[{"title":"学习总结（2022.04.25-2022.04.30）","path":"2022/04/30/学习总结（2022-04-25-2022-04-30）/","text":"数组和链表数组添加的时间复杂度: o(n) 数组删除的时间复杂度: o(n) 数组按下标查找的时间复杂度: o(1) 无序数组按值查找的时间复杂度: o(n) 有序数组按值查找的时间复杂度: o(logn) 链表的添加时间复杂度: o(1) 链表的删除时间复杂度: o(1) 链表的查找时间复杂度: o(n) 泛型泛型，就是参数化类型，在不确定传入的类型时，可以先设置一个参数来代指（类似于形参）。 基本语法如下： 123class 类名&lt;泛型类型1,…&gt;interface 接口名&lt;泛型类型1…&gt;public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 .) 可以定义多个泛型，但是最好不超过两个，如果需要两个以上的泛型，说明设计有问题。 在泛型类上定义的泛型，作用域仅在类名和类体内，即使是子类也不能继承。 泛型通配：？为泛型通配符，没有明确，就是Object以及任意类；？ extends E为向下限定，只能是E及其子类；？ super E为向上限定，只能是E及其父类。 泛型擦除：java中的泛型并不是真正的泛型，在编译之后，泛型会变成Object以及类型强转，泛型只是防止程序员对类型的随意转换。 红黑树红黑树是一个特殊的二叉搜索树，每个节点有红色和黑色两种颜色。 其中根节点和叶子（nil，叶子节点下的空节点）必须是黑色；父子节点不能都是红色节点；从叶子到根节点的路径上，黑色节点的数目是一样的。（黑高平衡） 红黑树通过旋转（类似于二叉搜索树）和分裂（类似于B树，向上和向下）保证黑高平衡和无连续红色节点。 集合类CollectionCollection是Collection集合体系的顶级接口，定义为一个数据容器。 Collection的子实现一些存储元素有序，一些存储元素无序；一些允许存储重复元素，一些不允许存储重复元素；一些允许存储null，一些不允许存储null。 API： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ------------------------------增删改查相关的api------------------------------// boolean add(E e)// 确保此 collection 包含指定的元素（可选操作）。// boolean addAll(Collection&lt;? extends E&gt; c)// 将指定 collection 中的所有元素都添加到此 collection 中（可选操作）。// boolean contains(Object o)// 如果此 collection 包含指定的元素，则返回 true。// boolean containsAll(Collection&lt;?&gt; c)// 如果此 collection 包含指定 collection 中的所有元素，则返回 true。 // boolean remove(Object o)// 从此 collection 中移除指定元素的单个实例，如果存在的话（可选操作）。// boolean removeAll(Collection&lt;?&gt; c)// 移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）。// boolean retainAll(Collection&lt;?&gt; c)// 仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）。 // ---------------------------------------集合类都具有的辅助方法----------------- // void clear()// 移除此 collection 中的所有元素（可选操作）。// boolean equals(Object o)// 比较此 collection 与指定对象是否相等。// int hashCode()// 返回此 collection 的哈希码值。// boolean isEmpty()// 如果此 collection 不包含元素，则返回 true。// int size()// 返回此 collection 中的元素数。 // ------------------------------------------特殊方法--------------------------// Object[] toArray()// 返回包含此 collection 中所有元素的数组。 // &lt;T&gt; T[] toArray(T[] a)// 返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同。// 只有数组类型与存储的数据类型相匹配，才能正常运行；如果传入的数组够长，那么返回的数组和传入的数组是一个数组，反之则不是；如果传入的数组过长，那么空位位置会置为null。// Iterator&lt;E&gt; iterator()// 返回在此 collection 的元素上进行迭代的迭代器。// Iterator类型的方法：// hasNext(): 向后还有没有元素可以遍历// next(): 向后遍历// remove(): 删除刚刚遍历过的元素; // 注意：java中的增强for循环就是由iterator方法实现的（数组不一样，数组的增强for循环在编译中是变成普通的fori循环） 并发修改异常：collection的一些子实现是线程不安全的，在使用Iterator遍历时会产生线程安全问题。所以一些子实现会维护一个标记，记录修改次数，每次修改次数都会增加。 Iterator对象遍历前，都会检查修改次数是否与原集合类一致，如果不一致，就会认为数据被其他线程修改，从而抛出并发修改异常。 但是即使在单线程情况下，如果在遍历过程中直接使用集合类的修改方法，也会抛出并发修改异常。所以在Iterator对象遍历时不要修改数据。 ListList是Collection的子接口，描述的数据结构是线性表。 List有序，允许存储重复元素，允许存储null。 API： 12345678910111213141516171819202122232425262728293031// void add(int index, E element)// 在列表的指定位置插入指定元素（可选操作）。 // boolean addAll(int index, Collection&lt;? extends E&gt; c)// 将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作）。 // E get(int index)// 返回列表中指定位置的元素。 // int indexOf(Object o)// 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。 // int lastIndexOf(Object o)// 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。// E remove(int index)// 移除列表中指定位置的元素（可选操作）。 // E set(int index, E element)// 用指定元素替换列表中指定位置的元素（可选操作）。// ListIterator&lt;E&gt; listIterator()// 返回此列表元素的列表迭代器（按适当顺序）。// ListIterator&lt;E&gt; listIterator(int index)// 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。// ListIterator类型的方法：// hasNext(): 向后还有没有元素可以遍历// next(): 向后遍历// remove(): 删除刚刚遍历过的元素; // hasPrevious(): 向前是否可以遍历// previous(): 向前遍历// List&lt;E&gt; subList(int fromIndex, int toIndex)// 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图。// subList并不是从源集合类中复制了数据，而是维护了一些标记指向源数据，在subList上操作，本质还是在操作源数据。// 所以不建议在使用subList中修改源数据，可能抛出并发修改异常。 ArrayListArrayList是List的子实现，描述的数据结构是线性表。 其底层结构是数组，数组默认长度为10，扩容倍数为1.5倍。 ArrayList存储结构有序，允许存储重复元素，允许存储null。 ArrayList线程不安全。 构造方法： 123456// ArrayList() // 构造一个初始容量为 10 的空列表。 // ArrayList(Collection&lt;? extends E&gt; c) // 构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。 // ArrayList(int initialCapacity) // 构造一个具有指定初始容量的空列表。 API： 123456// Object clone()// 返回此 ArrayList 实例的浅表副本。// void ensureCapacity(int minCapacity)// 如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。// void trimToSize()// 将此 ArrayList 实例的容量调整为列表的当前大小。 VectorVector是List的子类。描述的数据结构是线性表。 其底层结构是数组，数组默认长度为10，扩容倍数为2倍。 Vector存储结构有序，允许存储重复元素，允许存储null。 Vector线程安全。 LinkedListLinkedList是List的子实现，也是Deque的子实现。描述的数据结构是线性表/队列/双端队列/栈 其底层是双向链表。 LinkedList存储结构有序，允许存储重复元素，允许存储null。 LinkedList线程不安全。 构造方法： 1234// LinkedList() // 构造一个空列表。 // LinkedList(Collection&lt;? extends E&gt; c) // 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。 API: 123456789101112131415161718192021222324252627// 队列API// boolean offer(E e)// 将指定元素添加到此列表的末尾（最后一个元素）。// E poll()// 获取并移除此列表的头（第一个元素）// E peek()// 获取但不移除此列表的头（第一个元素）。// 双端队列API// boolean offerFirst(E e)// 在此列表的开头插入指定的元素。// boolean offerLast(E e)// 在此列表末尾插入指定的元素。// E peekFirst()// 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。// E peekLast()// 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。// E pollFirst()// 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。// E pollLast()// 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。// 栈API// E pop()// 从此列表所表示的堆栈处弹出一个元素。// void push(E e)// 将元素推入此列表所表示的堆栈。 QueueQueue是Collection的子接口，描述的数据结构是队列。 Queue存储元素有序，允许存储重复元素，不允许存储null。（因为Queue的poll方法返回null表示队列无元素，为避免混淆，所以不允许存储null） API: 123456789101112// boolean offer(E e)// 在队列中添加数据// E peek()// 查看队头元素// E poll()// 出队头// boolean add(E e)// 添加数据// E element()// 查看头元素// E remove()// 删除头元素 DequeDeque是Queue接口的一个子接口，描述的数据结构是队列/双端队列/栈。 Deque存储元素有序，允许存储重复元素，不允许存储null。 ArrayDequeArrayDeque是Deque接口的子实现。描述的数据结构是队列/双端队列/栈。 其底层结构是循环数组，数组默认长度为16，扩容倍数为2倍。 ArrayDeque存储元素有序，允许存储重复元素，不允许存储null。 ArrayDeque线程不安全。 BlockingQueueBlockingQueue是Queue的一个子接口，描述的数据结构是阻塞队列。 阻塞队列：大小有限的队列，常用于线程池。队满时，添加线程等待；队空时，删除线程等待。 SetSet接口是Collection的一个子接口，描述的数据结构是集合。 Set的子实现一些有序，一些无序；都不允许存储重复元素；一些允许存储null，一些不允许存储null。 HashSetHashSet是Set接口的子实现。 其底层结构是HashMap，HashSet添加的对象其实是HashMap的key值。 HashSet存储元素无序；不允许存储重复元素；允许存储null。 HashSet线程不安全。 构造方法： 12345678// HashSet() // 构造一个新的空 set，其底层 HashMap 实例的默认初始容量是 16，加载因子是 0.75。 // HashSet(Collection&lt;? extends E&gt; c) // 构造一个包含指定 collection 中的元素的新 set。 // HashSet(int initialCapacity) // 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和默认的加载因子（0.75）。 // HashSet(int initialCapacity, float loadFactor) // 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和指定的加载因子。 LinkedHashSetLinkedHashSet是HashSet的子类. 其底层结构是LinkedHashMap。 LinkedHashSet存储元素有序；不允许存储重复元素；允许存储null。 LinkedHashSet线程不安全。 TreeSetTreeSet是Set接口的子实现。 其底层结构是TreeMap。 TreeSet存储元素有序；不允许存储重复元素；不允许存储null。 TreeSet线程不安全。 MapMap是Map集合体系的顶级接口，存储key-value数据。 Map的子实现一些存储元素有序，一些存储元素无序；都不允许存储重复数据；一些允许存储null，一些不允许存储null（仅仅指key） API： 123456789101112131415161718192021222324252627282930313233 // -----------------------增删改查的api-------------------------// V put(K key, V value)// 将指定的值与此映射中的指定键关联（可选操作）。// void putAll(Map&lt;? extends K,? extends V&gt; m)// 从指定映射中将所有映射关系复制到此映射中（可选操作）。// V remove(Object key)// 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。// V get(Object key)// 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。// boolean containsKey(Object key)// 如果此映射包含指定键的映射关系，则返回 true。// boolean containsValue(Object value)// 如果此映射将一个或多个键映射到指定值，则返回 true。 // -----------------------集合类都有的api-------------------------// void clear()// 从此映射中移除所有映射关系（可选操作）。// boolean equals(Object o)// 比较指定的对象与此映射是否相等。// int hashCode()// 返回此映射的哈希码值。// boolean isEmpty()// 如果此映射未包含键-值映射关系，则返回 true。 // int size()// 返回此映射中的键-值映射关系数。 // -----------------------视图方法-------------------------// Set&lt;K&gt; keySet()// 返回此映射中包含的键的 Set 视图。// Collection&lt;V&gt; values()// 返回此映射中包含的值的 Collection 视图。// Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()// 返回此映射中包含的映射关系的 Set 视图。 HashMapHashMap是Map接口的具体子实现，底层结构是数组+链表+红黑树。数组的默认初始容量为16，扩容机制为2倍，默认的加载因子为0.75。 （加载因子用来控制HashMap的饱和度，默认阈值为16 * 0.75 = 12，如果超过12对键值对，HashMap扩容） HashMap存储元素无序；不允许存储重复的key；允许存储null作为key。 HashMap线程不安全。 HashMap中键值对的Hash值计算：(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); 如果一个新加入的key-value对，它的key值与已经存在的key值满足hash值相等，而且也满足值相等（==或equals），说明key值重复，此时会将新value值覆盖掉旧value值，并将旧value值返回出来。 HashMap在某一链表长度大于8时进行以下其中一种操作：当数组长度小于64时，会扩容数组并进行再散列；当数组长度大于等于64时，则会将链表转化为红黑树。 HashMap在删除节点时，如果删除的是红黑树上的节点，且该节点是红黑树的根节点/根节点的左右节点/根节点的左节点的左节点，此时会认为红黑树上节点过少，从而使红黑树转化为链表；HashMap在扩容进行再散列时，红黑树会被拆分，如果拆分后红黑树中的节点小于6个，红黑树转化为链表。 构造方法： 12345678// HashMap() // 构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。 // HashMap(int initialCapacity) // 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。 // HashMap(int initialCapacity, float loadFactor) // 构造一个带指定初始容量和加载因子的空 HashMap。 // HashMap(Map&lt;? extends K,? extends V&gt; m) // 构造一个映射关系与指定 Map 相同的新 HashMap。 HashMap没有额外的API，基本继承了Map接口的API。 LinkedHashMapLinkedHashMap是HashMap的一个子类，基本上完全复用了HashMap的底层结构和方法。 LinkedHashMap额外维护了一个双向链表保证迭代顺序。 LinkedHashMap存储元素有序；不允许存储重复的key；允许存储null作为key。 LinkedHashMap线程不安全。 TreeMapTreeMap是Map接口的子实现，描述的数据结构是红黑树。 其底层结构是链表。 TreeMap存储的元素有序；不允许存储重复的key；不允许存储null作为key。 因为TreeMap底层的数据结构是红黑树，所以key值需要比较大小，此时有两种实现比较的方式：存储的key值自身可以实现自然排序；TreeMap提供比较器。 构造方法： 12345678// TreeMap() // 使用键的自然顺序构造一个新的、空的树映射。 // TreeMap(Comparator&lt;? super K&gt; comparator) // 构造一个新的、空的树映射，该映射根据给定比较器进行排序。 // TreeMap(Map&lt;? extends K,? extends V&gt; m) // 构造一个与给定映射具有相同映射关系的新的树映射，该映射根据其键的自然顺序 进行排序。 // TreeMap(SortedMap&lt;K,? extends V&gt; m) // 构造一个与指定有序映射具有相同映射关系和相同排序顺序的新的树映射。 API: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// ------------------------TreeMap定义大小操作相关的api------------------------// Map.Entry&lt;K,V&gt; ceilingEntry(K key)// 大于等于给定key的最小键值对// K ceilingKey(K key)// 大于等于给定key的最小key// Map.Entry&lt;K,V&gt; floorEntry(K key)// 小于等于key的最大的键值对// K floorKey(K key)// 小于等于key最大的key// Map.Entry&lt;K,V&gt; higherEntry(K key)// 大于给定key的最小键值对// K higherKey(K key)// 大于给定key的最小key// Map.Entry&lt;K,V&gt; lowerEntry(K key)// 小于key的最大的键值对// K lowerKey(K key)// 小于key最大的key// Map.Entry&lt;K,V&gt; firstEntry()// 返回最小的键值对// K firstKey()// 返回最小的key// Map.Entry&lt;K,V&gt; lastEntry()// 返回最大的键值对// K lastKey()// 返回最大的key// Map.Entry&lt;K,V&gt; pollFirstEntry()// 删除最小的键值对// Map.Entry&lt;K,V&gt; pollLastEntry()// 删除最大的键值对// ---------------------视图方法-----------------------------// NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)// 返回此映射的部分视图，其键的范围从 fromKey 到 toKey。// SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey)// 返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。// SortedMap&lt;K,V&gt; tailMap(K fromKey)// 返回此映射的部分视图，其键大于等于 fromKey。// NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive)// 返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey。// SortedMap&lt;K,V&gt; headMap(K toKey)// 返回此映射的部分视图，其键值严格小于 toKey。// NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive)// 返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey。 HashTableHashTable是Map的子实现。 其底层结构是数组+链表。数组的初始容量为11，扩容倍数为2倍+1。 HashTable存储的元素无序；不允许存储重复的key；不允许存储null作为key，也不允许存储null作为value。 HashTable线程安全。 StreamStream流是jdk1.8时提供的一种处理集合数据的方法。它提供一种内部迭代的方式，允许我们用多个中间操作来串联成一个管道，如同流式风格，避免了我们在对数据集合进行操作时带来的代码冗长问题。 一个Stream流包括三个模块： 一个数据源，创建流。 多个中间操作，形成流。 一个终止操作，执行流，生成结果。 创建流： 12Collection collection = new ArrayList();Stream stream = collection.stream(); 形成流： 12345678910111213141516171819202122232425262728293031323334353637383940 List&lt;Person&gt; personList = StudentList.personList;// filter:用于通过设置条件过滤元素 // 获取所有北京地区的同学 List&lt;Person&gt; collect = personList.stream() .filter(d -&gt; d.getAddress().equals(Person.Address.BJ)) .collect(Collectors.toList());// distinct:去除重复元素 // 去除重复的同学 List&lt;Person&gt; collect = personList.stream() .distinct() .collect(Collectors.toList());// limit:获取指定数量的元素 // 获取三个年龄大于22岁的同学 List&lt;Person&gt; collect = personList.stream() .filter(d -&gt; d.getAge() &gt; 22) .limit(3) .collect(Collectors.toList());// skip:跳过前n个元素 // 获取年龄大于22岁的同学并跳过第一个 List&lt;Person&gt; collect2 = personList.stream() .filter(d -&gt; d.getAge() &gt; 22) .skip(1) .collect(Collectors.toList());// map:映射每个元素到对应的结果 // 获取所有学生姓名 List&lt;String&gt; collect = personList.stream() .map(a -&gt; a.getName()) .collect(Collectors.toList());// sorted:对流进行排序 // 对高于180的同学根据身高进行排序 List&lt;Person&gt; collect = personList.stream() .filter(a -&gt; a.getHeight() &gt; 180) .sorted(Comparator.comparing(Person::getHeight)) .collect(Collectors.toList()); 执行流： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// anyMatch:检查是否匹配一个元素 // 判断是否存在北京的同学 boolean b1 = personList.stream() .anyMatch(a -&gt; &#123; return a.getAddress() == Person.Address.BJ; &#125;);// allMatch:检查是否匹配所有元素 // 判断是否都是北京的同学 boolean b1 = personList.stream() .allMatch(a -&gt; &#123; return a.getAddress() == Person.Address.BJ; &#125;);// nonematch:检查是否没有匹配元素 // 判断是否不存在深圳的同学 boolean b1 = personList.stream() .noneMatch(a -&gt; &#123; return a.getAddress() == Person.Address.SZ; &#125;);// findAny:返回任意元素（默认第一个） // Optional类作为一个容器代表一个值存在或不存在，方法如下 // isPresent(): 如果 Optional包含值返回true, 否则返回false // ifPresent(代码块): 会将Optional包含的值, 传给指定的代码块 // get(): 如果Optional包含值, 返回包含的值, 否则抛出异常 // orElse(默认值): 如果Optional包含值, 返回包含的值, 否则返回默认值 // 返回任意一个同学 Optional&lt;Person&gt; any = personList.stream() .findAny();// findFirst:返回第一个元素 // 获得年龄最小的同学 Optional&lt;Person&gt; first = personList.stream() .sorted(Comparator.comparing(Person::getAge)) .findFirst();// forEach:遍历输出元素 // 遍历列表，输出学生姓名 personList.stream() .sorted(Comparator.comparing(Person::getAge)) .forEach(a -&gt; System.out.println(a.getName()));// count:返回元素数量 // 北京同学的数量 long count = personList.stream() .filter(a -&gt; a.getAddress() == Person.Address.BJ) .count();// reduce:计算元素 // reduce有双参方法，第一个元素为identity，为计算的初始值 // 班级同学年龄总和 Optional&lt;Integer&gt; reduce1 = personList.stream() .map(Person::getAge) .reduce((a, b) -&gt; &#123; return a + b; &#125;);// collect:收集结果 // 收集结果可以放进List、Map、Set、Collection中 // 获取所有学生姓名，放进List中 List&lt;String&gt; collect = personList.stream() .map(a -&gt; a.getName()) .collect(Collectors.toList());"},{"title":"剑指offer-day23","path":"2022/04/29/剑指offer-day23/","text":"数组中出现次数超过一半的数字最简单的想法当然是用哈希表或者排序，但是最优解是一个算法，叫摩尔投票法。 算法的大致思想是：记录一个投票数，与众数相同则投票数+1，否则-1。因为众数的数量超过数组长度的一半，那么统计整个数组的投票数会大于0。知道这个规律后，唯一的问题是怎么确定一个数是众数。那么就涉及到了第二个规律：数组中的某部分的投票数总和为0，并不会影响整体的票数。现在可以假设数组的第一个元素是众数，向后遍历，遇到相同的数时票数+1，否则-1，如果遇到票数为0的情况，则放弃这一块的遍历情况，转而设置下一个数为众数…直到遍历完成，此时票数一定大于0，指向的数即为众数。 123456789101112131415161718192021class Solution &#123; public int majorityElement(int[] nums) &#123; int vote = 0; int x = 0; for(int num : nums)&#123; // 当票数为0时，假设遍历至此的数为众数 if(vote == 0)&#123; x = num; &#125; // 如果后续遍历的数与该数相等，票数+1，否则-1 if(x == num)&#123; vote++; &#125; else&#123; vote--; &#125; &#125; // 返回最后指向的数 return x; &#125;&#125; 构建乘积数组提示了无法使用除法，那么只能使用乘法，最优解选择的方式是对原数组遍历两遍：第一遍只累乘在自己之前的数，第二遍则累乘在自己之后的数，这样就得到答案了。 1234567891011121314151617181920212223class Solution &#123; public int[] constructArr(int[] a) &#123; // 特殊情况：a为空数组，返回空数组 if(a.length == 0)&#123; return new int[0]; &#125; int[] b = new int[a.length]; // 因为第一个数只有自己之后的数的累乘，所以将b的第一个数置为1 b[0] = 1; // 遍历第一遍，b[i]的值都是在自己之前的数的累乘 for(int i = 1; i &lt; a.length; i++)&#123; b[i] = b[i - 1] * a[i - 1]; &#125; // 记录一个临时值，用来记录b[i]之后的数的累乘 int tmp = 1; // 因为最后一个数只有自己之前的数的累乘，之前已经计算完毕，所以从倒数第二个数开始 for(int i = a.length - 2; i &gt;= 0; i--)&#123; tmp *= a[i + 1]; b[i] *= tmp; &#125; return b; &#125;&#125;"},{"title":"剑指offer-day22","path":"2022/04/28/剑指offer-day22/","text":"数组中数字出现的次数Ⅰ说实话，位运算方面的算法真的很难想，基本都要靠别人的思路，代码虽然简洁但是很难看懂。 这道题目非常像只出现一次的数字，但是只出现一次的数字变成了两个，这说明原来遍历并异或的思路行不通了，但是这个思路是个出发点。在遍历并异或后，就可以获得两个不同的数异或的值，由于异或的特性（一者为0一者为1，结果为1，否则为0），可以确定在结果的二进制中，最低位的1所在的位，在两个数中分别是1和0，那么可以根据这个线索将数组分成两个，一个在该位全是1，另一个则全是0，而且相同的数，它们在该位的数一定相同，那么这两个数组中就是数对相同的数和一个不同的数，对这两个数组进行异或运算，得出来的就是结果了。 1234567891011121314151617181920212223242526272829class Solution &#123; public int[] singleNumbers(int[] nums) &#123; int sum = 0; // 获得整个数组异或后的值 for(int i : nums)&#123; sum ^= i; &#125; int n = 1; // 结果跟1进行与运算，等于0说明结果的倒数第一位是0，n左移一位让1从最低位移到倒数第二位，重复至找到第一个和结果进行与运算的值为1的n，此时n就是结果里最低位为1，其他位为0的值。 while((sum &amp; n) == 0)&#123; n &lt;&lt;= 1; &#125; int x = 0; int y = 0; // 根据n来对数组里每个数进行与运算，数的二进制在该位为0和在该位为1的值分成两组，对这两组分别进行异或运算 for(int i : nums)&#123; if((i &amp; n) != 0)&#123; x ^= i; &#125; else&#123; y ^= i; &#125; &#125; int[] res = &#123;x,y&#125;; return res; &#125;&#125; 数组中数字出现的次数Ⅱ这道题目的最优解引入了一个算法，叫有限状态转换机，但是我看不懂这个算法，只能作罢，直接背代码算了。 123456789101112// 看不懂class Solution &#123; public int singleNumber(int[] nums) &#123; int one = 0; int two = 0; for(int i : nums)&#123; one = one ^ i &amp; ~two; two = two ^ i &amp; ~one; &#125; return one; &#125;&#125; 其实题目并没有限制o(n)时间和o(1)空间，完全是可以用hashmap做的。"},{"title":"剑指offer-day21","path":"2022/04/27/剑指offer-day21/","text":"后面开始涉及位运算与数学知识了，由于这方面比较薄弱，题目基本都是不会做的，就直接看答案吧，争取把答案看懂就行。 二进制中1的个数最简单的想法就是把二进制转为字符串，遍历得到1的个数，当然这不是最优解，最优解是对每一位的数和1进行与运算（与运算，即只有在两数都是1时才返回1，其余可能都返回0），当返回值是1，说明该位位数是1，对计算总和+1，否则+0。然后再将二进制数往右移1位，一直移至n的所有位数都为0（即数的十进制为0）即可。（java中，&gt;&gt; 是右移位数的意思，后面跟的值是右移几位的意思，而 &gt;&gt;&gt; 则是右移的同时在缺失的高位补0）。 1234567891011public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int res = 0; while(n != 0)&#123;// 当n=0时，跳出循环 res += (n &amp; 1);// res累加n和1进行与运算的结果 n &gt;&gt;&gt;= 1;// n右移1位，高位补0 &#125; return res; &#125;&#125; 不用加减乘除做加法题目摆明了要用位运算，最优解是通过观察加法的规律来得出位运算的解决方案。 观察得知，当位数都是0时，它们的和是0，进位是0；当位数有一个是1时，它们的和是1，进位是0；当位数都是1时，它们的和是0，进位是1。可以发现和的计算跟异或运算是一样的（异或运算，即是当两数不相同时，返回值为1，两数相同则返回0），进位的计算跟与运算后是一样的。那么加法可以换算成和与进位的和（其中进位需要左移一位，这样才能体现进位）。 12345678910class Solution &#123; public int add(int a, int b) &#123; while(b != 0) &#123; // 当进位为 0 时跳出 int c = (a &amp; b) &lt;&lt; 1; // c = 进位 a ^= b; // a = 非进位和 b = c; // b = 进位 &#125; return a; &#125;&#125;"},{"title":"剑指offer-day20","path":"2022/04/26/剑指offer-day20/","text":"重建二叉树又是一道知道思路但是不知道怎么实现的题目，直接放答案吧。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int[] preorder; Map&lt;Integer, Integer&gt; inorderMap = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) &#123; this.preorder = preorder; for(int i = 0; i &lt; inorder.length; i++)&#123; inorderMap.put(inorder[i], i); &#125; return recur(0, 0, inorder.length - 1); &#125; public TreeNode recur(int root, int left, int right)&#123; if(left &gt; right)&#123;// 发生越界，返回null return null; &#125; int i = inorderMap.get(preorder[root]);// 获得根节点在中序序列的下标 TreeNode node = new TreeNode(preorder[root]);// 新建根节点 node.left = recur(root + 1, left, i-1);// 根节点的左节点连接递归生成的左子树 node.right = recur(root + 1 + i - left, i+1, right);// 右节点连接递归生成的右子树 return node; &#125;&#125; 数值的整次方如果用简单的迭代会超时，就是摆明了不准用迭代，正确的方式是用变化的二分法，每次将幂数折半，将要累乘的数换成该数的二次方，如果幂数是奇数的话就把多出来的一个数乘进返回值里。 123456789101112131415161718class Solution &#123; public double myPow(double x, int n) &#123; double res = 1; long b = n;// 用long来接int值，防止负数转正数时发生溢出 if(b &lt; 0)&#123;// 幂数小于0，底数要变为分数 b = -b; x = 1 / x; &#125; while(b &gt; 0)&#123; if(b % 2 == 1)&#123;// 幂数为奇数，将多出的数放入答案 res *= x; &#125; x *= x;// 底数变成平方 b /= 2;// 幂数变为一半，向下取整 &#125; return res; &#125;&#125; 二叉搜索树的后序遍历序列完全不会，直接放答案。 1234567891011121314151617class Solution &#123; public boolean verifyPostorder(int[] postorder) &#123; // 用栈存储倒序的后序遍历，即是“根，右，左”的逆序先序遍历 Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int root = Integer.MAX_VALUE; for(int i = postorder.length - 1; i &gt;= 0; i--) &#123; // 因为按照遍历逻辑当前节点一定是父节点的左孩子，如果出现左孩子的值大于父节点，说明不是后序遍历序列，返回false if(postorder[i] &gt; root) return false; // 如果栈顶大于当前节点，说明栈内有当前节点的父节点，出栈至栈空，栈底为父节点 while(!stack.isEmpty() &amp;&amp; stack.peek() &gt; postorder[i]) root = stack.pop(); // 当前节点压栈 stack.add(postorder[i]); &#125; return true; &#125;&#125;"},{"title":"剑指offer-day19","path":"2022/04/25/剑指offer-day19/","text":"求1+2+…+n感觉本质上是一道脑筋急转弯题目，因为迭代和递归的方式都被锁死了，只能另辟蹊径完成，答案用的是逻辑运算符的短路，也见到有人用异常的，我没有想出来，就以答案为标准吧。 123456789class Solution &#123; int res = 0; public int sumNums(int n) &#123; // 运用逻辑运算符短路，递归至n=1时发生短路，后面的递归计算终止 boolean x = n &gt; 1 &amp;&amp; sumNums(n-1) &gt; 0; res += n; return res; &#125;&#125; 二叉搜索树的最近公共祖先自己想出来了递归，答案给的最优解是迭代，但是实际实验过发现两者并没有差别，那就放自己的答案吧。 因为是二叉搜索树，可以利用搜索树的特性，判断两个节点是否在一侧，在哪一侧则往哪边遍历，否则就返回当前的根节点。 12345678910111213141516171819202122/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; // 在左子树往左遍历，在右子树往右遍历 if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123; return lowestCommonAncestor(root.left,p,q); &#125; else if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123; return lowestCommonAncestor(root.right,p,q); &#125; // 两边各一个返回当前根节点 return root; &#125;&#125; 二叉树的最近祖先相比上题少了一个搜索树的条件，显然变难了，自己写的是递归+遍历，有很高的时间复杂度，最优解只使用了递归。 1234567891011121314class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; // 递归终止条件：root为空，或root为p、q中的一个 if(root == null || root == p || root == q) return root; // 递归遍历根节点的左右子树，返回null、p或q TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); // left为空表示p、q都在右子树，返回右子树的根节点，反之同理 if(left == null) return right; if(right == null) return left; // 两者都不为空表示p、q在异侧，直接返回根节点 return root; &#125;&#125;"},{"title":"剑指offer-day18","path":"2022/04/25/剑指offer-day18/","text":"二叉树的深度第一道自己写出来的树题！可以说非常具有纪念意义了，时空复杂度也不输最优解，自豪地放上自己的解。 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int depth; int max; public int maxDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; depth = 0; max = 0; preorder(root); return max; &#125; public void preorder(TreeNode root)&#123;// 前序遍历 depth++;// 遍历该节点，深度+1 if(root == null)&#123;// 若节点为空，说明到达叶节点，深度-1并记录此时的最大深度 depth--; max = Math.max(max,depth); return; &#125; preorder(root.left);// 递归遍历左节点和右节点 preorder(root.right); depth--;// 遍历完成，深度-1 &#125;&#125; 平衡二叉树半写半抄完成的，用的是从上到下的递归，然而并不是最优解，最优解是从下到上的递归+剪枝。使用后序遍历从叶子节点往上遍历，每次遍历时看以该节点为根的子树是否是平衡二叉树，如果是则返回该子树的高度，否则返回-1，表示该树不是平衡二叉树。 123456789101112131415161718class Solution &#123; public boolean isBalanced(TreeNode root) &#123; return recur(root) != -1; &#125; private int recur(TreeNode root) &#123;// 返回平衡二叉树的高度，不是平衡二叉树则返回-1 if (root == null) return 0;// 遍历至叶子节点，返回高度为0 // 遍历左右子树，如果左右子树不是平衡二叉树，返回-1 int left = recur(root.left); if(left == -1) return -1; int right = recur(root.right); if(right == -1) return -1; // 如果左右子树的高度差&lt;2,表示是平衡二叉树，返回该根节点的高度，否则返回-1 return Math.abs(left - right) &lt; 2 ? Math.max(left, right) + 1 : -1; &#125;&#125;"},{"title":"剑指offer-day17","path":"2022/04/23/剑指offer-day17/","text":"最小的k个数非常简单的题目，如果利用Arrays.sort()基本等于白给，可是这就是明着考你排序算法的。我自己手动写了一个快排，虽然还是不太熟悉，多写写就好了。 最优解是利用快排的特点，在基准值左边的数都小于基准值，当基准值的下标为k时，左边则是答案了。 1234567891011121314151617181920212223242526class Solution &#123; public int[] getLeastNumbers(int[] arr, int k) &#123; if (k &gt;= arr.length)&#123;// 特殊值返回：如果k大于数组的长度，直接返回数组 return arr; &#125; return quickSort(arr, k, 0, arr.length - 1); &#125; private int[] quickSort(int[] arr, int k, int l, int r) &#123; int i = l, j = r;// 定义两个指针指向数组的头和尾 while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[j] &gt;= arr[l]) j--;// 找到基准值右边小于基准值的值 while (i &lt; j &amp;&amp; arr[i] &lt;= arr[l]) i++;// 找到基准值左边大于基准值的值 swap(arr, i, j);// 交换值 &#125; swap(arr, i, l);// 交换头/尾指针和基准值指针，使得基准值左边都小于基准值，右边都大于基准值 if (i &gt; k) return quickSort(arr, k, l, i - 1);// 如果基准值在k的右边，则对基准值左边的数组进行快排 if (i &lt; k) return quickSort(arr, k, i + 1, r);// 如果基准值在k的左边，则对基准值右边的数组进行快排 return Arrays.copyOf(arr, k);// 返回0-(k-1)的下标的数组 &#125; private void swap(int[] arr, int i, int j) &#123;// 交换方法 int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125;&#125; 数据流中的中位数看完题目我还嗤之以鼻，这也叫hard题？刷刷写完一提交，过是过了，跑了1600ms… 看了最优解，用到了大根堆和小根堆的知识，代码是不一定看得懂了，只能说尽力而为吧。 12345678910111213141516171819class MedianFinder &#123; Queue&lt;Integer&gt; A, B; public MedianFinder() &#123; A = new PriorityQueue&lt;&gt;(); // 小顶堆，保存较大的一半 B = new PriorityQueue&lt;&gt;((x, y) -&gt; (y - x)); // 大顶堆，保存较小的一半 &#125; public void addNum(int num) &#123; if(A.size() != B.size()) &#123;// 插入数量为奇数， A.add(num); B.add(A.poll()); &#125; else &#123; B.add(num); A.add(B.poll()); &#125; &#125; public double findMedian() &#123; return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;// 如果两堆容量相等，说明此时为偶数，各取堆顶值/2；反之说明为奇数，只取小顶堆中的值。 &#125;&#125;"},{"title":"剑指offer-day16","path":"2022/04/23/剑指offer-day16/","text":"把数组排成最小的数看到题目就想到自然排序了，但是直接使用是不可以的，正确的排序方式应该是看两字符串x和y，是否满足x+y&lt;y+x（比如3和30，如果按默认的字典序排列应该是3在前，但是两者的组合330明显大于303，所以应该是看是否满足330&lt;303,不满足则30排在前面） 1234567891011121314class Solution &#123; public String minNumber(int[] nums) &#123; StringBuffer res = new StringBuffer(); String[] s = new String[nums.length]; for(int i = 0; i &lt; nums.length; i++)&#123;// 将int转为String s[i] = String.valueOf(nums[i]); &#125; Arrays.sort(s, (s1,s2) -&gt; (s1+s2).compareTo(s2+s1));// 实现comparable接口的自然排序 for(String str : s)&#123; res.append(str); &#125; return res.toString(); &#125;&#125; 扑克牌的顺子一开始没有很好的想法，就放弃看答案了。 123456789101112131415class Solution &#123; public boolean isStraight(int[] nums) &#123; int zeroCount = 0; Arrays.sort(nums);// 对数组排序 for(int i = 0; i &lt; nums.length - 1; i++)&#123; if(nums[i] == 0)&#123; zeroCount++;// 记录大小王的个数，在0-2之间 &#125; else if(nums[i] == nums[i+1])&#123;// 出现相等的数表示无法成为顺子 return false; &#125; &#125; return nums[nums.length-1] - nums[zeroCount] &lt; 5;// 用最大的数减去最小的非0数，如果差值小于5说明可以成为顺子 &#125;&#125;"},{"title":"学习总结（2022.04.19-2022.04.24）","path":"2022/04/22/学习总结（2022-04-19-2022-04-24）/","text":"类加载器分类： Bootstrap ClassLoader 根类加载器，负责核心类的加载 Extension ClassLoader 扩展类加载器，负责扩展目录中jar包的加载 Sysetm(App) ClassLoader 系统类加载器/应用加载器，负责自定义类的加载 User ClassLoader 自定义类加载器，自定义的类加载器 双亲委派模型：当自定义类进行类加载时，并不是一开始就由系统类加载器进行加载的，而是会交给扩展类加载器，扩展类加载器又会交给根类加载器，但是根类加载器在核心类的jar包中找不到自定义的类，于是又会原路返回至系统类加载器，最后还是由系统类加载器执行。 注解注解是代码里面的一些特殊标记，可以在编译、类加载、运行时被读取，并执行相应的处理。注解可以在不改变原有逻辑的情况下，补充一些信息。注解作为一种数据类型，跟class、interface具有同等地位。 注解的使用方式与修饰符一样，可以给任何一种数据写上注解（类、接口、构造器、变量…） 自定义注解： 123456789101112// 语法权限修饰符 @interface 注解名字&#123; // 注解体 属性类型 属性名(); 属性类型 属性名(); 属性类型 属性名(); .....&#125;//举例public @interface MyAnno &#123;&#125; 注解的使用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// @注解名(属性1 = value1,属性2 = value2) // 注解使用 @MyAnno3(name = &quot;zs&quot;,age = 20) public static void func() &#123; &#125;// 例子：获取注解信息public class Demo &#123; public static void main(String[] args) throws Exception&#123; //获取Login注解里的信息 打印一下 // 获取字节码文件对象 Class&lt;?&gt; c = Class.forName(&quot;_23annotation.com.cskaoyan._04handle.Demo&quot;); // 获取方法对象 Method method = c.getDeclaredMethod(&quot;login&quot;); // 再判断方法上使用了注解 isAnnotationPresent boolean annotationPresent = method.isAnnotationPresent(Login.class); System.out.println(annotationPresent); if (annotationPresent) &#123; // 是 , 获取这个注解实例 getAnnotation Login annotation = method.getAnnotation(Login.class); // 获取属性 String name = annotation.name(); String password = annotation.password(); System.out.println(name); System.out.println(password); &#125; &#125; @Login public static void login() &#123; &#125;&#125;// 使用元注解修饰@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@interface Login &#123; // 定义属性 String name() default &quot;root&quot;; String password() default &quot;123456&quot;;&#125; 元注解：描述注解的注解。常用的元注解有： @Retention元注解，来定义我们自己定义的注解的保留级别. 123RetentionPolicy.RUNTIMERetentionPolicy.CLASS // 默认RetentionPolicy.SOURCE @Target元注解，注解可以作用的目标 1234ElementType.TYPE// 整个类ElementType.FIELD// 成员变量 ElementType.CONSTRUCTOR// 构造方法 ElementType.METHO// 成员方法 GC如何确定垃圾： 引用计数算法：给对象添加一个引用计数器，每当有引用指向它，计数器+1；每当引用失效，计数器-1。当计数器为0，表示该对象不可被引用。但是引用计数算法无法应用在循环引用中。 根搜索算法：以一个叫”GC Roots”的对象为起点向下搜索，看一个对象是否存在连接至GC Root的引用链，如果没有表示该对象不可被引用。GC使用根搜索算法。 如何回收垃圾： 标记清除算法：首先标记出所有需要回收的对象，再统一回收；或者标记出所有存活的对象，统一回收未被标记的对象。虽然实现简单，但是会产生很多内存碎片。 标记复制算法：将一块内存划分成容量相等的两块，每次使用其中一块，当内存用完后，将还存活的对象复制至另一块内存中，再把已满的内存全部清理。虽然实现简单且不容易产生内存碎片，但是内存利用率降低了，且存活对象较多时，会产生许多不必要的开销，降低效率。 标记整理算法：同标记清除算法一样，将所有需要回收的对象标记，但是它不会直接清理，而是将存活的对象都往一端移动，移动完成后清除边界外的所有对象。这样虽然不会产生内存碎片，但是效率却降低了。 分代收集算法：根据对象的存活时间将内存划分为新生代、老年代和永久代，新生代中的对象大部分都是存活时间较短的，老年代中的对象则是存活时间较长的。 新创建的对象会放入新生代中，新生代空间使用的是标记复制算法，将新生代空间划为一个eden空间和两个survivor空间（survivor1、survivor2），其中eden空间用来放置新建的对象，survivor1和survivor2则用来放置复制一遍和复制两遍后存活的对象。当过了一定时间后，survivor2中的对象会放至老年代。 老年代中因为存活对象较多，一般使用标记整理算法。 何时回收垃圾： 申请堆空间失败，表示堆空间已满，触发GC。 系统进入休眠一段时间触发GC。 主动调用GC。 设计模式五大原则： 单一职责原则：每个类只负责自己的部分。 开闭原则：一个类或模块应该对拓展开放，对修改关闭。 里氏替换原则：任何父类可以出现的地方，子类都可以出现。 接口隔离原则：一个接口只提供一个对外的功能。 依赖倒置原则：上层模块不应该依赖于底层模块，而应该依赖于抽象类或接口；抽象类或接口不应该依赖于具体实现类，具体实现类应该依赖于抽象类或接口。 单例设计模式： 保证一个类只有一个对象，防止频繁的创建和销毁对象，避免对共享资源的多重占用。 实现方法：构造方法私有；提供返回实例的静态方法；提供自身类型的全局变量。 123456789101112131415161718public class Singleton1 &#123; //- 提供自身类型的全局的成员变量 private static Singleton1 instance; // - 构造方法私有 private Singleton1() &#123; &#125; //- 提供静态方法,返回实例 public static Singleton1 getInstance() &#123; // 最终要返回singleton1对象 // 做判断 if (instance == null) &#123; instance = new Singleton1(); &#125; return instance; &#125;&#125; 工厂设计模式： 可以通过一个工厂批量生产对象，同时隐藏创建对象的一些细节，标准化产生实例。 123456789101112131415161718192021222324252627282930313233public class FruitFactory &#123; // 提供1个静态方法 返回具体水果对象 public static Fruit getInstance(String name) &#123; Fruit fruit = null; if (&quot;apple&quot;.equals(name)) &#123; fruit = new Apple(); &#125; else if (&quot;orange&quot;.equals(name)) &#123; fruit = new Orange(); &#125; else if (&quot;banana&quot;.equals(name)) &#123; fruit = new Banana(); &#125; else &#123; System.out.println(&quot;生产不了!&quot;); &#125; // 返回水果对象 return fruit; &#125; // 不修改原有的代码逻辑 实现功能 public static Fruit getInstance2(String className) throws Exception &#123; // 根据全限定名 获取字节码文件对象 Class&lt;?&gt; c = Class.forName(className); // 获取构造方法 Constructor&lt;?&gt; declaredConstructor = c.getDeclaredConstructor(); // 实例化对象 Fruit fruit = (Fruit) declaredConstructor.newInstance(); // 返回对象 return fruit; &#125;&#125;"},{"title":"剑指offer-day15","path":"2022/04/22/剑指offer-day15/","text":"二叉树中和为某一值的路径完全没思路，直接放答案。 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();// 定义一个path来记录每次递归结束后的结果 LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int target) &#123; firstOrder(root,target);// 先序遍历 return res; &#125; public void firstOrder(TreeNode root, int target)&#123; if(root == null)&#123;// 节点为空时返回 return; &#125; path.add(root.val);// path添加递归的值 target -= root.val;// 目标值减去当前递归的值 if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null)&#123;// 如果目标值为0且该节点为叶子节点，将已经递归完成的path放入答案列表中 res.add(new LinkedList(path)); &#125; pathSum(root.left,target);// 递归遍历左节点 pathSum(root.right,target);// 递归遍历右节点 path.removeLast();// 执行至此表示寻找符合的叶子节点失败，将本次遍历的节点退出，回溯至上个节点 &#125;&#125; 二叉搜索树与双向链表这道题想到了中序遍历，但是对双链表还是不太熟悉，没做出来，半抄了一个答案。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val,Node _left,Node _right) &#123; val = _val; left = _left; right = _right; &#125;&#125;;*/class Solution &#123; Node head;// 定义头节点和尾节点 Node pre; public Node treeToDoublyList(Node root) &#123; if(root == null)&#123;// 树为空返回null return null; &#125; inorder(root);// 以尾节点为指针，进行中序遍历 head.left = pre;// 遍历完成，将头尾节点连接 pre.right = head; return head; &#125; public void inorder(Node root)&#123; if(root == null)&#123;// 遍历至空节点返回 return; &#125; inorder(root.left); if(pre != null)&#123;// 此时尾节点若还没赋值表示头尾节点未初始化，需要初始化头节点；反之则让尾节点指向当前节点 pre.right = root; &#125; else&#123; head = root; &#125; root.left = pre;// 当前节点的尾指针指向尾节点 pre = root;//尾节点跳至当前节点 inorder(root.right); &#125;&#125; 二叉搜索树的第k大节点这道题倒是写出来了，但是还是老问题，时空复杂度非常感人，看了答案发现用了一个逆序的中序遍历，而且提前终止了遍历，所以能有非常优秀的时空复杂度。 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int res; int k; public int kthLargest(TreeNode root, int k) &#123; this.k = k; inorder(root);// 逆序中序遍历 return res; &#125; public void inorder(TreeNode root)&#123; if(root == null || k == 0)&#123;// 当遍历至空节点时返回；当k已经为0时，提前终止遍历 return; &#125; inorder(root.right); if(--k == 0)&#123;// 当k-1 = 0时，表示当前遍历的节点就是答案，赋值给res res = root.val; &#125; inorder(root.left); &#125;&#125;"},{"title":"剑指offer-day14","path":"2022/04/21/剑指offer-day14/","text":"矩阵中的路径涉及到图的范围了，只能说是力所不能及，直接放答案吧，主要是DFS的思想怎样用代码表现出来。 123456789101112131415161718192021222324252627282930class Solution &#123; public boolean exist(char[][] board, String word) &#123; char[] words = word.toCharArray(); for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[0].length; j++)&#123; if(dfs(board,words,i,j,0))&#123;// 遍历找到第一个等于字符串头的字母，开始DFS return true; &#125; &#125; &#125; // 没有找到或者没有路径，返回false return false; &#125; public boolean dfs(char[][] board, char[] word, int i, int j, int k)&#123; // 终止条件有：遍历时超出边界值；遍历的值不等于字符串中的值 if(i &lt; 0 || i &gt;= board.length || j &lt; 0 || j &gt;= board[0].length || board[i][j] != word[k])&#123; return false; &#125; // k为字符串的下标，如果此时k等于字符串长度，说明寻找到路径，直接返回true if(k == word.length - 1)&#123; return true; &#125; board[i][j] = &#x27;\\0&#x27;;// 遍历过的地方设为空，防止遍历回来 boolean res = (dfs(board,word,i+1,j,k+1) || dfs(board,word,i-1,j,k+1) || dfs(board,word,i,j+1,k+1) || dfs(board,word,i,j-1,k+1));// 分别遍历上下左右，只要有一个符合条件即可 board[i][j] = word[k];// 将遍历过的地方重新赋值，防止影响下一次遍历 return res;// 返回结果 &#125;&#125; 机器人的运动范围跟上题有些相似，就是返回值从boolean改成了int，参考着答案跌跌撞撞地写下来了。 123456789101112131415161718192021222324class Solution &#123; boolean[][] visited;// 定义一个boolean数组，来表示该元素是否被访问过 public int movingCount(int m, int n, int k) &#123; visited = new boolean[m][n]; return dfs(0,0,m,n,k);// 从左上角开始遍历 &#125; public int bitSum(int m, int n)&#123;// 计算位数和，因为题目只取两位数，就方便着写 int m1 = m % 10; int m2 = m / 10; int n1 = n % 10; int n2 = n / 10; return m1+m2+n1+n2; &#125; public int dfs(int i,int j, int m, int n,int k)&#123; // 遍历失败条件：遍历超出范围；遍历的位置的位数和大于要求数；该位置早被遍历过 if(i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || bitSum(i,j) &gt; k || visited[i][j])&#123; return 0;// 返回0表示此处不是机器人能到达的地方，不能计入总数 &#125; visited[i][j] = true;// 遍历成功，将这个位置设为已访问过 return 1+dfs(i+1,j,m,n,k)+dfs(i-1,j,m,n,k)+dfs(i,j+1,m,n,k)+dfs(i,j-1,m,n,k);// 因为成功，所以总数+1 &#125;&#125;"},{"title":"剑指offer-day13","path":"2022/04/21/剑指offer-day13/","text":"调整数组顺序一开始是想的最简单的方法，用两个数组来记录奇数和偶数，遍历原数组一遍就行，但是明显不是最优解。最优解是用双指针从数组两边往中间遍历，头指针记录奇数，尾指针记录偶数，如果头指针遇到偶数就停止，转而遍历尾指针；尾指针遇到奇数就跟头指针的偶数交换，遍历直至两指针相遇。 123456789101112131415161718class Solution &#123; public int[] exchange(int[] nums) &#123; int i = 0; int j = nums.length - 1; while(i &lt; j)&#123;// 遍历直至两指针相遇 while(nums[i] % 2 != 0 &amp;&amp; i &lt; j)&#123;// 头指针遇到偶数停止 i++; &#125; while(nums[j] % 2 == 0 &amp;&amp; i &lt; j)&#123;// 尾指针遇到奇数停止 j--; &#125; int tmp = nums[i];// 交换 nums[i] = nums[j]; nums[j] = tmp; &#125; return nums;// 返回原数组 &#125;&#125; 和为s的两个数字还是双指针…用一个头指针和一个尾指针指向数组两端，求两个指针所指元素的和，大于目标值尾指针向前移，反之头指针向后移，直至等于目标值，返回两个指针指向的元素。 12345678910111213141516171819class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int i = 0;// 维护一个头指针和一个尾指针 int j = nums.length - 1; while(i &lt; j)&#123;// 如果头指针超过尾指针，推出循环 while(nums[i] + nums[j] &lt; target &amp;&amp; i &lt; j)&#123;// 小于target，头指针后移 i++; &#125; while(nums[i] + nums[j] &gt; target &amp;&amp; i &lt; j)&#123;// 大于target，尾指针前移 j--; &#125; if(nums[i] + nums[j] == target)&#123;// 等于target，退出循环 break; &#125; &#125; int[] res = &#123;nums[i],nums[j]&#125;; return res; &#125;&#125; 翻转单词顺序一开始是用split()方法来分割字符串的，虽然写出来了但是时空复杂度不好，看了答案也发现并不推荐这种做法，利用双指针会更好。 用两个指针都指向string的尾部，前指针i遍历至空格，与后指针j一起获取了第一个不含空格的子字符串，用一个StringBuffer接住该字符串，i则继续遍历，不过此时是遍历至第一个字符，再将j移到此处，重复至遍历完成。 12345678910111213141516171819class Solution &#123; public String reverseWords(String s) &#123; s.trim();// 将s头尾的空格去掉 int i = s.length() - 1;// 维护两个指针 int j = i; StringBuffer sb = new StringBuffer(); while(i &gt;= 0)&#123; while(i &gt;= 0 &amp;&amp; s.charAt(i) != &#x27; &#x27;)&#123;// 找到第一个空格 i--; &#125; sb.append(s.substring(i+1,j+1) + &quot; &quot;);// 获取并添加子字符串+&quot; &quot; while(i &gt;= 0 &amp;&amp; s.charAt(i) == &#x27; &#x27;)&#123;// 找到第一个字符 i--; &#125; j = i;// 后指针指向第一个字符 &#125; return sb.toString().trim();// 完成后尾部会多出一个空格，除去空格 &#125;&#125;"},{"title":"剑指offer-day12","path":"2022/04/21/剑指offer-day12/","text":"合并两个排序的链表还是双指针的题目，一开始是想直接在两个链表上处理的，后来发现会出现漏元素的问题，就跟着答案老老实实地用一条新链表来接。 思路很简单，用两个指针p和q遍历两个链表，p&lt;=q时将p指向的元素放入新建的链表，反之则放入q指向的元素，遍历至一个指针遍历完成，将新链表指向未遍历完的那个指针就完成了。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null)&#123; return l2; &#125; if(l2 == null)&#123; return l1; &#125; ListNode p = l1;// 创建两个指针 ListNode q = l2; ListNode head = new ListNode(-1);// 创建新链表头和一个头指针 ListNode pre = head; while(p != null &amp;&amp; q != null)&#123;// 遍历两个链表 if(p.val &lt;= q.val)&#123; ListNode cp = p; head.next = cp; head = head.next; p = p.next; &#125; else&#123; ListNode cq = q; head.next = cq; head = head.next; q = q.next; &#125; &#125; if(p != null)&#123;// 其中一个链表遍历完成，遍历另一个链表 head.next = p; &#125; if(q != null)&#123; head.next = q; &#125; return pre.next; &#125;&#125; 两个链表的第一个公共节点这个并没有想出来怎么做，还是看答案吧。 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA == null || headB == null)&#123;// 其中一个节点为空，返回null return null; &#125; ListNode p = headA;// 建立两个指针 ListNode q = headB; while(p != q)&#123; if(p == null)&#123;// 当headA的指针遍历完成后，改为从headB再遍历一次 p = headB; &#125; else&#123; p = p.next; &#125; if(q == null)&#123;// 当headB的指针遍历完成后，改为从headA再遍历一次 q = headA; &#125; else&#123; q = q.next; &#125; &#125; // p、q相等时，跳出循环并输出p，这就是公共节点 return p; &#125;&#125;"},{"title":"剑指offer-day11","path":"2022/04/21/剑指offer-day11/","text":"删除链表的节点思路很简单，维护一个双指针，一个指向现节点，一个指向前节点，找到要删除的节点，让前节点指向现节点的下一个节点，再让现节点指向空指针即可。主要是删除头节点的问题，我选择再维护一个头指针preHead，而答案是将其作为特殊情况处理，直接返回头节点指向的链表。 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode deleteNode(ListNode head, int val) &#123; ListNode pre = new ListNode(-1);// pre指向头指针 ListNode preHead = pre;// preHead指向头指针 ListNode cur = head;// cur指向链表中的头指针 pre.next = cur;// 将自建的头指针和链表中的头指针连接 while(cur != null)&#123; if(cur.val == val)&#123;// 删除节点 pre.next = cur.next; cur.next = null; &#125; pre = cur; cur = cur.next; &#125; return preHead.next; &#125;&#125; 链表中倒数第k个节点跟上面一样，维护一个双指针，都先指向头节点，根据k值让p节点向前移动，当两个节点相距k-1时q节点和p节点一起前移，到p节点指向链表尾节点时结束，返回q节点所指向的链表即可。 12345678910111213141516171819202122/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode getKthFromEnd(ListNode head, int k) &#123; ListNode p = head;// 维护两个节点p、q ListNode q = head; for(int i = 0; i &lt; k-1; i++)&#123;// 迁移p节点 p = p.next; &#125; while(p.next != null)&#123;// p节点和q节点一起前移 q = q.next; p = p.next; &#125; return q;// 返回q节点指向的链表 &#125;&#125;"},{"title":"剑指offer-day10","path":"2022/04/20/剑指offer-day10/","text":"把数字翻译成字符串有一点像青蛙跳台阶，但是递归条件有点不一样。 维护三个指针a=f(0)=1、b=f(1)=1、c = 1，遍历整个数字（为了方便遍历需要把数字转为字符串），从第二个数字开始，如果该数字和前一个数字组成的数&gt;=10且&lt;=25，说明这个数字的翻译方法有f(0)+f(1)种，否则只有f(1)种。c的值等于这个数的翻译方法，此时c指向该数字，a指向b，b指向c，循环至遍历结束。 1234567891011121314151617181920class Solution &#123; public int translateNum(int num) &#123; String s = String.valueOf(num); int a = 1;// 代表f(0) int b = 1;// 代表f(1) int c = 1;// 代表f(0)+f(1)，防止只有一个数的特殊情况，初始值为1 for(int i = 1; i &lt; s.length(); i++)&#123; int n = Integer.parseInt(s.substring(i-1,i+1)); if(n &gt;= 10 &amp;&amp; n &lt;= 25)&#123;// 如果遍历的数与前一个数组合符合范围，说明遍历至该数时的翻译方法有f(n-1)+f(n-2)种 c = a + b; &#125; else&#123;// 不符合，明遍历至该数时的翻译方法有f(n-1)种 c = b; &#125; a = b;// a跳至f(n-2) b = c;// b跳至f(n-1) &#125; return c; &#125;&#125; 最长不含重复字符的子字符串自己写了一个虽然过了，但是时空复杂度真的丢人…算是一个暴力解吧。 同样是动态规划思想，用一个哈希表来记录每个字符最后出现的位置，遍历整个字符串，获得一个字符过去出现的最后位置和现在出现的位置，相减获得重复前的子字符串长度。用一个数tmp来记录。最后返回每次记录后tmp的最大值。 12345678910111213141516171819class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); int tmp = 0; int res = 0; for(int i = 0; i &lt; s.length(); i++)&#123; int j = map.getOrDefault(s.charAt(i),-1);//无值则初始化map，初始值设为-1，有值则获取该字符前一次出现的位置 map.put(s.charAt(i),i);// 修改位置至当前 if(tmp &lt; i - j)&#123;// 如果tmp&lt;i-j，说明还未找到相同的字符，tmp长度+1 tmp++; &#125; else&#123;// 如果tmp&gt;=i-j，说明出现了相同的字符，tmp=i-j tmp = i - j; &#125; res = Math.max(tmp,res);// 获取tmp的最大值 &#125; return res; &#125;&#125;"},{"title":"剑指offer-day9","path":"2022/04/20/剑指offer-day9/","text":"连续子数组的最大和思路跟之前的股票的最大利润是一样的，遍历一次数组，如果之前遍历的值的和sum加上这次遍历的值num都小于该值，那么就将起点改为num，并用一个值res来记录每次遍历后的最大值。 1234567891011121314class Solution &#123; public int maxSubArray(int[] nums) &#123; int res = Integer.MIN_VALUE; int sum = 0; for(int num : nums)&#123; sum += num;// 记录遍历至该值的和 if(sum &lt;= num)&#123; sum = num;// 如果总和都没有该值大，将记录的起点改为该值 &#125; res = Math.max(res,sum);// 记录每次遍历后总和间的最大值 &#125; return res; &#125;&#125; 礼物的最大价值相当于上题的加强版，使用一个二维数组，并且增加了一个向下还是向右的判断，但是核心思想是不变的。 遍历数组来记录每次行进的最大总和，放在这次行进的节点中。从左上角开始遍历，因为从第一行遍历和从第一列遍历都是累加的，可以做一个判断：当要遍历的值位于这两个特殊位置时，只需要获取它的左边（或上边）的和，累加至该值并替换。其他时候则需要对左边的值和上边的值进行比较，取较大的累加至该值并替换。最后输出右下角的总和。 123456789101112131415161718192021class Solution &#123; public int maxValue(int[][] grid) &#123; for(int m = 0; m &lt; grid.length; m++)&#123; for(int n = 0; n &lt; grid[0].length; n++)&#123; if(m == 0 &amp;&amp; n == 0)&#123;// 位于起点，跳过遍历 continue; &#125; if(m == 0)&#123;// 位于第一行，只累加左边的值 grid[m][n] += grid[m][n-1]; &#125; else if(n == 0)&#123;// 位于第一列，只累加上边的值 grid[m][n] += grid[m-1][n]; &#125; else&#123;// 其他情况需要判断左边和上边的值，取较大值累加 grid[m][n] += Math.max(grid[m][n-1],grid[m-1][n]); &#125; &#125; &#125; return grid[grid.length - 1][grid[0].length - 1];// 返回右下角值 &#125;&#125;"},{"title":"学习总结（2022.04.12-2022.04.20）","path":"2022/04/18/学习总结（2022-04-12-2022-04-18）/","text":"IO的分类按照数据流向分(以内存为参照物)： 输入：外设-&gt;内存 输出：内存-&gt;外设 按照数据类型分： 字节流(1B = 0000 0000) 字符流 字节流一般用于非文本文件；字符流一般用于文本文件。 为什么会有字符流？因为用字节流读取非英文和数字的数据可能会发生错误 4个抽象基类及其子类 字节输出流 字节输入流 字符输出流 字符输入流 抽象父类 OutputStream&lt;br&gt;void write(byte[] b) InputStream&lt;br/&gt;int read(byte[] b) Writer&lt;br&gt;void write(char[] c)&lt;br/&gt;void writer(String s) Reader&lt;br&gt;int read(char[] c) 文件 FileOutputStream(File file, boolean append) FileInputStream(File file) FileWriter(File file, boolean append) FileReader(File file) 缓冲 BufferedOutputStream(OutputSteam out, int size) BufferedInputStream(InputStream in, int size) BufferedWriter(Writer out, int size) BufferedReader(Reader in, int size)&lt;br&gt;String readLine() 转换(字节转字符) OutputStreamWriter(OutputStream out, String charsetName) InputStreamReader(InputStream in, String charsetName) 数据(输入/输出java基本类型) DataOutputStream(OutputStream out)&lt;br&gt;void writeInt(int a)... DataInputStream(InputStream in)&lt;br&gt;int readInt()... 打印(输入/输出字符串) PrintStream(OutputStream out) &lt;br&gt;int print(int a)... PrintWriter(Writer out)&lt;br&gt;int print(int a) 对象(序列化/反序列化) ObjectOutputStream(OutputStream out)&lt;br&gt;void writeObject(Object obj) ObjectInputStream(InputStream in)&lt;br&gt;Object readObject() 换行方式“\\r\\n” System.lineSeparator() 标准IO流System.in本质是InputStream System.out本质是PrintStream 进程/线程 同步/异步进程是操作系统调度的基本单位，线程是cpu调度的基本单位 同步是调用可以立即得到结果，但是需要等待；异步是调用不能立即得到结果，但是可以不等待 java程序运行原理jvm是多线程的，每次运行至少有两个线程：main线程和GC线程 java是抢占式线程调度，但是java自带的setPriority()方法并不能改变线程的优先级，因为java中的优先级是静态的，只能给操作系统一个建议，实际上操作系统有自己的一套线程优先级 多线程的实现方式 定义一个类继承Thread类，重写run()方法，创建该类对象，通过start()创建线程(如果使用run()只是普通的调用子类方法，并不能达到创建多线程的效果)特点：单继承 定义一个类实现Runnable接口，重写run()方法，创建Runnable子类对象，再创建Thread对象，并将该子类对象作为参数传递。特点：实现接口 定义一个类实现Callable接口，重写call()方法，创建FutureTask对象并将该类的对象作为参数传递，再创建Thread对象将FutureTask对象作为参数传递。特点：有返回值 线程API123456789String getName();// 获得该线程的名称void setName(String name);// 设置该线程的名称Static Thread currentThread();// 返回当前正在执行的线程对象的引用static void sleep(long millis);// 线程休眠，进入阻塞，但是不释放资源void join();// 主线程等待执行该方法的子线程终止。join在哪个线程的代码块中被调用，该线程就是主线程；哪个线程调用了join，该线程就是子线程void setDaemon(boolean on);// 设置一个线程为守护线程。当正在运行的线程都为守护线程时，jvm停止运行；该方法必须在线程启动前调用；GC线程是守护线程。void wait();// 线程进入阻塞并释放资源。void notify();// 线程唤醒随机一个阻塞的进程。void notifyAll();// 线程唤醒全部进入阻塞的进程。 安全中断线程线程执行完毕就会中断。但是很多时候我们需要自己控制线程终止，然而API中的stop()方法存在线程不安全问题，所以一般定义一个成员变量boolean flag来控制。 synchronized关键字基本语法 123synchronized(锁对象)&#123; // 对共享数据的访问操作&#125; 锁对象可以是： 任意一个Object及其子类对象，java中的任意对象都可以当锁，都存在wait()、notify()和notifyAll()方法。 this关键字，即是令包含该代码块的类对象当锁。 字节码文件对象(类名.class) Lock类成员方法： 12lock();// 获取锁unlock();// 释放锁 lock是一把真正的锁类，可以让我们看到加锁解锁的过程。 死锁的原因及解决方法原因：一般出现在同步代码块嵌套，因为2个或以上的线程抢夺资源而造成互相等待。 12345678910synchronized(ObjA)&#123; synchronized(objB)&#123; &#125;&#125;synchronized(objB)&#123; synchronized(ObjA)&#123; &#125;&#125; 解决方式： 更改加锁顺序 12345678910synchronized(ObjA)&#123; synchronized(objB)&#123; &#125;&#125;synchronized(ObjA)&#123; synchronized(objB)&#123; &#125;&#125; 再加一把锁，将非原子操作改为原子操作 1234567891011121314synchronized(ObjC)&#123; synchronized(objB)&#123; synchronized(objA)&#123; &#125; &#125;&#125;synchronized(objC)&#123; synchronized(ObjA)&#123; synchronized(objB)&#123; &#125; &#125;&#125; 线程池线程池有三种子类： ExecutorService newCachedThreadPool()：根据需要创建新线程，也可以自动删除，60s处于空闲状态的线程。线程数量可变。 ExecutorService newFixedThreadPool(int nThreads)：线程数量固定，维护一个无界队列（暂存已提交的来不及执行的任务），按照任务的提交顺序，将任务执行完毕。 ExecutorService newSingleThreadExecutor()：单个线程，其他特点如上。 两种成员方法： 12void submit(Runnable task);// 提交任务void shutdown();// 启动顺序关闭 定时任务与定时器Timer定时器是一种工具，线程用其安排以后在后台线程中执行的任务。可安排任务执行一次，或者定期重复执行。 两种构造方法： 12Timer();// 创建一个新计时器Timer(boolean isDaemon);// 创建一个新计时器，可以指定其相关的线程作为守护程序运行 四种成员方法： 1234schedule(TimerTask task, Date time);// 从time时间开始执行。schedule(TimerTask task, long delay, long period);// 在延迟delay毫秒后，每period毫秒执行一次。schedule(TimerTask task, Date firstTime, long period);// 从firstTime时间开始执行，之后每period毫秒执行一次。scheduleAtFixedRate(TimerTask task, long delay, long period);// 设置一个继承了TimerTask类的定时任务类，在延迟delay毫秒后，每period毫秒执行一次该任务。(TimerTask定时任务，使用时继承该类并重写run()方法) UDP/TCPUDP发送端步骤： DatagramSocket datagramSocket = new DatagramSocket(int port); 创建发送端的Socket对象 DatagramPacket sendPacket= newDatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port); 创建用于发送的数据报包 datagramSocket.send(sendPacket); 把包发送出去 datagramSocket.close(); 关闭Socket UDP接收端步骤： DatagramSocket datagramSocket = new DatagramSocket(int port); 创建接收端的Socket对象 DatagramPacket receivePacket = new DatagramPacket(byte[] buf, int offset, int length); 创建用于接收的数据报包 datagramSocket.receive(receivePacket); receive方法进行接收 byte[] data = receivePacket.getData(); 解析数据 datagramSocket.close(); 关闭Socket UDP可以通过多线程优化，达到两端互相通信的效果 TCP客户端步骤： Socket socket = new Socket(String host, int port); 创建客户端的socket对象 OutputStream out = socket.getOutputStream(); 从socket中获取输入/输出流 out.write(byte[] b); 利用输入/输出流进行读写操作 socket.close(); 关闭Socket TCP服务端步骤： ServerSocket serverSocket = new ServerSocket(int port); 创建服务端的ServerSocket 对象 Socket socket = serverSocket.accept(); 利用accept方法建立连接,得到socket对象 InputStream in = socket.getInputStream(); 从socket中获取输入/输出流 in.read(byte[] b); 利用输入/输出流进行读写操作 socket.close(); 关闭Socket TCP可以通过ObjectInputStream/ObjectOutputStream来实现序列化/反序列化传输，也可以通过FileInputStream/FileOutputStream来实现文件传输。 反射反射时在类运行时获取其信息的一种技术，具体方式是获取字节码文件（也就是.class文件）对象，然后从对象中获取该类的构造器、变量、方法等成员，且能无视修饰符强行访问。 获取字节码的三种方式： 对象.getClass() 类名.class Class.forName(String classname) classname是全类名 因为第三种才能获取较为完整的对象，一般使用第三种。 反射获得构造方法的方式有： 1234Constructor[] getConstructors();// 获取所有public方法Constructor[] getDeclaredConstructors();// 获取所有构造方法，包括privateConstructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes);// 获取单个public方法Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes);// 获取单个构造方法，包括private 获得构造方法后可以创建对象。 Object o = constructor.newInstance(&quot;张三&quot;, 20, true); 如果构造器非public修饰，需要暴力破解。 constructor.setAccessible(true); 反射获得成员变量的方式有： 1234Field[] getFields();// 获取所有public变量Field[] getDeclaredFields();// 获取所有成员变量Field getField(String name);// 获取指定public成员变量Field getDeclaredField(String name);// 获取指定成员变量 获得成员变量后可以给成员变量赋值。 12Object o = declaredConstructor.newInstance();// 实例化对象nameFiled.set(o, &quot;张三&quot;);// 对该对象的名字成员变量赋值 也可以获得某个成员变量。 Object o1 = nameFiled.get(o); 如果成员变量非public修饰，需要暴力破解，方式同上。 反射获得成员方法的方式有： 1234Method[] getMethods();// 获取所有public方法Method[] getDeclaredMethods();// 获取所有方法Method getMethod(String name, Class&lt;?&gt;... parameterTypes);// 获取指定public方法Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes);// 获取指定方法 可以利用Method调用对象方法。 Object invoke(Object obj, Object... args); 第一个是要调用的对象，后面是多个可变参数类型。 Class类API： 1234String getName();// 获取全类名String getSimpleName();// 获取简单名Class&lt;?&gt; getInterfaces();// 获取接口Class&lt;?&gt; getSuperclass();// 获取父类 Field类API： 12Class&lt;?&gt; getType();// 获取变量类型int getModifiers();// 获取变量类型，以int值表示，可用Modifier.toString()转为String Method类API： 12String getReturnType();// 获取返回值类型Class&lt;?&gt;[] getParameterTypes();// 获取方法参数 配置文件配置文件(properties)里有各种配置信息，以键值对方式存储。 配置文件中注释使用#号。 Properties类表示了一个持久的属性集，可以获得配置文件中的数据。 一种构造方法： ​ Properties() 创建一个无默认值的空属性列表 两种成员方法： 12void load(InputStream inStream);// 从输入流中读取属性列表（键和元素对）String getProperty(String key);// 用指定的键在此属性列表中搜索属性"},{"title":"剑指offer-day8","path":"2022/04/18/剑指offer-day8/","text":"斐波那契数列递归经典题目，但是使用传统递归会超时，需要使用优化的记忆递归。 123456789101112131415161718class Solution &#123; public int fib(int n) &#123; // 超出时间限制 // if(n == 0 || n == 1)&#123; // return n; // &#125; // return fib(n-1) + fib(n-2); int a = 0;// a表示f(0) int b = 1;// b表示f(1) int sum = 0; for(int i = 0; i &lt; n; i++)&#123; sum = (a + b) % 1000000007;// sum表示f(2) = f(0) + f(1) a = b;// a向前移动至f(1) b = sum;// b向前移动至f(2) &#125; return a;// 循环结束，a=f(n) &#125;&#125; 青蛙跳台阶其实就是斐波那契数列，只要记住上一题的解法，这道题就是一模一样，只是初始条件改变了。 12345678910111213class Solution &#123; public int numWays(int n) &#123; int a = 1;// f(0) = 1 int b = 1;// f(1) = 1，f(2) = f(0) + f(1) = 2 int sum = 0; for(int i = 0; i &lt; n; i++)&#123; sum = (a+b) % 1000000007; a = b; b = sum; &#125; return a; &#125;&#125; 股票的最大利润这道题用动态规划没有想出来，看了答案才发现原来这么淳朴…大体思路是遍历整个数组，记录一个最低价，如果后面有更低的价格就更新最低价；没有的话就计算差值，差值最大即为答案。 1234567891011class Solution &#123; public int maxProfit(int[] prices) &#123; int cost = Integer.MAX_VALUE; int profit = 0; for(int price : prices)&#123; cost = Math.min(price,cost);// 更新最低价 profit = Math.max(profit,price - cost);// 更新最大差值 &#125; return profit; &#125;&#125;"},{"title":"剑指offer-day7","path":"2022/04/16/剑指offer-day7/","text":"树的子结构大致思路是有的：通过先序遍历来遍历主树，如果有等于子树根节点的节点，再先序遍历比较。 但是实现得磕磕绊绊，没法了，进行一个答案的抄。 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSubStructure(TreeNode A, TreeNode B) &#123;// 遍历A树 if(A == null || B == null)&#123;// A或B为空，返回false return false; &#125; return (compare(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B)); &#125; public boolean compare(TreeNode A,TreeNode B)&#123;// 比较B树 if(B == null)&#123;// 如果先序遍历完成，返回true return true; &#125; if(A == null || (A.val != B.val))&#123;// 如果A树为空或者两数节点不相等，返回false return false; &#125; return (compare(A.left,B.left) &amp;&amp; compare(A.right,B.right));// 两数节点相等，再先序遍历比较其左节点和右节点 &#125;&#125; 感觉递归的结束条件确实很难想。 二叉树的镜像直接摆烂看答案 1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode mirrorTree(TreeNode root) &#123; if(root == null)&#123;// 遍历至子节点返回null return null; &#125; TreeNode tmp = root.left; root.left = mirrorTree(root.right); root.right = mirrorTree(tmp); return root; &#125;&#125; 可以发现这道题目其实跟交换数字的思路很像，可以靠这个来记忆。 对称二叉树跟第一题很像，都是需要遍历比较。 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root == null)&#123;// root为空返回true return true; &#125; return compare(root.left,root.right); &#125; public boolean compare(TreeNode left, TreeNode right)&#123;// 遍历比较两个节点 if(left == null &amp;&amp; right == null)&#123;// 两个节点同时遍历完毕，说明对称，返回true return true; &#125; if(left == null || right == null || left.val != right.val)&#123;// 其中一个节点先遍历完毕或两节点不相等，返回false return false; &#125; return(compare(left.left,right.right) &amp;&amp; compare(left.right,right.left)); &#125; &#125;"},{"title":"剑指offer-day6","path":"2022/04/14/剑指offer-day6/","text":"从上到下打印二叉树经典题目，使用层序遍历来实现，具体实现方法就是用一个队列来记录节点，一个ArrayList记录答案。当前节点入队后，再将其左右节点入队，随后出队，ArrayList记录节点的值，直至队列为空。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int[] levelOrder(TreeNode root) &#123; LinkedList&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); q.add(root);// 将根节点入队 TreeNode t; while((t = q.peek()) != null)&#123;// 队头为空跳出 if(t.left != null)&#123;// 左节点入队 q.add(t.left); &#125; if(t.right != null)&#123;// 右节点入队 q.add(t.right); &#125; res.add(q.poll().val);// 取出队头获得其值 &#125; int[] arr = new int[res.size()]; for(int i = 0; i&lt;res.size(); i++)&#123;// ArrayList转数组 arr[i] = res.get(i); &#125; return arr; &#125;&#125; 从上到下打印二叉树Ⅱ上一题的变种，加入了对当前层数的判断，需要在之前的代码上做一些修改，主要是用一个int值记录当前层数中的节点数。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); if(root != null)&#123; q.add(root); &#125; while(q.size() != 0)&#123; int i = q.size();// 记录当前层数的节点数 List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); while(i &gt; 0)&#123; TreeNode t = q.poll(); tmp.add(t.val); if(t.left != null)&#123; q.add(t.left); &#125; if(t.right != null)&#123; q.add(t.right); &#125; i--; &#125; res.add(tmp); &#125; return res; &#125;&#125; 从上到下打印二叉树Ⅲ究极加强版，在上一题的基础上加上了蛇形遍历，其实就是需要对层数的奇偶进行判断，而且需要把临时队列tmp更改为双端队列，当层数为奇时从尾部插入，反之从头部插入 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); if(root != null)&#123; q.add(root); &#125; while(q.size() != 0)&#123; int i = q.size(); LinkedList&lt;Integer&gt; tmp = new LinkedList&lt;&gt;(); while(i &gt; 0)&#123; TreeNode t = q.poll(); if(res.size() % 2 == 0)&#123;// 层数判断 tmp.addLast(t.val); &#125; else&#123; tmp.addFirst(t.val); &#125; if(t.left != null)&#123; q.add(t.left); &#125; if(t.right != null)&#123; q.add(t.right); &#125; i--; &#125; res.add(tmp); &#125; return res; &#125;&#125;"},{"title":"剑指offer-day5","path":"2022/04/13/剑指offer-day5/","text":"二维数组中的查找一开始就想到了线性查找，但是是从左上方开始的，发现判定条件不好写后看了看答案，才知道从右上方开始会比较方便（即大于查找值向左移，小于查找值向下移） 提交几次都发现会有边界溢出的情况，无奈只能跟答案一一对照，发现答案事先用了一个int值接住了要判断的值，这样就不会发生边界溢出了。 12345678910111213141516171819202122class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; if(matrix.length == 0)&#123; return false; &#125; int m = 0;// 行数 int n = matrix[0].length - 1;// 列数 while(n &gt;=0 &amp;&amp; m &lt; matrix.length)&#123; int num = matrix[m][n];// 用一个int表示当前值，防止边界溢出 if(num == target)&#123; return true; &#125; if(num &gt; target)&#123; n--; &#125; if(num &lt; target)&#123; m++; &#125; &#125; return false; &#125;&#125; 旋转数组的最小数字不想多说了，就是二分法，重点是怎么设定跳出条件，不然就是寄（是的，我又没做出来） 1234567891011121314// 将数组划分成旋转的和未旋转的// 左指针指向未旋转数组的最后一个元素，右指针指向旋转数组的第一个元素class Solution &#123; public int minArray(int[] numbers) &#123; int i = 0, j = numbers.length - 1; while (i &lt; j) &#123; int m = (i + j) / 2; if (numbers[m] &gt; numbers[j]) i = m + 1;// 说明m还在未旋转数组中，左指针指向m的下一个元素 else if (numbers[m] &lt; numbers[j]) j = m;// 说明m在旋转数组中，右指针指向m else j--;// m正好指向与旋转数组第一个元素相等的元素，右指针左移至与左指针重合 &#125; return numbers[i]; &#125;&#125; 第一个只出现一次的字符一开始就把题目想错了，以为类似为**&quot;aadadaad&quot;**的字符应该返回为空，但是实际上是返回a（a、d两两配对，第一个只剩一个的字母是a） 这道题应该是用哈希表解决的，放出代码。 1234567891011class Solution &#123; public char firstUniqChar(String s) &#123; HashMap&lt;Character, Boolean&gt; dic = new HashMap&lt;&gt;(); char[] sc = s.toCharArray(); for(char c : sc) dic.put(c, !dic.containsKey(c));// 没有则修改为true，有则改为false for(char c : sc) if(dic.get(c)) return c; return &#x27; &#x27;; &#125;&#125;"},{"title":"剑指offer-day4","path":"2022/04/11/剑指offer-day4/","text":"数组中重复的数字最简单的思路当然是使用哈希表来记录重复数，老老实实的写了。 123456789101112131415161718192021class Solution &#123; public int findRepeatNumber(int[] nums) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i : nums)&#123; if(map.containsKey(i))&#123; map.put(i,map.get(i)+1); &#125; else&#123; map.put(i,1); &#125; &#125; int res = 0; for(int i : nums)&#123; if(map.get(i) &gt; 1)&#123; res = i; break; &#125; &#125; return res; &#125;&#125; 结果发现这时空复杂度也太高了…愤而看官方解，发现它也是这么写的…只不过优化了一下过程。 发现自己两年前居然做过这道题，而且时空复杂度都比我现在的优秀，看了一眼： 12345678910class Solution &#123; public int findRepeatNumber(int[] nums) &#123; Arrays.sort(nums); for(int i = 1; i &lt; nums.length;i++)&#123; if(nums[i] == nums[i-1]) return nums[i]; &#125; return 0; &#125;&#125; …也不知道是聪明还是偷懒，利用了题目中 长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内 的条件，自作聪明地用排序来解决问题，不过这应该也算是另辟蹊径吧… 但这道题的最优解还真是利用了这个条件，因为数组内的数不会超过下标值，所以可以利用值对应下标的方法来检测是否有重复，即数字0交换至对应下标0，以此类推，直到交换值和被交换的值相等，说明这个值是重复值。 12345678910111213141516class Solution &#123; public int findRepeatNumber(int[] nums) &#123; int i = 0; while(i &lt; nums.length) &#123; if(nums[i] == i) &#123;// 如果值一开始就对应，则跳过该次循环 i++; continue; &#125; if(nums[nums[i]] == nums[i]) return nums[i];// 交换值和被交换的值相等，说明这个值是重复值 int tmp = nums[i];// 交换两个值 nums[i] = nums[tmp]; nums[tmp] = tmp; &#125; return -1; &#125;&#125; 在排序数组中查找数字 Ⅰ遍历的方法最简单也是最low的，放一个二分法的答案吧。 1234567891011121314151617181920212223class Solution &#123; public int search(int[] nums, int target) &#123; // 搜索右边界 right int i = 0, j = nums.length - 1; while(i &lt;= j) &#123; int m = (i + j) / 2; if(nums[m] &lt;= target) i = m + 1; else j = m - 1; &#125; int right = i; // 若数组中无 target ，则提前返回 if(j &gt;= 0 &amp;&amp; nums[j] != target) return 0; // 搜索左边界 right i = 0; j = nums.length - 1; while(i &lt;= j) &#123; int m = (i + j) / 2; if(nums[m] &lt; target) i = m + 1; else j = m - 1; &#125; int left = j; return right - left - 1; &#125;&#125; 0~n-1中缺失的数字想了很久的二分，但是跳出条件总是写不出，怒而写出暴力解，直接遍历查询。 跟上题一样，还是放出二分的答案吧。 1234567891011121314// 将数组分为两部分：nums[i] == i，nums[i] != i// 用i记录前一数组的最后一个元素，j记录后一数组的第一个元素// 以i &lt;= j来作为跳出条件class Solution &#123; public int missingNumber(int[] nums) &#123; int i = 0, j = nums.length - 1; while(i &lt;= j) &#123; int m = (i + j) / 2; if(nums[m] == m) i = m + 1; else j = m - 1; &#125; return i; &#125;&#125; 感觉静不下心来想二分，都是怎么简单怎么来了，看来得好好练一下二分。"},{"title":"学习总结（2022.04.07-2022.04.11）","path":"2022/04/09/学习总结（2022-04-07-2022-04-11）/","text":"String常量池每次创建字符串常量时，JVM会检查常量池是否存在该常量，如果存在则直接返回该常量的实例引用，没有才会在常量池中创建该常量对象。 例子 123String s1 = &quot;abc&quot;;String s2 = &quot;abc&quot;;System.out.println(s1 == s2)// ==是判断两个引用是否指向同一对象，返回true String两种实例化方式的区别 直接赋值的方式 String s = &quot;abc&quot;; 通过构造方法 String s = new String(&quot;abc&quot;) 第一种只会创建一个对象，第二种则会创建两个对象：一个是与第一种相同的创建方式，一个则是因为new关键字而创建的。虽然两者并不是同一个对象，但它们共用一个value数组（即String类中的char数组）（如果常量池中早已有第0，一种方式创建好的对象，那么第二种方式也只会创建一个对象，即new关键字创建的对象） 第一种会在常量池中创建对象，第二种会在堆上创建对象。 字符串拼接字符串拼接时有两种情况： 在常量池中创建新的对象 在堆上创建新的对象 这两个对象并不是同一个对象，用==判别会返回false。 只要拼接的字符串中有一个是以引用变量的形式出现的（比如String s、new String(&quot;abc&quot;)）那么该字符串就是在堆上创建对象。只有拼接时都是以直接赋值的方式创建时，才会在常量池中创建对象（若常量池中已存在拼接后的对象，则不会创建新的，而是使引用指向该对象） 自然排序一般使用Comparable接口和Comparator接口实现。 Comparable接口一般在希望能实现排序的类中实现，通过重写compareTo()方法来达到排序的效果。 a1.compareTo(a2)的返回值若大于0，说明a1对象大于a2，a1排在后面；小于0，说明a1对象小于a2，a1排在前面；等于0则说明a1等于a2。 重写后可以通过Arrays.sort()或Collections.sort()进行自动排序。 Comparator接口一般用于匿名内部类排序，相比Comparable接口更加灵活，依赖于带比较器的Arrays.sort(T[] a, Comparator&lt;? super T&gt; c) ，排序规则跟Comparable接口相同。 示例： 1Arrays.sort(students,(stu1,stu2)-&gt;stu1.getAge() - stu2.getAge());// 根据学生年龄排序 StringBuffer，StringBuilder都是长度可变的字符串类，StringBuilder线程不安全，StringBuffer线程安全。 throws，throwthrows用在方法声明后面，跟的是异常类名；可以跟多个异常类名，用逗号隔开。 throws表示出现异常的一种可能性，并不一定会发生这些异常，且throws修饰的方法由该方法的调用者来处理。 throw用在方法体内，跟的是异常对象名，只能抛出一个异常对象。 throw表示抛出异常，可以由方法体内的语句处理，但执行throw则一定抛出了某种异常。 自定义异常可以自己写一个类并继承Exception 或RuntimeException 来自定义异常。 示例： 123456789101112131415161718192021222324252627282930313233class MyException extends Exception&#123; public MyException() &#123; &#125; public MyException(String message) &#123; super(message); &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; try &#123; func(); &#125; catch (MyException e) &#123; e.printStackTrace(); &#125; &#125; private static void func() throws MyException&#123; // 创建scanner对象 Scanner scanner = new Scanner(System.in); // 输入一个分数 System.out.println(&quot;请输入一个分数&quot;); String score = scanner.nextLine(); int i = Integer.parseInt(score); // 判断一下分数是否满足我们的要求 if (i &lt; 0 || i &gt; 100) &#123; // 认为成绩异常的 // 抛出异常 throw new MyException(&quot;分数异常&quot;); &#125; &#125;&#125; 路径表示对于类 UNIX 平台，绝对路径名的前缀始终是 “/“。相对路径名没有前缀。表示根目录的绝对路径名的前缀为 “/“ 且名称序列为空。​ 绝对路径： /home/st/6379.conf​ 相对路径： st/a.txt​ 根目录： / 对于 Microsoft Windows 平台，包含盘符的路径名前缀由驱动器号和一个 “:” 组成。如果路径名是绝对路径名，还可能后跟 “\\“​ 绝对路径： e:\\st\\a.txt​ 相对路径：没有盘符前缀 st\\a.txt 文件过滤器FileFilter接口可以用于实现文件的高级获取功能，通过设置条件来过滤文件，常用匿名内部类实现。 示例： 12File[] files = dir.listFiles((pathname) -&gt; pathname.getName().endsWith(&quot;.java&quot;));// 过滤后缀名为.java的文件"},{"title":"剑指offer-day3","path":"2022/04/09/剑指offer-day3/","text":"替换空格一看到这道题我就优雅地敲下代码 12345class Solution &#123; public String replaceSpace(String s) &#123; return s.replace(&quot; &quot;,&quot;%20&quot;); &#125;&#125; …咳咳，大佬说过，不要成为API Coder，不然35岁就去开滴滴了。 但其实思路还是很简单，因为java的特性，字符串不能被直接修改，只能创建一个新对象，所以在空间复杂度上是怎么都干不过C++的。那么就新建一个可变字符串对象StringBuffer来接收修改后的String对象，可以最大程度优化空间。（其实可以替换为StringBulider，但是在本题中没有明显的优化） 123456789101112131415161718class Solution &#123; public String replaceSpace(String s) &#123; if(s == null || s == &quot;&quot;)&#123; return null; &#125; StringBuilder res = new StringBuilder(); for(int i = 0; i &lt; s.length(); i++)&#123; if(s.charAt(i) == &#x27; &#x27;)&#123; res.append(&quot;%20&quot;); &#125; else&#123; res.append(s.charAt(i)); &#125; &#125; return res.toString(); // return s.replace(&quot; &quot;,&quot;%20&quot;); &#125;&#125; 最后吐槽一下，自己写的方法时空复杂度甚至还没有包装好的replace()低…这道题可能只是单纯用来折磨C++程序员的吧… 左旋转字符串一看到这我又优雅地敲下代码 12345class Solution &#123; public String reverseLeftWords(String s, int n) &#123; return s.substring(n, s.length()) + s.substring(0, n); &#125;&#125; 没想到这么写居然是对的，而且还是最优解… 当然，我一开始并不是这么写的，而是仿造796.旋转字符串的解来写的，用一个字符串来接收两个拼接起来的目标字符串，再返回其中与目标字符串等长的结果字符串。 123456class Solution &#123; public String reverseLeftWords(String s, int n) &#123; String s1 = s + s; return s1.substring(n,s.length() + n); &#125;&#125; 空间复杂度当然没有API好，毕竟自创了一个字符串。 （今天题目挺水的，不过周末了，就放过我吧）"},{"title":"剑指offer-day2","path":"2022/04/08/剑指offer-day2/","text":"从尾到头打印链表简单题，但是实现方法与答案有些不同。 我考虑的是用一个ArrayList来记录链表中的值，最后逆序赋值给一个int数组。答案用的是模拟栈的LinkedList。我尝试了两个方法，发现时空复杂度并没有什么变化，所以就放上自己的答案吧。 12345678910111213141516171819202122/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int[] reversePrint(ListNode head) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(head != null)&#123; list.add(head.val); head = head.next; &#125; int[] res = new int[list.size()]; for(int i = 0; i &lt; list.size(); i++)&#123; res[i] = list.get(list.size() - i - 1); &#125; return res; &#125;&#125; 反转链表经典题目了，但是发现自己死活做不出来，总是有空指针异常，一看答案发现语句顺序错了…但总体思路是对的。利用三个指针来指向前元素、现元素和后元素，然后进行反转操作，操作顺序为： next指针指向当前元素的后一个元素 cur指向的当前元素的指针改为指向pre pre改为指向cur指向的元素 cur改为指向next指向的元素 唯一要注意的点是next指针需要在循环内创建，否则在链表本身为空时会报空指针。 1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head)&#123; ListNode pre = null; ListNode cur = head; while(cur != null)&#123; ListNode next = cur.next;// next指针指向后元素 cur.next = pre;// cur的指针改为指向pre pre = cur;// pre改为指向cur指向的元素 cur = next;// cur改为指向next指向的元素 //next = cur.next;// 自己写的报空指针，不能写在后面，因为当cur在尾指针null时，无法获取next &#125; return pre; &#125;&#125; 之前有想过同上一题目一样，用一个辅助栈来完成反转，看了答案发现这样做并没有三指针快，就放弃这个思路了。 复杂链表的复制完全不会做，选择睡大觉（恼） 好好看了看答案，大概知道思路是怎样的，复述一下。 有两种解法：辅助哈希表和拼接链表，因为后者在空间复杂度上优于前者，所以使用后者。 因为random节点的存在，导致复制时指针可能指向一个还没有创建的节点，所以可以将原链表两倍拉长，使原链表节点先指向复制节点，复制节点再指向原链表的下一个节点。完成复制后进行random节点的指向初始化，通过原节点的信息来让复制节点的指向正确的节点。最后将链表拆开，复制完成。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*// Definition for a Node.class Node &#123; int val; Node next; Node random; public Node(int val) &#123; this.val = val; this.next = null; this.random = null; &#125;&#125;*/class Solution &#123; public Node copyRandomList(Node head) &#123; if(head == null) return null;// 空链表返回空 Node cur = head; // 1. 复制各节点，并构建拼接链表 while(cur != null) &#123; Node tmp = new Node(cur.val);// 新建复制节点，复制原节点的值 tmp.next = cur.next;// 复制节点的指针指向原节点的下一个元素 cur.next = tmp;// 原节点的指针指向复制节点 cur = tmp.next;// cur改为指向复制节点的下一节点，即原链表的下一节点 &#125; // 2. 构建各新节点的 random 指向 cur = head; while(cur != null) &#123; if(cur.random != null) cur.next.random = cur.random.next;// cur.next是复制节点，说明将复制节点的random指针指向原节点的random指针指向的节点的下一个节点，即也是复制节点 cur = cur.next.next;// 跳到原链表的下一个节点 &#125; // 3. 拆分两链表 cur = head.next; Node pre = head, res = head.next; while(cur.next != null) &#123; pre.next = pre.next.next;// 原节点的指针指向原链表的下一个节点 cur.next = cur.next.next;// 复制节点的指针指向复制链表的下一个节点 pre = pre.next;// 跳到原链表的下一个节点 cur = cur.next;// 跳到复制链表的下一个节点 &#125; pre.next = null; // 单独处理原链表尾节点 return res; // 返回新链表头节点 &#125;&#125;// 作者：jyd// 链接：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/jian-zhi-offer-35-fu-za-lian-biao-de-fu-zhi-ha-xi-/// 来源：力扣（LeetCode）// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 可以发现自己对链表还不够熟练，这道题要多加练习。"},{"title":"剑指offer-day1","path":"2022/04/07/剑指offer-day1/","text":"用两个栈实现队列简单且经典的题目，用两个栈来模拟一个队列。 设置两个栈s1和s2，s1用于正常模拟队列的进队。当队列需要出队时，要把是s1中的值依次放入s2，再在s2的栈顶删除s1的栈底元素（也就是队列的队头元素），然后将处理后的元素再依次放入s1中，就模拟了队列的出队过程。 此时需注意：删除元素应该有判空条件。 12345678910111213141516171819202122232425262728class CQueue &#123; Stack&lt;Integer&gt; s1;// 新建两个栈 Stack&lt;Integer&gt; s2; public CQueue() &#123;// 初始化 s1 = new Stack&lt;&gt;(); s2 = new Stack&lt;&gt;(); &#125; public void appendTail(int value) &#123;// 模拟进队 s1.push(value); &#125; public int deleteHead() &#123;// 模拟出队 if(s1.empty())&#123; return -1; &#125; while(!s1.empty())&#123; s2.push(s1.pop()); &#125; int res = s2.pop();// 需要出队的元素 while(!s2.empty())&#123; s1.push(s2.pop()); &#125; return res; &#125;&#125; 看评论说java的stack类会造成速度变慢，可以用LinkedList做容器，但是会不符合题目要求，可以作为优化的一种选项。 包含min函数的栈原本是简单题，但是因为自己想的太复杂了，迟迟没有做出来，参考了一下答案，才把思路理清（👎） 设置一个辅助栈supStack，用于记录主栈入栈操作时栈内的最小值。第一个入主栈的自然要记录，此后若有小于或等于辅助栈栈顶的数，则需要辅助栈将一个相同的数放入栈顶，反之则不用操作。出栈时则需要与辅助栈的栈顶比对，若相等则辅助栈也必须出栈。 123456789101112131415161718192021222324252627282930class MinStack &#123; Stack&lt;Integer&gt; mainStack;// 主栈 Stack&lt;Integer&gt; supStack;// 辅助栈 /** initialize your data structure here. */ public MinStack() &#123;// 初始化 mainStack = new Stack(); supStack = new Stack(); &#125; public void push(int x) &#123; mainStack.push(x); if(supStack.empty() || supStack.peek() &gt;= x)&#123;// 辅助栈空或大于等于要放入的值时，需放入一个同样的值 supStack.push(x); &#125; &#125; public void pop() &#123; if(mainStack.pop().equals(supStack.peek()))&#123;// 当出栈值与辅助栈栈顶相等时，辅助栈也要出栈 supStack.pop(); &#125; &#125; public int top() &#123;// 查看主栈的栈顶 return mainStack.peek(); &#125; public int min() &#123;// 查看辅助栈的栈顶 return supStack.peek(); &#125;&#125; 需要注意的是，pop()中需要使用equals方法而不是==，因为在Integer中，[-128,127]会被缓存记住，只有在这个范围内==才是比较数值，否则比较的是对象，会造成错误。 记忆点1234567// Java Stack类boolean empty();// 判断栈是否为空Object peek();// 返回栈顶Object pop();// 返回并删除栈顶Object push(Object element);// 在栈顶添加新元素int search();// 查找s内的值，返回其在栈内的位置，以1为基数"},{"title":"学习总结（2022.03.31-2022.04.06）","path":"2022/04/06/学习总结（2022-03-31-2022-04-06）/","text":"继承的限制 子类不可以继承父类的私有成员，因为没有访问权限。 子类不可以继承父类的构造器，因为构造器不能算成员。 子类可以访问父类的静态方法，但是并不是继承。 继承中的属性隐藏和方法覆盖对于成员变量的访问范围和访问结果都看引用类型。引用是父类则访问的是父类成员变量，子类则访问子类成员变量。 对于成员方法的访问范围如上相同，看引用类型。 对于成员方法的访问结果则看对象类型。对象是子类则可以调用子类方法、重写或没重写的父类方法，父类则只能调用父类方法。 final关键字final修饰类表示类不可被继承。 final修饰方法表示方法不可被重写，但可以被继承。 final修饰变量表示常量。与static一起用表示全局变量。 instanceof关键字用来判断一个类是否是某个类的子类，一般用于保证向下转型的安全。 抽象类（abstract）抽象类与普通类相同，但是多了一个抽象方法，即不需要实现该方法，而是让子类通过重写的方式来实现。抽象类和抽象类之间可以有继承关系，且继承的抽象类可以选择重写被继承抽象类的抽象方法。 接口（interface）接口是一种开发标准，表示对功能的扩展，只关注行为而不关注属性。一般用来抽象共性行为，与实现其的类为like-a关系。 接口不能创建对象，自然也没有构造器。 接口一般没有成员，只有抽象方法。 接口可以继承接口，但是接口和类之间不能发生继承，类只能实现(implement)接口。 内部类 成员内部类：与普通类相同，但是没有静态声明（允许有静态全局常量）；可以发生继承和实现；与外围类有强依赖关系，可以无视访问权限互相访问。 静态内部类：与普通类完全相同；可以发生继承和实现；与外围类为互相独立的关系，虽然访问不受访问权限限制，但是需要创建对象才可以访问。 局部内部类：不具有访问修饰权限；不具有静态声明；可以发生继承和实现；虽然可以访问外部类的成员，但是外部类无法访问局部内部类的成员。 Lambda表达式Lambda表达式是一种特殊的局部匿名内部类。必须在一个实现了功能接口（有且只有一个必须实现的抽象方法的接口）的类中定义。得到的是这个接口的子类对象。基本格式为： 123(形参列表) -&gt; &#123;// 方法体&#125; ()中是抽象方法的形参列表。 {}中是抽象方法的实现。 在写完Lambda表达式后，需要在表达式前面用(对象名)帮编译器明确对象类型。 Lambda表达式可以简化：当形参只有一个时，可以省略()；当方法体只有一条语句时（包括return语句），可以省略{}。 Lambda表达式的应用：将一个String对象数组映射为所有字符串长度的数组。 1234567891011121314151617181920212223242526/** * @author yzw * @since 2022/04/02 */public class HomeworkImpl &#123; public static void main(String[] args) &#123; String[] s = &#123;&quot;aaa&quot;,&quot;bb&quot;,&quot;c&quot;&#125;;// 实验数组 int[] sLength = mappingObjectLength(s,o -&gt; new int[s.length]);// mapping返回int数组 for(int i : sLength)&#123; System.out.println(i); &#125; &#125; public static int[] mappingObjectLength(Object[] obj, Map map)&#123; int[] result = map.mapping(obj); for (int i = 0; i &lt; obj.length; i++) &#123; result[i] = obj[i].toString().length(); &#125; return result; &#125;&#125;interface Map&#123; int[] mapping(Object o); //返回一个int数组表示每个元素的长度 Object.toString()toString()直接使用是打印对象的全限定类名 + @ + 对象的十六进制地址值。 可以通过重写来展示对象的状态。 Object.equals()和Object.hashcode()equals()直接使用是比较两个引用是否指向相同对象，可以通过重写来修改判断的条件（比如从比较对象的地址修改为比较对象的状态）。 重写遵从闭包原则，即 自反性。x.equals(x) == true 排他性。当比对的不是同种类型的对象或者是一个null时，默认返回false。 对称性。x.equals(y) == true -&gt; y.equals(x) == true。 传递性。x.equals(y) == true &amp;&amp; y.equals(z) == true -&gt; x.equals(z) == true。 其中自反性和排它性需要写代码做判断，而对称性，一致性，传递性，只需要用成员变量的取值来判断对象相等，就自动满足它们。 排他性的选择：getClass()（只能是相同的对象），instanceof（可以是对象的子类） 如果重写equals()，hashcode()也需要重写。因为逻辑上相等的两个对象必须有相同的hash值。 Object.clone()作用是获得一个独立的，与原对象成员一致的新对象。但是在默认的情况下，只能在子类内克隆自己，所以一般需要在类中重写该方法。其次，一个类想实现克隆，需要实现一个标记接口（不含任何抽象方法的接口）java.lang.Cloneable。 浅克隆：如果克隆的类中有引用类型变量，在克隆后该变量会与克隆前的类中的变量指向同一个对象，这样并不能说明这两个类是独立的，这叫做浅克隆。 深度克隆：在clone()中做出如下操作： 将引用指向的对象，也克隆一份。 然后让克隆后的引用指向它。 可以让克隆后的引用类型变量指向一个同样被克隆的新的对象，这样就实现了深度克隆。 示例代码： 123456789101112131415161718class Student&#123; Dog d; //重写clone方法的访问权限 @Override protected Student clone() throws CloneNotSupportedException &#123; //仍然选择调用父类默认实现 //深度克隆的步骤 //1.深度克隆是在浅克隆基础上完成的 Student cloneStu = (Student) super.clone(); //2.需要把Dog对象克隆一份 Dog cloneDog = cloneStu.d.clone(); //3.将拷贝引用指向拷贝对象 cloneStu.d = cloneDog; return cloneStu; //return ((Student) super.clone()); &#125;&#125;"},{"title":"学习总结（2022.03.21-2022.03.30）","path":"2022/04/06/学习总结（2022-03-21-2022-03-30）/","text":"JVM内存 JVM栈。方法执行时占用的内存空间，方法以栈帧形式存储，方法内的局部变量会直接存储在栈帧中，方法执行完毕后出栈销毁，局部变量也被销毁。 堆。存储对象。new关键字即是在堆上开辟空间给对象。当没有引用指向对象时，该对象会被垃圾回收器执行垃圾回收机制(GC)回收内存。 方法区。 本地方法栈。存储JVM的本地(native)方法。 程序计数器：记录当前执行的行数。 传参问题java是值传递，指调用方法时，传入的是实参的拷贝而不是实参本身。 所以下列代码是不可能得出a的两倍的。 123public static void sendIntValue(int a) &#123; a *= 2;&#125; 但是对引用数据类型而言，因为声明的是引用的拷贝，所以内存地址也是会被拷贝的。对引用数据类型进行修改，本身的引用不会发生改变，但是引用和引用的拷贝所指向的对象发生了改变。 所以下列代码b的后面是会加上.zip的。 123public static void sendStringtValue(String b) &#123; b += ”.zip“;&#125; 因为此时b和b的拷贝指向了新的对象b+.zip。 看起来似乎是引用传递，但是下列代码是一个反例。 123456public static void swapArray(int[] arr1,int[] arr2)&#123; int[] temp; temp = arr1; arr1 = arr2; arr2 = temp;&#125; 交换两个拷贝的值，其实就是在交换它们指向的对象，而原先的引用不受影响。在方法结束后，两个拷贝被销毁，交换失败。 类加载JVM认识一个我们创建的类，叫类加载。类加载在一次程序运行中只有一次，且类加载是懒加载的，一些场景会触发类加载，称为类加载的时机，有以下几种： 创建该类对象（new一个对象） 启动该类的main方法 访问某个类的静态成员（包括变量和方法） 子类类加载会触发父类类加载 static修饰的成员是随着类加载完毕就存在的，所以不需要创建对象就可以访问。 创建对象也不依赖于类加载。 类生命周期 类加载过程的三个步骤：加载，连接，初始化 加载主要是将class字节码读取进JVM 连接主要是将静态成员变量进行默认初始化，保证其永远最先进行。 初始化主要执行static相关的内容，包括为静态成员变量赋值，以及执行静态代码块。 成员变量的赋值方式和顺序 默认初始化 显式赋值 构造代码块 构造器赋值 其中默认初始化和构造器赋值永远是第一步和最后一步（掐头去尾） 创建对象过程中结构执行顺序（全） 类加载。首先程序要从有main方法的类中开始执行，所以要先对其进行类加载。（要考虑发生连环类加载的情况，首先有父类存在的话要先执行父类类加载，其次有静态成员变量或者静态代码块创建对象的话要先执行该对象的类加载） 执行静态成员变量的初始化。（包括显式赋值和静态代码块） 创建对象。首先找到对象的构造器，如果有显式调用其他构造器，则跳转至该构造器的类，执行构造代码块和显式赋值，最后执行该构造器。如果没有，则是跳转至父类的无参构造器（无父类则是跳转至Object，但是不影响），执行父类的构造代码块和显式赋值。"},{"title":"Github+hexo搭建博客遇到的坑","path":"2022/04/05/github+hexo搭建博客遇到的坑/","text":"hexo部署问题按照教程部署完后发现页面仍旧没法更改，折腾大半天后发现github最近将默认分支的名字从master改成了main，而_config.yml中一般都将branch设置为master，导致master成为了副分支，github pages默认应用主分支main，所以没法更改页面（所以说政治正确真是害死人…大家约定俗成的事说改就改） 部署慢问题还没有发现问题所在，大概只能理解成访问github困难导致即使push成功网页也会刷新不及时。 图片CDN问题nexmoe主题中的图片使用CDN保存，所以无法使用本地路径，但是图片也不能直接保存至username.github.io中，因为每次push都会导致仓库中保存的图片被删，所以在github中新建了一个仓库用来保存图片。 评论系统gitment已经停止使用！请用gitalk替代。"},{"title":"Hello World","path":"2022/04/05/hello-world/","text":"我的第一篇博客！希望可以一直用下去。"}]