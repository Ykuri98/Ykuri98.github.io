[{"title":"记一次Oracle SQL调优","path":"2023/09/01/记一次Oracle-SQL调优/","text":"公司一个数据库的查询很慢，测试环境200w数据大概需要2秒，正式环境400w数据就需要7秒了。看一下查询语句。 123456789101112131415161718192021222324252627282930313233343536373839404142434445SELECT * FROM ( SELECT TMP_PAGE.*, ROWNUM ROW_ID FROM ( SELECT PRODUCTVARIANTID AS id, BARCODE AS code, PARENT_CODE, NAME, COST_PRICE, ORIGINAL_PRICE, GUIDE_PRICE, UPDATE_USER, UPDATE_TIME, CREATE_USER, UPDATE_USER_ID, CREATE_USER_ID, CREATE_TIME, IS_MEDICARE, IS_MEDICARE_IN_CITY, IS_ON_SHELF_IN_CITY, MEDICARE_PRICE, UPC, IS_DEL, STATUS, CITY_ID, CODE_TYPE, CHANNEL FROM NST_PRODUCT_O2O_PRODUCT WHERE IS_DEL = 0 AND (UPDATE_TIME IS NOT NULL) ORDER BY UPDATE_TIME DESC ) TMP_PAGE ) WHERE ROW_ID &lt;= 10 ## 这里是分页插件要传的参数 AND ROW_ID &gt; 0; 再用 explain plan for分析一下整个语句，发现问题，TABLE ACCESS(FULL)说明整张表并未走索引，所以导致慢查询。但是表中的UPDATE_TIME和IS_DEL字段是建立了联合索引的，说明出现了一些情况导致Oracle不走索引。 贴上一些不会走索引的情况 ‍1,&lt;&gt;2,单独的&gt;,&lt;,(有时会用到，有时不会)3,like “%_” 百分号在前.4,表没分析.5,单独引用复合索引里非第一位置的索引列.6,字符型字段为数字时在where条件里不添加引号.7,对索引列进行运算.需要建立函数索引.8,not in ,not exist.9,当变量采用的是times变量，而表的字段采用的是date变量时.或相反情况。10, 索引失效。11,基于cost成本分析(oracle因为走全表成本会更小)：查询小表,或者返回值大概在10%以上12,有时都考虑到了 但就是不走索引,drop了从建试试在13,B-tree索引 is null不会走,is not null会走,位图索引 is null,is not null 都会走14,联合索引 is not null 只要在建立的索引列（不分先后）都会走,in null时 必须要和建立索引第一列一起使用,当建立索引第一位置条件是is null 时,其他建立索引的列可以是is null（但必须在所有列都满足is null的时候）,或者&#x3D;一个值；当建立索引的第一位置是&#x3D;一个值时,其他索引列可以是任何情况（包括is null &#x3D;一个值）,以上两种情况索引都会走。其他情况不会走。 解决方法主要有三种 选用适合的Oracle优化器 Oracle优化器有三种，RULE(基于规则)，COST(基于成本)，CHOOSE(选择性) 在缺省情况下,Oracle采用CHOOSE优化器, 为了避免那些不必要的全表扫描（full table scan）, 你必须尽量避免使用CHOOSE优化器,而直接采用基于规则或者基于成本的优化器。 重建索引 ‍alter index 索引名 rebuild 强制索引 在select 后，from 前加上 /*+INDEX(表名 索引名)*/ 那么思路就很清晰了。首先公司的数据库我肯定是不敢乱动的，第一种方式pass，那就剩下两个互相尝试。最后测试环境的索引重建后就开始走索引了，速度从2s变成了1s；但是正式环境就比较奇怪，重建后也没有走索引，强制走索引后反而变得更慢了，说明此时走索引是更差的选择，Oracle选了全表来提高效率，目前也想不到更好的处理方法了，或许增加限制条件（比如添加一些默认值，让查询数量变少）和分库分表能解决吧。 2022&#x2F;9&#x2F;7更新 今天又跑了一下测试环境，发现索引又失效了，而且不能强制使用，否则会更慢，估计还是因为策略问题，那么想从数据库方面优化是不太可能了，试着优化一下SQL语句吧。 网上一篇博客https://www.cnblogs.com/quartz/p/14668586.html给了我启发，可能是pageHelper源码写的SQL语句导致查询速度慢。 修改后的SQL语句如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748SELECT * FROM ( SELECT TMP_PAGE.*, ROWNUM ROW_ID FROM ( SELECT PRODUCTVARIANTID AS id, BARCODE AS code, PARENT_CODE, NAME, COST_PRICE, ORIGINAL_PRICE, GUIDE_PRICE, UPDATE_USER, UPDATE_TIME, CREATE_USER, UPDATE_USER_ID, CREATE_USER_ID, CREATE_TIME, IS_MEDICARE, IS_MEDICARE_IN_CITY, IS_ON_SHELF_IN_CITY, MEDICARE_PRICE, UPC, IS_DEL, STATUS, CITY_ID, CODE_TYPE, CHANNEL FROM NST_PRODUCT_O2O_PRODUCT WHERE IS_DEL = 0 AND (UPDATE_TIME IS NOT NULL) ORDER BY UPDATE_TIME DESC ) TMP_PAGE ## 将一个条件放入子查询中 WHERE ROWNUM &lt;= 10 ) WHERE ## 这里是分页插件要传的参数 ROW_ID &gt; 0; 在navicat上跑了一下修改后的SQL语句，速度确实提高了一倍左右。现在的问题就是如何修改源码了，参考博客https://www.jianshu.com/p/47dbb01f3aaa?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation，可以知道只需要在项目中创建与源码相同的包和类，再修改源码就行，这样编译后的class文件会替换maven依赖中的class文件。 修改成功后，测试环境测试发现确实快了很多！唯一的缺点是当页数太大时，还是会拖慢查询的速度，目前还没想到好办法，所以先部署在正式环境先。"},{"title":"记一次Nacos配置迁移与更改","path":"2023/09/01/记一次Nacos配置迁移与更改/","text":"之前配合运维把Nacos的配置迁到了另一台机器上，看界面应该也更新了Nacos的版本，结果在一次本地启动时发现报了如下错误： 123456Whitelabel Error PageThis application has no explicit mapping for /error, so you are seeing this as a fallback.Sun May 30 22:19:43 CST 2021There was an unexpected error (type=Forbidden, status=403).unknown user! 查了一下，发现是运维对nacos添加了权限…之后获取nacos都需要账户才行。 解决方法是首先将spring-cloud-alibaba-dependencies的版本改为2.2.0以上，之后移除spring-cloud-starter-alibaba-nacos-discovery以及spring-cloud-starter-alibaba-nacos-config依赖中的nacos-client，最后加入nacos-client依赖版本1.2.1以上版本。 1234567891011121314151617181920212223242526&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt;&lt;/dependency&gt; 之后就要修改自己的yml了 1234567891011121314151617spring: application: name: xxx cloud: nacos: config: server-addr: xxx namespace: xxx file-extension: yaml username: xxx password: xxx contextPath: /nacos discovery: server-addr: xxx namespace: xxx username: xxx password: xxx 改完之后，读取配置时又开始报错，看日志发现是存在一些空的配置，而估计是Nacos升级后不再支持空配置了，此时就需要在空配置后增加&quot;&quot;来表示空值了。"},{"title":"RabbitMQ消费多个集群的消息","path":"2023/09/01/RabbitMQ消费多个集群的消息/","text":"最近摸鱼成瘾，好久没写过技术相关的东西了… 昨天跟同事遇到了一个问题： 同事需要消费我的项目A发送的MQ消息和另一个同事的项目B发送的MQ消息，在测试环境下用的是同一条MQ集群，但是到了生产环境，就是两个不同的MQ集群了。RabbitMQ的自动配置类是单例模式，无法通过配置多个集群来达到效果，跟同事看了很久的RabbitMQ源码去思考，一开始我的想法是类似动态数据源，切面更换RabbitMQ配置，但是这仅适用于生产者，RabbitMQ的消费者是无法根据切面更换配置的。同事的想法是重写配置类，但是RabbitMQ的消费者配置类经过了很多层的封装，耦合得很厉害，也基本无法实现。 最后找到了一篇博客https://blog.csdn.net/b_ingrem/article/details/118969504其实思路跟同事是比较符合的，重写了两个`ConnectionFactory`，通过`@RabbitListener`中的`containerFactory`来指定使用的`ConnectionFactory`即可。 复制一下配置类代码方便以后使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class connectionFactory &#123; /* 定义连接，rabbitMQ */ @Bean(name = &quot;mainConnectionFactory&quot;) @Primary public ConnectionFactory mainConnectionFactory( @Value(&quot;$&#123;spring.rabbitmq.first.host&#125;&quot;) String host, @Value(&quot;$&#123;spring.rabbitmq.first.port&#125;&quot;) int port, @Value(&quot;$&#123;spring.rabbitmq.first.username&#125;&quot;) String username, @Value(&quot;$&#123;spring.rabbitmq.first.password&#125;&quot;) String password) &#123; return connectionFactory(host, port, username, password); &#125; /* 定义连接 */ @Bean(name = &quot;secondConnectionFactory&quot;) public ConnectionFactory secondConnectionFactory( @Value(&quot;$&#123;spring.rabbitmq.second.host&#125;&quot;) String host, @Value(&quot;$&#123;spring.rabbitmq.second.port&#125;&quot;) int port, @Value(&quot;$&#123;spring.rabbitmq.second.username&#125;&quot;) String username, @Value(&quot;$&#123;spring.rabbitmq.second.password&#125;&quot;) String password) &#123; return connectionFactory(host, port, username, password); &#125; /* 定义连接 */ public CachingConnectionFactory connectionFactory(String host, int port, String username, String password) &#123; CachingConnectionFactory connectionFactory = new CachingConnectionFactory(); connectionFactory.setHost(host); connectionFactory.setPort(port); connectionFactory.setUsername(username); connectionFactory.setPassword(password); // connectionFactory.setVirtualHost(virtual_host); return connectionFactory; &#125; @Bean(name = &quot;mainRabbitTemplate&quot;) @Primary public RabbitTemplate mainRabbitTemplate(@Qualifier(&quot;mainConnectionFactory&quot;) ConnectionFactory connectionFactory) &#123; RabbitTemplate mainRabbitTemplate = new RabbitTemplate(connectionFactory); mainRabbitTemplate.setMessageConverter(new Jackson2JsonMessageConverter()); return mainRabbitTemplate; &#125; @Bean(name = &quot;secondRabbitTemplate&quot;) public RabbitTemplate secondRabbitTemplate(@Qualifier(&quot;secondConnectionFactory&quot;) ConnectionFactory connectionFactory) &#123; RabbitTemplate secondRabbitTemplate = new RabbitTemplate(connectionFactory); return secondRabbitTemplate; &#125; @Bean(name = &quot;mainFactory&quot;) @Primary public SimpleRabbitListenerContainerFactory myFactory( SimpleRabbitListenerContainerFactoryConfigurer configurer, @Qualifier(&quot;mainConnectionFactory&quot;) ConnectionFactory connectionFactory) &#123; SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); factory.setMessageConverter(new Jackson2JsonMessageConverter()); configurer.configure(factory, connectionFactory); return factory; &#125; @Bean(name = &quot;secondFactory&quot;) public SimpleRabbitListenerContainerFactory secondFactory( SimpleRabbitListenerContainerFactoryConfigurer configurer, @Qualifier(&quot;secondConnectionFactory&quot;) ConnectionFactory connectionFactory) &#123; SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); factory.setConcurrentConsumers(10); factory.setMaxConcurrentConsumers(20); factory.setPrefetchCount(1); configurer.configure(factory, connectionFactory); return factory; &#125;&#125;"},{"title":"工作中的一些小问题（持续更新）","path":"2023/09/01/工作中的一些小问题（持续更新）/","text":"Could not resolve placeholder ‘xxx’ in value “${xxx}”工作时出现了好几次这个问题，需要记录一下解决思路和方法。 出现这种问题的根源都是配置文件下的这个配置无法正确识别，要么就是最简单的：配置文件里压根没这配置，而自己却使用了；要么就是配置文件本身就无法被识别了。 为什么会无法识别配置文件？最可能的问题是字符集不符合，一旦配置文件内出现中文，无论是不是注释，都会在maven编译后报错的日志中找到这么一句话 1org.yaml.snakeyaml.error.YAMLException: java.nio.charset.MalformedInputException: Input length = 1 说明了yaml文件由于字符集不是utf8而不能被正确识别。 这时就要检查自己的配置文件是不是utf8字符集了，如果是本地文件需要用文本文件打开查看；如果是nacos上的配置，那默认就是utf8，说明项目自身编译配置文件时用的不是utf8字符集。 解决方法也很简单，在maven下的&lt;properties&gt;标签增加一个 1&lt;argLine&gt;-Dfile.encoding=UTF-8&lt;/argLine&gt; 说明编译时需要用utf8编译即可。 try&#x2F;catch和for循环的内外关系同事问了我一个问题:在try&#x2F;catch下的for循环发生异常后，会不会跳出循环? 我愣了一下，之前好像没有考虑过这个问题，当时回答是会跳出的，当然正确答案我也不能确定。 正好在知乎刷到了这个问题的正确解答，在这里记录一下。 在try&#x2F;catch下的for循环，发生异常会跳出并终止循环。 在for循环下的try&#x2F;catch，发生异常会报出异常，但不会终止循环。 记一次Oracle update更新的回滚早上模模糊糊的，想执行一个插入的语句，没成想写成update了，一下把表里所有数据都更新了，给我吓出一身冷汗…好险是公司的测试环境，不然今天我就拿东西滚蛋了。 大致查了一下怎么恢复，得知了Oracle具有快照的功能，会存储一段时间内的数据，只需要执行如下语句就可以查看。 1select * from table_name as of timestamp to_timestamp(&#x27;2022-07-26 17:20:00&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;); 其中table_name是需要回滚的表，时间填要回滚的时间即可。 然后开启表的闪回功能 1alter table table_name enable row movement; 最后修改表 1flashback table table_name to timestamp to_timestamp(&#x27;2022-07-26 17:20:51&#x27;,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;); 只能说以后要引以为戒… 记一个service bean为空的bug调接口发现报空指针，本地debug才发现报空指针的是service bean，可是其他使用该service的接口都可以正常使用，service也加了@Autowired注解，有点百思不得其解了。后面查询了https://ask.csdn.net/questions/7615814的回答，发现接口方法写成private了...说明private会影响service bean的注入，以后可不能再手快了… Maven字符集相关问题今天好不容易写完bug代码，准备打包发测试的时候发现打包失败了，还是第一次遇到这种情况，看了一下错误日志，说明nacos中的配置文件并没有被解析到，导致读取不到配置文件中的常量，上网搜了一下，初步猜测是字符集的问题，首先确认nacos中的字符集，查了一下就知道，nacos中的配置文件字符集默认都是utf-8。 那么只能是本地字符集的问题了，在idea的设置中将所有文件都改为utf-8，继续跑package，结果还是失败… maven打包失败后会在target中放一个错误日志，查看日志发现了一个更重要的错误。 1java.nio.charset.MalformedInputException: Input length = 1 这个错误说明maven打包时使用的字符集与配置文件的字符集不相符，导致不能正常读取。 在网上找了各种方法，给pom文件加了各种配置，都没能有效解决… 最后看到了一篇博客https://blog.csdn.net/m0_46897923/article/details/116236929，里面禁用了maven的test，这样在打包时会自动跳过test从而打包成功。虽然解决问题了，但并不完美，如何修改maven运行时的字符集才是重点。 根据这个思路继续查，查到博客https://blog.csdn.net/usrnck0709/article/details/124945862，这里给出了四个比较具体的方案，其中我采用的是最后一种，在pom文件中添加 123&lt;properties&gt; &lt;argLine&gt;-Dfile.encoding=UTF-8&lt;/argLine&gt;&lt;/properties&gt; 即在运行maven时确认字符集为utf-8 查数据库锁表语句，杀锁表进程123456789-- 查数据库锁表语句，杀锁表进程select sess.sid,sess.serial#, lo.oracle_username,lo.os_user_name,ao.object_name,lo.locked_mode from v$locked_object lo,dba_objects ao,v$session sesswhere ao.object_id=lo.object_id and lo.session_id=sess.sid;-- #参数分别是sid, serial#alter system kill session &#x27;603,3&#x27;;-- 如果杀不掉，用alter system kill session &#x27;2724,43721&#x27; immediate ; 部署命令123456# 抓取进程IDps -ef | grep xxx# 根据进程ID杀死进程sudo kill -9 xxx# 启动jar包nohup sudo java -Xms512m -Xmx1024m -jar xxx.jar &gt;&gt; ./nohup.out 2&gt;&amp;1"},{"title":"关于网关超时的一些思考与解决方案","path":"2023/09/01/关于网关超时的一些思考与解决方案/","text":"开发接口的时候经常会发现，一些需要执行大量操作的接口，在逻辑处理上存在处理缓慢的问题的时候，前端经常会出现504 gateway timeout的错误，导致接口的可用性变差。 为什么会有504错误在微服务中，接口调用都是链式的，即是说一次接口调用伴随着多个并行和串行的子任务。如果子任务中某一环节发生处理缓慢的情况，且一直有请求在发送，就会导致改环节下未完成的子任务越来越多，从而让服务器执行效率下降，直至耗尽内存资源宕机。网关此时就作为一个流量控制的工具，在接口未能及时返回的情况下，应该阻止这种情况发生，所以网关会监听一个接口的响应时间，并在接口超时后及时阻断请求，返回504错误。 解决方案一般出现504错误，说明接口内的业务处理逻辑仍有需要优化的地方。目前自己在工作中常见的处理方法有以下几种。 异步处理。即对请求优先返回响应，但是让子任务继续执行。这种做法完美避开了网关超时的可能，但这并不是一个推荐的做法。首先它违背了网关对于异常流量阻断的原则，使得网关无法正确监听接口的实际执行时间。其次子任务执行缓慢的根本问题依旧没有解决，在多请求的情况下仍然会发生服务处理效率下降的问题。最后，异步处理还带来了问题定位上的问题，即很难通过一个完整的链路定位到问题。 多线程。如果业务逻辑中存在大量的独立任务，可以考虑使用多线程来并行执行。多线程可以显著提高接口效率，但是亦有诸多限制。首先是问题定位，多线程下的问题定位会变得困难，无法通过日志打印时间来定位。其次是对线程数量的控制，如果控制不当，一样会消耗服务器过多的资源。 消息队列。在一些链式调用中，可以通过消息队列来发送和接收消息。消息队列可以做到异步的功能，而且由于队列可以作为阻塞队列使用，能够容许消费端执行缓慢，也侧面解决了接口频繁调用导致的内存资源不足的问题。 ———————————————————————————————————————————— 最近逛掘金，看到了一篇不错的文章https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;mid=2247502660&amp;idx=1&amp;sn=17166646f82412cd81955930f799ab4e&amp;chksm=cf22146df8559d7bcf9becd82e1d8006c35a781e5dbd0a79e0a9e121803ee40d6eae7ebd7ccb&amp;token=1371687559&amp;lang=zh_CN#rd，也介绍了一些优化接口的经验，可以记录一下。"},{"title":"关于Kafka批量消费的一些坑","path":"2023/08/31/关于kafka批量消费的一些坑/","text":"​ 很久很久之前，发现Kafka的一些Topic发生了消费延迟，为了提高消费速率，我自作聪明地使用containerFactory并指定了一个批量消费的Factory： 12345678910111213@Bean(value = &quot;kafkaListenerContainerBatchFactory&quot;)public KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;String, String&gt;&gt; kafkaListenerContainerFactory() &#123; ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); //消费者实例个数，并发消费（实例数*分布式机器数&lt;=kafka分区数，避免浪费） factory.setConcurrency(concurrency); //支持并发消费 factory.setBatchListener(true); //设置提交偏移量的方式, 默认是 batch factory.getContainerProperties().setAckMode(ContainerProperties.AckMode.MANUAL_IMMEDIATE); return factory;&#125; ​ 曽以为这样就万事大吉，Kafka的消费延迟也确实消失了，直到昨天早上，生产报出问题，Kafka竟然出现了消息丢失的情况！用可视化工具检查了Kafka内的消息，确认并不是生产者的问题，那么消息丢失就是发生在消费者这了。 ​ 检查日志，发现一个很奇怪的问题：Kafka消费的offset有时候会开始中断几百条再消费。确认了这个group只有我一个项目在消费，所以不存在项目间抢夺消息的问题。 ​ 此时一个想法在我脑海浮现：难道是批量消费都没有执行完，就被强行中断了？因为这个group做了三个分区，并且开了三台机器来消费，所以每个机器的并发数都是1，也就是说，Kafka Consumer在每台机器上都是一个单线程。一开始怀疑的是auto-offset-reset这个配置项。在项目中，它的值是latest，官方文档的解释是 earliest：自动将偏移量重置为最早的偏移量latest：自动将偏移量重置为最新偏移量 ​ 是不是在两次拉取中，因为前一次的消费速度太慢，导致前一次的offset并没有提交，后一次的消费则直接从最新的offset消费了？然而在本地的实验宣告该想法是不正确的，即使改为了earliest，依旧出现了offset跳跃的问题。那么只能确定，这个配置项只会在Kafka Consumer停止或重启时有影响。 ​ 那么我加快消费速度，让他能在两次拉取的间隔时间内全部消费完呢？我在本地开启一个线程池去并发消费，结果很明显，offset跳跃的情况消失了。根据日志可以看到，两次批量拉取的间隔时间是在3s左右。 ​ 为什么是3s？查了一圈发现最有可能的是heartbeat.interval.ms这个配置项在起作用。在Kafka中，除了消费者线程，还有一个心跳线程。生产者线程会定时发送心跳给心跳线程接收，如果心跳线程没有在一定时间内回应，生产者会默认该消费者已经挂了，将该消费者提出消费群组并进行重新的负载均衡（Rebalance）。但是如果只是消费速度慢，offset没有及时commit的话，就会出现以下情况： 生产者发送心跳 -&gt; 消费者还在消费，offset未commit -&gt; Kafka Consumer报出CommitFailedException，commit失败 -&gt; 生产者未收到心跳回应，踢出该消费者并进行Rebalance -&gt; 消费者并未挂掉，会重新订阅topic -&gt; 消费者从最新的offset开始消费，发生offset跳跃 ​ 以上是我结合实际情况和文档、博客作出的一个较合理的猜测，真实情况还是得在实际项目中去继续观察……"},{"title":"MybatisPlus多数据源配置","path":"2023/08/28/MybatisPlus多数据源配置/","text":"采用AOP思想，对DataSource注解进行动态切换，核心思想是依靠 继承AbstractRoutingDataSource，重写determineCurrentLookupKey()方法，在该方法中使用DatabaseContextHolder获取当前线程的dataSource。 首先要在配置文件中配置不同的数据源。 12345678910111213spring: datasource: druid: dianshang: driver-class-name: oracle.jdbc.OracleDriver username: xxx password: xxx url: jdbc:oracle:thin:@//10.21.1.18:1531/oradev pos: driver-class-name: oracle.jdbc.OracleDriver username: xxx password: xxx url: jdbc:oracle:thin:@//10.1.8.58:1521/orcl 在项目中创建如下文件 首先，编写DynamicDataSource类集成AbstractRoutingDataSource，重写determineCurrentLookupKey方法，该方法主要作用是选择数据源的key 1234567891011121314151617181920/** * 动态数据源 * */ public class DynamicDataSource extends AbstractRoutingDataSource &#123; public DynamicDataSource(DataSource defaultTargetDataSource, Map&lt;Object, Object&gt; targetDataSources) &#123; // 设置默认的数据源 super.setDefaultTargetDataSource(defaultTargetDataSource); // 设置目标数据源的集合 super.setTargetDataSources(targetDataSources); // 初始化bean时，通过外界数据为bean填充属性 super.afterPropertiesSet(); &#125; @Override protected Object determineCurrentLookupKey() &#123; return DataSourceHolder.getDataSourceType(); &#125;&#125; 其次自定义@DataSource注解，在需要切换数据的Dao添加此注解 123456789/** * 备注：自定义数据源选择注解 **/@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface DataSource &#123; String name() default &quot;&quot;;&#125; 配置AOP切面类 12345678910111213141516171819202122232425@Aspect@Componentpublic class DataSourceAspect &#123; @Pointcut(&quot;@annotation(com.xxx.aspect.DataSource)&quot;) public void dataSourcePointCut() &#123; &#125; @Around(&quot;dataSourcePointCut()&quot;) public Object around(ProceedingJoinPoint point) throws Throwable &#123; MethodSignature signature = (MethodSignature) point.getSignature(); Method method = signature.getMethod(); DataSource dataSource = method.getAnnotation(DataSource.class); if(dataSource == null)&#123; DataSourceHolder.setDataSourceType(dataSource.name()); &#125; try &#123; return point.proceed(); &#125; finally &#123; DataSourceHolder.clearDataSource(); &#125; &#125;&#125; 配置DataSourceHolder 1234567891011121314151617181920212223242526272829303132public class DataSourceHolder &#123; /** * threadLocal存储数据源 */ private static final ThreadLocal&lt;String&gt; DATA_SOURCE = new ThreadLocal&lt;&gt;(); /** * 设置当前数据源 * * @param type */ public static void setDataSourceType(String type) &#123; DATA_SOURCE.set(type); &#125; /** * 获取当前数据源 * * @return */ public static String getDataSourceType() &#123; return DATA_SOURCE.get(); &#125; /** * 清除当前数据源 */ public static void clearDataSourceType() &#123; DATA_SOURCE.remove(); &#125;&#125; 在项目的配置包中添加配置类 添加数据源配置DataSourceConfig 12345678910111213141516171819202122232425@Configurationpublic class DataSourceConfig &#123; @Bean @ConfigurationProperties(prefix = &quot;spring.datasource.druid.dianshang&quot;) public DruidDataSource dataSource1() &#123; return DruidDataSourceBuilder.create().build(); &#125; @Bean @ConfigurationProperties(prefix = &quot;spring.datasource.druid.pos&quot;) public DruidDataSource dataSource2() &#123; return DruidDataSourceBuilder.create().build(); &#125; @Primary @Bean(name = &quot;dynamicDataSource&quot;) public DynamicDataSource dataSource(@Qualifier(&quot;dataSource1&quot;) DataSource dataSource1, @Qualifier(&quot;dataSource2&quot;) DataSource dataSource2) &#123; Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;(16); targetDataSources.put(&quot;dianshang&quot;, dataSource1); targetDataSources.put(&quot;pos&quot;, dataSource2); return new DynamicDataSource(dataSource1, targetDataSources); &#125;&#125; 最后配置启动类 12345678910// 需要去除springBoot自带的数据源配置@SpringBootApplication(exclude= &#123;DataSourceAutoConfiguration.class&#125;)@MapperScan(basePackages = &quot;com.xxx.mapper&quot;)// 导入自己写的数据源配置类@Import(&#123;DataSourceConfig.class&#125;)public class StartApp &#123; public static void main(String[] args) &#123; SpringApplication.run(StartApp.class); &#125;&#125; 如果配了mybatisPlus，需要更改其中的一些配置 123456789101112131415161718192021@Configurationpublic class MybatisPlusConfig &#123; /** * oracle序列生成器 */ @Bean public OracleKeyGenerator oracleKeyGenerator() &#123; return new OracleKeyGenerator(); &#125; /** * oracle事务管理器 */ @Bean(name = &quot;mybatisTransactionManager&quot;) @Primary //事务默认数据库 // Qualifier注解需要改为dynamicDataSource public DataSourceTransactionManager testTransactionManager(@Qualifier(&quot;dynamicDataSource&quot;) DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 之后在写Mybatis的mapper接口时用注解声明要使用的数据源就可以实现动态切换啦 1234public interface Mapper &#123; @DataSource(name = &quot;pos&quot;) String querySkuIdByBarcode(@Param(&quot;barcode&quot;) String barcode);&#125;"},{"title":"学习总结（2022.07.04-2022.07.20）","path":"2022/07/07/学习总结（2022-07-04-2022-07-20）/","text":"NginxNginx是一个高性能的支持HTTP协议和反向代理的web服务器，其特点是占有内存少，并发能力强。 正向代理：代理服务器代理的是用户的客户端，访问的是服务端的服务器。 反向代理：代理服务器代理的是服务端的服务器，客户端访问的是被代理的服务器。 在微服务架构下，Nginx主要用于静态代理和负载均衡。 Nginx优点： 高并发，高性能 扩展性好 异步非阻塞的事件驱动模型 高可靠性 微服务单体架构的好处有： 应用开发简单 应用修改简单 测试相对简单 部署简单 横向扩容性好 弊端有： 代码过度复杂且严重耦合，导致难以维护 从代码提交到实际部署的周期很长 扩展性受限 开发慢，启动慢，严重影响开发效率 难以交付可靠的单体应用 为了解决单体架构的问题，提出了微服务架构，即每个服务器按照单一职责原则实现特定的一组功能，每个服务器可以独立部署，独立运行，独立对外提供服务。当一个单体应用程序的规模过大时，就很难作为一个整体开发，也很难让一个人完全理解，所以需要拆分为模块来开发。但是在单体应用中，模块通常由编程语言提供的结构来定义，这样不同模块的代码还是可以互相引用，导致模块中依赖关系的混乱。而在微服务架构中，要访问别的模块，只能通过实现该模块的服务所提供的API调用，这样就保持了模块的独立性。 微服务的优势有： 每个服务都相对较小，易维护 大型的应用程序可以实现快速的持续交付和持续部署 应用扩展灵活 更好的容错 弊端有： 系统复杂难以管理 部署追踪问题难 事务难处理 服务数量增加，管理复杂性增加 服务注册中心服务注册中心用于统一管理服务的状态和信息，以方便在微服务架构中服务间的互相调用。 在服务启动时，会将自己的信息注册至服务注册中心，包括ip地址、端口号等；在服务运行的过程中，会实时向服务注册中心报告自己的状态，如果服务注册中心太久没有收到来自服务的消息，会自动将该服务注销，以免影响整个应用程序，这被称为心跳机制；服务启动后，会定时去注册中心拉取其他服务信息，即将服务注册表下载到本地，这样每个服务都知道其他服务的信息。 目前使用的注册中心有Eureka和Nacos。 EurekaEureka是SpringCloud中包含的注册中心的组件，采用了CS架构的设计，Server作为服务器端实现了服务注册中心的功能，Client则是作为客户端，服务提供者通过它实现服务的注册，服务消费者通过它完成服务的自动发现。 EurekaServer的配置例子如下： 1234567891011121314server: port: 7001# Eureka配置eureka: instance: # Eureka服务端的实例名字 hostname: localhost client: # 表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) register-with-eureka: false # fetch-registry如果为false,则表示自己为注册中心,客户端的化为 ture fetch-registry: false service-url: defaultZone: http://localhost:7001/eureka/ 123456789@SpringBootApplication// 启动类上添加注解@EnableEurekaServer@EnableEurekaServerpublic class EurekaServer &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServer1.class, args); &#125;&#125; EurekaClient的配置例子如下： 1234567891011121314spring: application: name: registry-consumerserver: port: 8002# Eureka配置eureka: client: service-url: defaultZone: http://localhost:7001/eureka/ instance: instance-id: springcloud-consumer-eureka-8002 #修改Eureka上的默认描述信息 hostname: localhost 123456789@SpringBootApplication// 启动类上添加注解@EnableEurekaClient@EnableEurekaClientpublic class RegistryConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RegistryConsumerApplication.class, args); &#125;&#125; Eureka具有自我保护机制，如果在短时间内丢失大量服务连接，Eureka并不会将所有丢失连接的服务注销，而是会保护这些服务。自我保护机制的意义是避免发生网络连接故障时对服务状态的误判，这会使服务集群更加健壮。 NacosNacos在功能方面与Eureka并无区别，只是Nacos在实现方式上不同相同。它是一个类似tomcat的独立服务器，需要自行开启才可使用。开启方式实在其bin目录下输入 1startup.cmd -m standalone 即可启动。默认端口号为8848。 在需要注册的服务中添加如下配置： 12345678910server: port: 8002spring: application: name: nacos-provider cloud: nacos: discovery: # nacos服务器地址 server-addr: localhost:8848 12345678@SpringBootApplication// 在启动类上加注解@EnableDiscoveryClient@EnableDiscoveryClientpublic class NacosProvider8002Application &#123; public static void main(String[] args) &#123; SpringApplication.run(NacosProvider8002Application.class, args); &#125;&#125; Ribbon负载均衡微服务架构中有一个很重要的问题是服务调用的选择策略问题，解决该问题的方法则是使用Ribbon。Ribbon是一个客户端负载均衡器，可以帮助我们在一个服务集群中，根据一组选择策略，选择一个服务实例，并向该实例发起调用请求。 它支持的负载均衡策略如下。 策略 实现类 描述 随机策略 RandomRule 随机选择server 轮训策略 RoundRobinRule 轮询选择 重试策略 RetryRule 对选定的负载均衡策略(轮训)之上重试机制，在一个配置时间段内当选择服务不成功，则一直尝试使用该策略选择一个可用的服务； 最低并发策略 BestAvailableRule 逐个考察服务，如果服务断路器打开，则忽略，再选择其中并发连接最低的服务 可用过滤策略 AvailabilityFilteringRule 过滤掉因一直失败并被标记为circuit tripped的服务，过滤掉那些高并发链接的服务（active connections超过配置的阈值) 响应时间加权重策略 WeightedResponseTimeRule 根据server的响应时间分配权重，响应时间越长，权重越低，被选择到的概率也就越低。响应时间越短，权重越高，被选中的概率越高，这个策略很贴切，综合了各种因素，比如：网络，磁盘，io等，都直接影响响应时间 区域权重策略 ZoneAvoidanceRule 综合判断服务所在区域的性能，和服务的，轮询选择server并且判断一个AWS Zone的运行性能是否可用，剔除不可用的Zone中的所有server 可以通过配置文件指定负载均衡策略。 12345# 这里的users是我们的服务名称users: ribbon: # 这一行配置的就是实现具体负载均衡策略实现类的全类名 NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule OpenFeign在引入OpenFeign之前，我们调用服务的方式都是由RestTemplate实现的，但是需要自己构建url、请求参数等，这导致我们的代码和RESTful风格的Http请求紧密耦合。OpenFeign则可以实现它们的解耦，帮助我们以统一的方式，将接口翻译为RESTful风格的请求。 因为OpenFeign是面向Java接口而非HTTP的API，所以需要我们自己建立一个工程用于存放一些公共接口的请求参数和响应类。 使用OpenFeign需要定义Feign客户端。 123456// 注意，这里FeignClient的名字是调用的服务的名称@FeignClient(&quot;feign-provider-8005&quot;)public interface DemoServiceClient&#123; @GetMapping(&quot;/feign/hello&quot;) String sayHello(@RequestParam(name = &quot;name&quot;)String name);&#125; 12345678910@SpringBootApplication@EnableDiscoveryClient// 在启动类上加注解@EnableFeignClients@EnableFeignClientspublic class FeignConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(FeignConsumerApplication.class, args); &#125;&#125; 如果需要查看日志，可以在FeignClient的配置文件中打开日志配置。 1234# 这里的xxx表示我们自己的定义的FeignClient所在包的包名(比如: com.cskaoyan.feign.consumer.api)logging: level: xxx: debug 为了防止在非正常情况下服务在调用过程中长时间阻塞等待，可以在配置文件中设置超时时间。 12345ribbon: #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间 ReadTimeout: 5000 #指的是建立连接后从服务器读取到可用资源所用的时间 ConnectTimeout: 5000 配置中心若每个服务都拥有自己的配置，那么如果有一天一些公共的配置出现了更改的话，所有服务都需要一起更改，且每个服务都需要重启，这明显是不合理的。要解决这个问题，就需要引入配置中心。配置中心类似于注册中心，可以以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置，消除了配置变更时重新部署应用和服务的需求，让配置管理变得更加高效。 目前Nacos除了作为服务注册中心，还具有配置中心的功能。Nacos配置中心定义了如下概念。 配置项：一个具体的可配置的参数与其值域，通常以 param-key&#x3D;param-value 的形式存在。例如我们常配置系统的日志输出级别（logLevel&#x3D;INFO|WARN|ERROR） 就是一个配置项。 配置集：一组相关或者不相关的配置项的集合称为配置集。在系统中，一个配置文件通常就是一个配置集，包含了系统各个方面的配置，每一个配置集都对应一个唯一的DataId，DataId必须由我们自己定义。 配置分组: Nacos 中的一组配置集，是组织配置的维度之一，每一个分组都有一个唯一的组名，如果我们未定义，则默认使用DEFAULT-GROUP分组 命名空间: 用于进行用户粒度的配置隔离，每一个命名空间都有一个唯一的Id值，如果我们未定义，则默认使用public命名空间 有以上的概念，即可自己定义配置项了。 配置项的key值以及分组组名都由自己定义。 命名空间的id值由Nacos生成。 配置集的DataId定义如下。 1$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125; prefix默认为spring配置文件中spring.application.name的值；spring.profiles.active对应spring配置文件中名字相同的值；&#96;file-exetension为配置内容的数据格式，可以通过spring.cloud.nacos.config.file-extension配置，只支持properties和yaml。 在spring项目中加入配置中心的配置， 1234567891011121314151617181920# 项目中的其他配置都包含在application.yml文件中server: port: 3377# bootstrap.yml文件内容spring: application: name: nacos-config-client profiles: active: dev # 表示开发环境 cloud: nacos: config: #Nacos作为配置中心地址 server-addr: localhost:8848 #指定yaml格式的配置，如果是yml文件，注意这里写的是yaml! file-extension: yaml # 配置所属的配置分组 # group: DEV_GROUP # 配置所属的命名空间 # namespace: 7d8f0f5a-6a53-4785-9686-dd460158e5d4 此外Nacos的配置也可以通过数据库实现持久化，Nacos的配置会保存到Nacos自带的一个数据库derby中，因此即使重启Nacos也可以看到之前的配置信息。由于derby是嵌入式数据库，其中的数据无法可视化，所以Nacos也支持将数据库更换为mysql，具体方式如下。 在数据库中，创建名为nacos的数据库 在nacos数据库中，执行数据库初始化文件：nacos-mysql.sql(改文件在conf目录下已经提供) .修改conf&#x2F;application.properties文件，增加支持mysql数据源配置（目前只支持mysql），添加mysql数据源的url、用户名和密码。 1234567spring.datasource.platform=mysqldb.num=1# 这里的url要改成你自己的mysql数据库地址，并在你的mysql中创建名为nacos的数据库db.url.0=jdbc:mysql://11.162.196.16:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true# 这里要改成你自己登录mysql的用户名和密码db.user.0=nacos_devtestdb.password.0=youdontknow TK-MybatisTK-Mybatis是Mybatis的增强工具，为简化开发，提高效率而生。 TK-Mybatis的示例如下。 12345678// 实体类和表的映射@Table(name = &quot;user&quot;) // name配置为表名public class User &#123; @Id private Integer id; // @Id 表示该字段是主键 @Column private String name; // @Column表示该字段是普通字段 @Column private Integer age; @Column private String gender; &#125; 12// 通用Mapperpublic interface UserMapper extends Mapper&lt;User&gt; &#123;&#125; 12@MapperScan(basePackages = &quot;com.cskaoyan.tkdemo.dal&quot;) //这个注解加到启动类上或者是 配置类上 public class TkDemoApplication &#123;&#125; 123456789101112131415161718192021222324252627282930313233343536@Autowired private UserMapper userMapper;@Test public void test01()&#123; // 这个就是tkMybatis给我们提供的模板方法，类似的方法还有很多 // 插入数据之后获取id值 User user = new User(); user.setUserName(&quot;zuoyou&quot;); user.setAge(20); int insert = userMapper.insert(user); System.out.println(user.getId()); // 根据复杂条件查询 Example secondExample = new Example(User.class); secondExample.createCriteria() // 这里的条件名称，指的是映射实体类的属性名 .orEqualTo(&quot;userName&quot;, &quot;zs&quot;) .orEqualTo(&quot;age&quot;, 20); List&lt;User&gt; us = userMapper.selectByExample(secondExample); // 根据复杂条件来修改 Example example = new Example(User.class); example.createCriteria().andEqualTo(&quot;userName&quot;, &quot;lisi&quot;); User user = new User(); user.setAge(100); int i = userMapper.updateByExampleSelective(user, example); // 删除 int i = userMapper.deleteByPrimaryKey(4); &#125; Map-StructMap-Struct主要用途是简化对象间的映射。在实际开发中，DAO层的实体类（即PO）与数据传输类（即BO或VO）不一定完全相同，而通过Map-Struct可以使它们间的转换变得简单。 使用示例 1234567891011@Mapper(componentModel = &quot;spring&quot;)public interface UserConverter &#123; // User对象 ——&gt; UserDto @Mappings(&#123; @Mapping(source = &quot;userName&quot;, target = &quot;name&quot;) &#125;) UserDto userDoToUserDto(User user); // List&lt;User&gt; ——&gt; List&lt;UserDto&gt; List&lt;UserDto&gt; userDosToUserDtos(List&lt;User&gt; users);&#125; SPI机制SPI是JDK内置的一种服务提供发现机制，用于做接口实现类的扩展发现，简单来说，它就是一种动态替换发现的机制。 SPI要实现其机制，需要遵循以下约定。 当服务的提供者提供了服务接口的一种实现之后，在jar包的META-INF&#x2F;services&#x2F;目录中同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当程序运行时，使用这个接口的实现类的时，就能通过该jar包META-INF&#x2F;Services&#x2F;的配置文件找到具体的实现类名。并加载该实现类(可能有多个)并实例化。 基于这样的一个约定就能很好的找到服务接口的实现类，而不需要在代码里指定。 示例 定义接口 123public interface CatService &#123; void sleep(); &#125; 定义接口实现类 1234567891011public class BlackCatService implements CatService &#123; @Override public void sleep() &#123; System.out.println(&quot;黑猫呼呼睡大觉...&quot;); &#125; &#125;public class WhiteCatService implements CatService &#123; @Override public void sleep() &#123; System.out.println(&quot;白猫孜孜不倦的学习...&quot;); &#125; &#125; 定义配置文件 在src&#x2F;META-INF&#x2F;services目录下新增和接口全类名一样的一个文件，文件里面配置需要接口动态 加载的实现类的全类名，这样Java在调用接口的时候就能动态的去找到接口的实现，而对原来的代 码没有丝毫的侵入性。 Gateway网关是一个服务器，是系统的唯一入口。所有的客户端和消费端都通过统一的网关接入微服务，在网关处理所有的非业务功能，如请求认证，请求记录，请求限流，黑白名单判断等。 Spring Cloud Gateway是一个基于Spring生态的API网关，基于WebFlux框架实现。它旨在以简单高效的方式实现，请求路由，以及一些其他的边缘功能，比如，安全，监控等功能。 通用的网关框架除了Gateway之外，还有Zuul，Zuul2等框架。其中，Zuul是由Netflix公司开发出的最早的通用网关框架，功能丰富，但是基于同步阻塞式Servlet API实现，性能不佳。Zuul2可以理解为Zuul的升级版，它基于异步非阻塞模式实现，但是由于zuul2在开发过程中一直延期，所以Spring Coud官方并未采用Zuul2最为自己的通用网关，而是自己推出了自己的基于异步非阻塞实现的第二代服务网关Gateway。 Gateway的一些核心概念如下。 Predicate：路由规则的匹配条件。 Filter：过滤器，在请求处理前实现对请求的拦截处理，在请求处理之后实现对响应的拦截处理。 Route：定义请求和路由目标之间的映射，它由一个唯一ID(自定义)，一个目标地址URI，表示路由条件Predicate集合，以及一个Filter集合组成。对于一个请求而言，如果它满足一个路由的全部路由条件(Predicate)，那么该请求就会按照该路由(Route)规则，向目标地址URI转发。 Gateway的工作流程如下。 客户端向Gateway发起请求 Gateway的Handler Mapping组件，会对请求做路由匹配，如果请求和某个路由规则匹配，则把该请求交给Web Handler处理 在将请求转发给目标之前，Web Handler会将请求，交给满足请求过滤条件的一系列过滤器，即一个过滤器链对该请求进行过滤处理 过滤器既在转发请求前拦截请求，也在请求处理之后对响应进行拦截处理。 Gateway可以通过整合Nacos或Eureka、Ribbon从而实现动态路由（即服务的自动发现和调用、服务的负载均衡） 配置文件示例如下。 12345678910111213141516spring: application: name: cloud-gateway cloud: nacos: discovery: server-addr: localhost:8848 gateway: routes: #路由的ID，没有固定规则但要求唯一，建议配合服务名 - id: config_route #匹配后提供服务的路由地址, 这里lb之后，跟的是要调用的服务名称 uri: lb://nacos-provider-8002 # 断言，路径相匹配的条件 predicates: - Path=/routeconfig/rest/** JWTJWT是一个开发标准，它定义了一种紧凑的，自包含的方式，用于JSON对象在各方之间安全的传输信息，该信息可以被验证和信任，因为它是数字签名的。 下列场景中使用JWT是很有用的： Information Exchange（信息交换）：对于安全的在各方之间传输信息而言，Json·Web·Token无疑是一种很好的方式。因为JWT可以被签名，例如，用公钥&#x2F;私钥配对，你可以确定发送人就是他们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容有没有被篡改。 正因为数据可以基于JWT进行安全的传输，所以基于JWT，我们可以实现单点登录功能。（单点登录，即在多应用系统中，用户只需登录一次就能访问所有相互信任的应用系统） 使用JWT可以完成基于Token的身份验证，流程如下： 客户端使用用户名、密码请求登录 服务器收到请求去验证用户名和密码 验证成功之后服务端会签发一个token，再把这个token发送给客户端 客户端收到token以后可以把它存储起来，存到客户端内存或者其他地方 客户端每次向服务器请求资源的时候需要带着服务器签发的token 服务端收到请求，然后去验证客户端请求里面带着的token，如果验证成功，就向客户端返回请求的数据 对比使用Session的身份验证： 每次用户认证通过以后，服务器需要创建一条记录来保存用户信息，通常是在内存中。那么随着认证通过的用户越来越多，服务器在这里的开销就会越来越大。 由于session是在内存中的，这就带来一些扩展性的问题。 用户很容易受到CSRF（跨站请求伪造）的攻击 使用Token的身份验证： JWT是把用户信息保存在客户端，基于token的方式将用户状态分散到了各个客户端中，可以减轻服务端的内存压力。 token的状态是存储在客户端，这就使得服务器端并未存储用户登录状态，是无状态的，因为是无状态的，所以便于集群的扩容。 Token不是cookie。每次请求的时候token都会被发送，可以作为请求参数发送，可以放在请求头里面发送，也可以放在cookie里面被发送。即使在你的实现中将token存储到客户端的cookie中，这个cookie也只是一种存储机制，而非身份认证机制。没有基于会话的信息可以操作，因为我们没有会话。 JWT由三部分组成，中间以·连接，三部分分别是： Header Payload Signature Header由两部分信息组成： type：声明类型 alg：声明加密的算法，通常使用HMAC SHA256 Payload由8部分信息组成： iss：签发者 sub：所面向的用户 aud：接收方 exp：过期时间 nbf：可用时间，在该时间前JWT不可用 iat：签发时间 jti：唯一身份标识，主要用于作为一次性token claim：存放信息的地方 Signature即签名信息。 在java中，JWT的使用方式如下。 12345// 创建JWTString token = JwtTokenUtils.builder().msg(&quot;xxx&quot;).build().creatJwtToken();// 解析JWTString msg = JwtTokenUtils.builder().token(token).build().freeJwt(); RocketMQ消息中间件（消息队列）：利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。 RocketMQ是阿里巴巴开源的一个消息中间件，是一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式特点。目前已贡献给apache。 对比一些其他的消息中间件： ActiveMQ：Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，是使用Java语言编写的。由于年代久远且社区不活跃，目前已极少人使用。 RabbitMQ：AMQP协议的领导实现，支持多种场景。淘宝的MySQL集群内部有使用它进行通讯，OpenStack开源云平台的通信组件，最先在金融行业得到运用，使用Erlang语言编写的。 Kafka：最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm&#x2F;Spark流式处理引擎，web&#x2F;nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。 RocketMQ的主要功能有以下两种： 异步化。将一些可以异步化的操作通过发送消息来进行异步化，从而提高效率。 限流削峰。在高并发场景下把请求存入消息队列，利用排队思想降低系统瞬间峰值。 RocketMQ的一些相关概念如下。 Producer：消息生产者，负责消息的产生。 Consumer：消息消费者，负责消息消费。 Topic：消息的逻辑管理单位，每个消息都具有的一个属性。 Broker：消息的中转角色，负责存储消息，转发消息，一般也称为server，可以理解为一个存放消息的服务，里面可以有多个Topic。 MessageQueue: 消息的物理管理单位，一个Topic下有多个Queue，默认一个Topic创建时会创建四个MessageQueue。 ConsumerGroup: 具有同样消费逻辑消费同样消息的Consumer，可以归并为一个group。 ProducerGroup: 具有同样属性的一些Producer可以归并为同一个Group。 同样属性是指：发送同样Topic类型的消息 Nameserver 注册中心。 作用： 每个Broker启动的时候会向namesrv注册 Producer发送消息的时候根据Topic获取路由到Broker里面Broker的信息 Consumer根据Topic到Namesrv 获取topic的路由到Broker的信息 RocketMQ部署步骤如下： 注册中心Nameserver启动 消息中转服务Broker启动。启动时会创建Topic及其对应的MessageQueue，然后去注册中心注册，把自己的地址以及负责的Topic告诉注册中心。Broker和Nameserver之间通过心跳机制来检测对方是否存活。(Broker每隔30秒向所有Nameserver发送心跳，Nameserver则每隔10秒钟扫描所有存活的Broker，若2分钟内未收到心跳，则断开连接) 消息生产者Producer启动。启动后与一个Nameserver和所有与该生产者关联的Broker保持长连接。每30秒从Nameserver获取所有topic的情况，发送消息时，根据Nameserver、Topic和Broker建立连接。每30秒向所有Broker发送心跳。 消息消费者Consumer启动。启动后操作与Producer相同。 同步刷盘和异步刷盘 RocketMQ的消息可以存储到磁盘，保证断电后可以恢复，且存储的消息量不会超出内存限制。为了提高性能，RocketMQ会尽可能保证磁盘的顺序写，此时写入磁盘会有两种方式： 异步刷盘，返回"},{"title":"学习总结（2022.06.15-2022.06.24）","path":"2022/07/04/学习总结（2022-06-15-2022-06-24）/","text":"动态代理JDK动态代理JDK动态代理是基于Java的反射机制实现的，使用jdk中的接口和类实现代理对象的动态创建，但是要求代理对象必须实现接口。 JDK动态代理的实现步骤如下。 新建一个接口，作为目标接口。 1234public interface UserService &#123; public void sayHello();&#125; 为接口创建实现类。 12345678public class UserServiceImpl implements UserService&#123; @Override public void sayHello() &#123; System.out.println(&quot;hello spring&quot;); &#125; &#125; 创建一个类实现InvocationHandler接口及其invoke方法，在method.invoke()前后执行对方法的增强。 123456public class CustomInvocationHandler implements InvocationHandler &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return null; &#125;&#125; 在main方法中调用Proxy.newProxyInstance()创建JDK动态代理，使用代理对象执行方法。 1234567891011121314151617181920@Testpublic void mytest4() &#123; UserService instance = new UserServiceImpl(); // instance 👉 method.invoke(instance,args); // UserServiceImpl 👉 sayHello // Proxy 👉 sayHello UserService userServiceProxy = (UserService) Proxy.newProxyInstance(UserServiceImpl.class.getClassLoader(), UserServiceImpl.class.getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //jdsfkhjasdjyr System.out.println(&quot;jdsfkhjasdjyr&quot;); Object invoke = method.invoke(instance, args); //dfjkasdhjfisdya System.out.println(&quot;dfjkasdhjfisdya&quot;); return invoke; &#125; &#125;); userServiceProxy.sayHello();//invocationHandler.invoke &#125; Cglib动态代理Cglib动态代理只针对类实现代理，不需要实现接口。 Cglib动态代理的实现步骤如下。 创建一个类实现MethodInterceptor接口及其intercept方法。 12345678910111213141516171819public class MyMethodInterceptor implements MethodInterceptor &#123; /** * cglib * * @param o cglib生成的代理对象 * @param method 被代理对象的方法 * @param objects 方法入参 * @param methodProxy 代理方法 * @return * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;before advice...&quot;); Object object = methodProxy.invokeSuper(o, objects); System.out.println(&quot;after advice...&quot;); return object; &#125;&#125; 在main方法中，通过Enhancer获取代理对象。 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; //通过CGLIB动态代理获取代理对象的过程 Enhancer enhancer = new Enhancer(); //设置enhancer对象的父类 enhancer.setSuperclass(HelloService.class); //设置enhancer的回调对象 enhancer.setCallback(new MyMethodInterceptor()); //创建代理对象 HelloService proxy = (HelloService) enhancer.create(); //通过代理对象调用目标方法 proxy.sayHello(); &#125;&#125; IOC&#x2F;DIIOC，控制反转，将生成实例的控制权交由Spring容器，容器只控制实例的生成，而开发人员只需要往容器中注册需要生成实例的类，即组件，并在需要时取出该组件的对象即可。 DI，依赖注入，即具体的IOC实现方式。一般通过配置文件和注解来完成依赖注入。 XML在Spring的XML文件中注册组件。 123456789101112131415&lt;!--注册组件 → 提供信息 → 向容器中放入实例--&gt;&lt;!--id属性：组件在容器中的唯一标识 → 可以省略--&gt;&lt;!--class属性：组件的全限定类名--&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.cskaoyan.dao.UserDaoImpl&quot;/&gt;&lt;!--set方法来维护组件之间的关系--&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.cskaoyan.service.UserServiceImpl&quot;&gt; &lt;!--property标签的name属性 → set方法--&gt; &lt;!--ref属性：reference → 容器中的组件id--&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;orderService&quot; class=&quot;com.cskaoyan.service.OrderServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;&lt;/bean&gt; 取出组件。 123456789101112131415@Testpublic void mytest1() &#123; // 初始化Spring容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application.xml&quot;); // 通过id取出组件 UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); // 通过类型取出组件byType → class 可以写接口、实现类 → 该类型的组件在容器中只有一个 // 建议用接口 UserService userService1 = applicationContext.getBean(UserService.class); UserService userService2 = applicationContext.getBean(UserServiceImpl.class); // 通过id和类型共同取出 OrderService orderService = applicationContext.getBean(&quot;orderService&quot;, OrderService.class);&#125; 注解也可以使用注解注册组件。可以在注解中指定组件id，也可以使用默认的组件id，默认id一般为类名的首字母小写。 1234567891011// 通用注解@Component// service层@Service// dao层@Repository// controller层@Controller 配置类在一个类上加上@Configuration注解，表示该类被注册为一个组件，且该类为一个配置类。类中的方法可以被@Bean注解修饰，表示该方法的返回值的实例会被注册为一个组件。 1234567891011121314151617181920212223242526272829303132@Configuration// @ComponentScan注解表示扫描指定包下的所有类，并将带有@Component等相关注解的类注册为组件@ComponentScan(&quot;com.cskaoyan&quot;)public class SpringConfiguration &#123; /** * 返回值类型：Spring容器中的组件类型 * 返回值：返回值注册为容器中的组件 * 组件ID：默认值是方法名；如果想要指定组件id，可以使用@Bean的value属性 */ @Bean(&quot;druidDatasource&quot;) public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/cskaoyan_db&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;123456&quot;); return dataSource; &#125; /** * 形参：默认按照类型从容器中取出组件;想要指定组件id → @Qualifier */ // 注册一个UserServiceImpl组件 @Bean public UserService userService(@Qualifier(&quot;userDaoImpl&quot;) UserDao userDao) &#123; UserServiceImpl userService = new UserServiceImpl(); // 从容器中取出userDao并且给其赋值 userService.setUserDao(userDao); return userService; &#125;&#125; @Autowired类中的成员变量可以通过@Autowired注解注册为组件，此时该成员变量就不需要开发人员手动初始化。@Autowired的本质是利用容器提供的set方法。 1234@Autowired// 如果该类型的组件不止一个，需要使用@Qualifier来指定组件的id@Qualifier(&quot;userDaoImpl2&quot;)UserDao userDao; 组件的生命周期组件可以使用@Scope注解来确定自己的作用域。如果作用域为singleton，即单例模式，那么每次从容器中取出的组件都是同一个组件；如果使用的是prototype，即原型模式，那么每次取出的都是新的实例。Spring默认使用单例模式。 在单例模式下，容器初始化时就会开始组件的生命周期；如果是原型模式，则只有在获得组件时才开始生命周期。 组件的生命周期如下。 实例化。 给成员变量赋值。一般通过@Autowired等注解实现。 觉醒（Aware），如果组件实现了Aware相关的接口，在这时组件就可以通过该接口的set方法设置一些数据。比如，如果组件实现了BeanNameAware接口，那么就可以调用setBeanName(String beanName)方法。 BeanPostProcessor，提供了两个实现方法：postProcessBeforeInitialization和postProcessAfterInitialization，其作用范围为所有注册的组件。此时触发的是before方法。 InitializingBean的afterPropertiesSet方法 ，或是自定义的init方法。 12345678910@Overridepublic void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;InitializingBean提供的init方法&quot;);&#125;// 自定义init方法，方法名自己定义@PostConstructpublic void init() &#123; System.out.println(&quot;自定义init&quot;);&#125; BeanPostProcessor的after方法。 使用组件。 DisposableBean的destroy方法，或是自定义的destroy方法。 123456789@Overridepublic void destroy() throws Exception &#123; System.out.println(&quot;DisposableBean提供的destroy&quot;);&#125;@PreDestroypublic void customDestroy() &#123; System.out.println(&quot;自定义destroy&quot;);&#125; AOPAOP，面向切面编程，可以将一些与业务无关，但是所有业务都需要调用的逻辑封装起来（如日志，权限控制等），将其作为一种增强。AOP基于动态代理实现，但是相比动态代理，AOP可以更灵活的筛选需要增强的方法以及增强所要做的业务。 现在一般使用AspectJ框架实现AOP。 切入点Pointcut使用execution指定需要增强的方法。 1234567&lt;aop:comfig&gt;&lt;aop:pointcut id=&quot;mypointcut1&quot; expression=&quot;execution(public voidcom.cskaoyan.service.UserServiceImpl.sayHello(String))&quot;/&gt;&lt;aop:pointcut id=&quot;mypointcut2&quot; expression=&quot;execution(* co*..say*(*))&quot;/&gt;&lt;aop:pointcut id=&quot;mypointcut3&quot; expression=&quot;execution(*co*.cskaoyan..UserServiceImpl.sayHello(..))&quot;/&gt;&lt;/aop:config&gt; 使用@annotation指定特殊的增强方法。 1234@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface CountTime &#123;&#125; 12345&lt;aop:config&gt;&lt;!--作用场景：组件中的方法，包含自定义@CountTime注解的方法生效--&gt;&lt;aop:pointcut id=&quot;mypointcut&quot;expression=&quot;@annotation(com.cskaoyan.CountTime)&quot;/&gt;&lt;/aop:config&gt; 通知器Advisor1234&lt;!--advisor → 新的标签 aop标签 → 引入aop的schema约束--&gt;&lt;aop:config&gt; &lt;aop:advisor advice-ref=&quot;countTimeInterceptor&quot; pointcut=&quot;execution(public void com.cskaoyan.service.UserServiceImpl.sayHello(String))&quot;/&gt;&lt;/aop:config&gt; 切面Aspect切面是上面两种的结合，即在指定的切入点写入自定义的通知。切面有五个通知方法，分别是Before、After、Around、AfterReturning、AfterThrowing。Before和After表示在该方法的执行前后的通知；Around类似于InvocationHandler的invoke()和MethodInterceptor的invoke()，可以在执行proceed方法前后进行操作，Around也是使用的最多的通知；AfterReturning是在方法返回值后使用的通知，可以接收方法的返回值；AfterThrowing是在方法抛出异常后使用的通知，可以接收方法的异常。 五个通知的先后顺序是：Before-&gt;Around-&gt;After&#x2F;AfterThrowing-&gt;AfterReturning 可以使用@Aspect注解指定一个组件为切面组件，且在类中的方法要使用@Before、@After、@Around、@AfterReturning、@AfterThrowing注解修饰方法。 @Aspect@Componentpublic class CustomAspect { 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Aspect@Componentpublic class CustomAspect &#123; //@Pointcut注解增加在方法上 → value属性写切入点表达式，方法名作为切入点的id @Pointcut(&quot;execution(* com.cskaoyan.service..*(..))&quot;) public void servicePointcut() &#123; &#125; // 切面组件中的方法，作为对应的通知方法 → 在对应的时间点下会执行到对应的方法 // 通知注解的value属性：可以直接写切入点表达式；也可以引用切入点方法 @Before(&quot;servicePointcut()&quot;) public void beforex() &#123; System.out.println(&quot;before方法&quot;); &#125; @After(&quot;servicePointcut()&quot;) public void after() &#123; System.out.println(&quot;after通知方法&quot;); &#125; // Around通知 → 最强通知 ：返回值为Object，要有委托类方法的执行 // 类似于InvocationHandler的invoke，类似于MethodInterceptor的invoke // 执行委托类的方法：ProceedingJoinPoint proceed方法 @Around(&quot;servicePointcut()&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123; long start = System.currentTimeMillis(); System.out.println(&quot;开始时间：&quot; + start); Object proceed = joinPoint.proceed(); // 执行委托类的方法 long end = System.currentTimeMillis(); System.out.println(&quot;方法执行时间：&quot; + (end - start)); return proceed; // 就是作为代理对象执行方法的返回值 &#125; // afterReturning通知方法的形参，采用Object类型，接收委托类方法的返回值 @AfterReturning(value = &quot;servicePointcut()&quot;,returning = &quot;result&quot;) public void afterReturning(Object result) &#123; System.out.println(&quot;AfterReturning接收到的结果：&quot; + result); &#125; // public void afterThrowing(Exception exception) &#123; @AfterThrowing(value = &quot;servicePointcut()&quot;,throwing = &quot;exception&quot;) public void afterThrowing(Throwable exception) &#123; System.out.println(&quot;afterThrowing通知：&quot; + exception.getMessage()); &#125;&#125; 连接点JoinPoint在Before和Around通知执行过程中可以获得JoinPoint，通过它拿到一些信息，这意味着在通知中可以有更多操作空间。 joinPoint可以直接写在通知方法的形参中，通过调用其方法获取信息。 123456789101112131415@Before(&quot;servicePointcut()&quot;)public void beforex(JoinPoint joinPoint) &#123; // 代理类 Object proxy = joinPoint.getThis(); // 目标类、委托类对象 Object target = joinPoint.getTarget(); // 参数 Object[] args = joinPoint.getArgs(); // 方法 Signature signature = joinPoint.getSignature(); String name = signature.getName(); System.out.println(&quot;正在执行的方法：&quot; + name); System.out.println(&quot;before方法&quot;);&#125; Spring事务Spring事务有三种事务传播行为，分别是REQUIRED、REQUIRES_NEW、NESTED。 REQUIRED：Spring默认。如果外围的方法不包含事务，那么被修饰的内部方法就添加一个新的事务；如果外围方法包含事务，则内部方法加入该事务，要么一起提交要么一起回滚。 REQUIRES_NEW：如果外围的方法不包含事务，那么内部方法就添加一个新的事务；如果外围方法包含事务，内部方法也添加一个事务，且该事务与外围的事务独立。 NESTED：如果外围的方法不包含事务，那么内部方法就添加一个新的事务；如果外围方法包含事务，内部方法也添加一个事务，且该事务与外围的事务成嵌套关系。 Spring事务的开启方式有： PlatFormTransactionManager，平台事务管理器 12345678public interface PlatformTransactionManager extends TransactionManager &#123; // 根据事务的定义，获得事务的状态 → 开启事务 TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException; // 提交 → 参数是TransactionStatus void commit(TransactionStatus var1) throws TransactionException; // 回滚 → 参数是TransactionStatus void rollback(TransactionStatus var1) throws TransactionException;&#125; TransactionTemplate 12345678910111213141516171819202122232425public class TransferTransactionCallBack implements TransactionCallback &#123; AccountMapper accountMapper; Integer fromId; Integer destId; Integer fromMoney; Integer destMoney; public TransferTransactionCallBack(AccountMapper accountMapper, Integer fromId, Integer destId, Integer fromMoney, Integer destMoney) &#123; this.accountMapper = accountMapper; this.fromId = fromId; this.destId = destId; this.fromMoney = fromMoney; this.destMoney = destMoney; &#125; @Override public Object doInTransaction(TransactionStatus transactionStatus) &#123; // 更新money int update1 = accountMapper.update(fromId, fromMoney); int i = 1 / 0; int update2 = accountMapper.update(destId, destMoney); return null; &#125;&#125; 在配置类使用@EnableTransactionManagement注解开启事务，在需要事务的类或方法中使用注解@Transactional。 1234567891011121314151617@Transactional@Overridepublic void transfer(int fromId, int destId, Integer money) &#123; // 查询现有的money是多少 Integer fromMoney = accountMapper.select(fromId); Integer destMoney = accountMapper.select(destId); // 计算转账后的money是多少 fromMoney -= money; destMoney += money; // 更新money int update1 = accountMapper.update(fromId, fromMoney); int i = 1 / 0; int update2 = accountMapper.update(destId, destMoney);&#125; SpringMVC传统的Servlet映射过程繁琐，需要我们自己处理url和Servlet的映射关系，并根据url判断、分发接口至不同的方法中，且请求参数、响应结果都要自己手动拆封json。在SpringMVC中，则只由一个Servlet：DispatcherServlet来解决上述问题。 在SpringMVC中的流程如下。 客户端（浏览器）发送请求，直接请求到 DispatcherServlet。 DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。 解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。 HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。 处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。 ViewResolver 会根据逻辑 View 查找实际的 View。 DispaterServlet 把返回的 Model 传给 View（视图渲染）。 把 View 返回给请求者（浏览器） 在SpringMVC中，可以完全使用JavaConfig代替配置文件，主要有： AACDSI（AbstractAnnotationConfigDispatcherServletInitializer） 1234567891011121314151617181920public class ApplicationInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; // 加载Spring的配置文件application.xml → 配置类 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;SpringConfiguration.class&#125;; &#125; // 加载SpringMVC的配置文件application-mvc.xml → 配置类 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;MvcConfiguration.class&#125;; &#125; // DispatcherServlet的映射范围 @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125;&#125; Spring配置类，用@Configuration修饰 12345@ComponentScan(value = &quot;com.cskaoyan&quot;, excludeFilters = @ComponentScan.Filter(&#123;Controller.class, EnableWebMvc.class&#125;)) // mvc配置类也在扫描包范围@Configurationpublic class SpringConfiguration &#123;&#125; SpringMVC配置类，用@EnableWebMvc修饰 1234@ComponentScan(&quot;com.cskaoyan.controller&quot;)@EnableWebMvcpublic class MvcConfiguration implements WebMvcConfigurer &#123;&#125; @RequestMapping用于url的路径映射，可以写在类或方法上。 同一个RequestMapping可以映射多个路径，通过数组表示。 1234567891011121314@RequestMapping(&#123;&quot;hello&quot;,&quot;hello2&quot;,&quot;hello3&quot;&#125;) @ResponseBody public String hello() &#123; return &quot;hello world&quot;; &#125;/** * 也可以使用通配符 * */ @RequestMapping(&#123;&quot;goodbye/*&quot;, &quot;goodbye*&quot;&#125;) @ResponseBody public String goodbye() &#123; return &quot;byebye&quot;; &#125; 如果请求url包含共同的前缀，可以提取至修饰类的注解中，这称为窄化请求。 1234567891011121314151617181920212223242526272829@Controller@RequestMapping(&quot;user&quot;)public class UserController &#123; //@RequestMapping(&quot;user/login&quot;) @RequestMapping(&quot;login&quot;) @ResponseBody public String login() &#123; return &quot;login&quot;; &#125; //@RequestMapping(&quot;user/register&quot;) @RequestMapping(&quot;register&quot;) @ResponseBody public String register() &#123; return &quot;register&quot;; &#125; //@RequestMapping(&quot;user/modify&quot;) @RequestMapping(&quot;modify&quot;) @ResponseBody public String modify() &#123; return &quot;modify&quot;; &#125; //@RequestMapping(&quot;user/remove&quot;) @RequestMapping(&quot;remove&quot;) @ResponseBody public String remove() &#123; return &quot;remove&quot;; &#125;&#125; @RequestMapping还有多种属性： method：用于限定请求方法。如GET、POST。 12345@RequestMapping(value = &quot;get&quot;,method = RequestMethod.GET) @ResponseBody public String methodGet() &#123; return &quot;Method GET&quot;; &#125; params：用于限定参数。 12345@RequestMapping(value = &quot;login&quot;,params = &#123;&quot;username&quot;,&quot;password&quot;&#125;) // 既要携带username又要携带password @ResponseBody public String login() &#123; return &quot;ok&quot;; &#125; headers：用于限定请求头。 12345@RequestMapping(value = &quot;limit&quot;, headers = &#123;&quot;abc&quot;, &quot;def&quot;&#125;)//既要携带abc、又要携带def这两个请求头 @ResponseBody public String headerLimit() &#123; return &quot;header limit&quot;; &#125; consumes：用于限定Content-Type的值。 produces：用于限定Accept的值 @ResponseBody在Controller上添加注解@ResponseBody，即可将返回值自动包装为json。 123456789@Controllerpublic class JsonController &#123; @RequestMapping(&quot;json&quot;) @ResponseBody public User json() &#123; return new User(&quot;123&quot;,&quot;456&quot;); &#125;&#125; 可以使用@RestController来代替@Controller和 @ResponseBody。 请求参数的接收如果是普通的get请求，可以使用方法形参来接收参数，但要求形参名与参数名必须一致。类型支持： 字符串String 基本类型以及对应包装类 数组 Date（需要使用@DateTimeFormat来标准化日期格式） 文件 1234567891011121314151617181920@RequestMapping(&quot;register5&quot;)public BaseRespVo register5(String username, String password, Integer age, String[] hobbies, Integer[] ids, @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date birthday) &#123; return BaseRespVo.ok();&#125;@RequestMapping(&quot;file&quot;)public BaseRespVo uploadFile(MultipartFile file) throws IOException &#123; // 获得上传的文件的信息 String name = file.getName(); // 请求参数名 → file String originalFilename = file.getOriginalFilename(); //原始文件名 long size = file.getSize(); // 文件的大小 String contentType = file.getContentType(); // 正文类型 → 文件类型 // MultipartFile.transferTo File saveFile = new File(&quot;D:\\\\WorkSpace\\\\j40_workspace&quot;, originalFilename); //File saveFile = new File(&quot;D:\\\\WorkSpace\\\\j40_workspace\\\\dlrb.jpg&quot;); file.transferTo(saveFile); return BaseRespVo.ok();&#125; 除了形参，还可以使用自定义的引用类型对象，如果使用引用类型的对象时，Servlet会去创建一个新的实例。看你这个类中有哪些成员变量，如果成员变量名和请求参数名相同，就会使用成员变量来接收请求参数，使用set方法来进行封装。所以要求请求参数名与引用类中的成员变量名一致。 12345678910@Datapublic class User &#123; String username; String password; Integer age; String[] hobbies; Integer[] ids; @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date birthday;&#125; 1234@RequestMapping(&quot;register6&quot;)public BaseRespVo register6(User user) &#123; return BaseRespVo.ok();&#125; 如果是post请求，那么发送的请求参数一般是json，需要对json转换成对应的实例。此时需要增加@RequestBody注解来修饰json对应的bean类。 1234@RequestMapping(&quot;user/login&quot;)public BaseRespVo login(@RequestBody JsonUser user) &#123; return BaseRespVo.ok(user);&#125; 如果需要获得Cookie，则不能直接获得，需要通过Request获得。 12345678910// 把所有Cookie都遍历打印一下@RequestMapping(&quot;cookies&quot;)public BaseRespVo cookies(HttpServletRequest request) &#123; Cookie[] cookies = request.getCookies(); for (Cookie cookie : cookies) &#123; System.out.println(cookie.getName() + &quot; --&gt; &quot; + cookie.getValue()); &#125; return BaseRespVo.ok();&#125; 而session可以直接获得。 12345@RequestMapping(&quot;session2&quot;)public BaseRespVo session2(HttpSession session) &#123; Object username = session.getAttribute(&quot;username&quot;); return BaseRespVo.ok(username);&#125; @PathVariable获取请求url中指定占位符的值，并将值赋给对应的形参。 1234@RequestMapping(&quot;note/&#123;id&#125;&quot;)public BaseRespVo note(@PathVariable(&quot;id&quot;) Integer id) &#123; return BaseRespVo.ok();&#125; ConverterConverter，类型转换器，使用主要是在请求参数封装的过程中，也就是Handler方法的形参。在形参并不是String的情况下会用到Converter。 一般情况下需要自己定义Converter。如从String转为User。 12345678910public class String2UserConverter implements Converter&lt;String, User&gt; &#123; @Override public User convert(String s) &#123; // 里面的转换业务需要你自己定义 User user = new User(); user.setUsername(s); user.setPassword(s); return user; &#125;&#125; 12345// 提供自定义的转换器@Overridepublic void addFormatters(FormatterRegistry registry) &#123; registry.addConverter(new String2UserConverter());&#125; ResourceHandler因为在SpringMVC中，DispatcherServlet的映射范围是&#x2F;，即除了jsp外的所有请求，之前JavaEE的访问静态资源的方式就无法使用了，所以需要使用ResourceHandler来进行静态资源映射。 123456@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(&quot;/pic/**&quot;).addResourceLocations(&quot;classpath:/&quot;); registry.addResourceHandler(&quot;/jpg/**&quot;).addResourceLocations(&quot;/&quot;); registry.addResourceHandler(&quot;/png/**&quot;).addResourceLocations(&quot;file:D:\\\\spring/&quot;);&#125; HandlerInterceptor在Handler前执行，起到了拦截的功能。 12345678910111213public interface HandlerInterceptor &#123; // 在Handler方法执行之前 // 返回值为boolean，如果为true则继续流程，如果false，则中断流程 default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125; // 在Handler方法执行之后 default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; &#125; // 在整个流程完成之后 default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; &#125;&#125; 异常处理有两种异常处理方式：统一的全局异常处理 HandlerExceptionResolver和自定义异常处理 ExceptionHandler。 HandlerExceptionResolver是一个接口，接口里提供了resolveException方法，重写该方法来处理全局异常。 123456789101112@Componentpublic class CustomHandlerExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123; // 通过它也可以做个性化的异常处理，如果要做，需要你自己来做个性化的东西 if (e instanceof ArithmeticException) &#123; //做个性化的异常处理 System.out.println(e.getMessage()); &#125; return new ModelAndView(&quot;/exception.jsp&quot;); &#125;&#125; ExceptionHandler是一个注解，value是对应的异常，旨在用对应的方法处理对应的异常。一般放在ontrollerAdvice组件中的方法上。 1234567891011@ControllerAdvicepublic class CustomExceptionControllerAdvice &#123; // 在形参中可以直接接收你抛出的异常，你映射的是什么异常，就可以以什么类型的形参来接收 @ExceptionHandler(ArithmeticException.class) @ResponseBody public BaseRespVo method1(ArithmeticException exception) &#123; return BaseRespVo.fail(exception.getMessage()); &#125; &#125; SpringBootSpringBoot本质上就是一个Spring框架，但是它简化了Spring的配置。在没有给具体配置前，SpringBoot会使用默认的配置，只有给到具体的配置，才采用具体的配置。 启动类： 123456789// 该注解就是SpringBoot应用启动类上的注解 → 会配置扫描包目录就是该类所处的包目录@SpringBootApplicationpublic class Demo1FirstSbApplication &#123; // 启动类中一定会包含main方法 → 就是启动SpringBoot应用程序的入口 public static void main(String[] args) &#123; SpringApplication.run(Demo1FirstSbApplication.class, args); &#125;&#125; SpringBoot对web的支持： 12345678910111213141516# tomcat配置server: port: 8083 #Tomcat的端口号配置 servlet: context-path: /demo1 # 应用程序的上下文配置（应用名） # 静态资源映射spring: mvc: static-path-pattern: /pic/**# spring.resources 或 spring.web.resources resources: static-locations: file:d:/spring/ # Converter# Filter SpringBoot对Mybatis的支持： 123456spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/cskaoyan_db?useUnicode=true&amp;characterEncoding=utf-8 username: root password: 123456 12345678910@SpringBootApplication// 需要添加@MapperScan来扫描mapper@MapperScan(&quot;com.cskaoyan.mapper&quot;)public class Demo1FirstSbApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Demo1FirstSbApplication.class, args); &#125;&#125; 逆向工程逆向工程可以根据数据库中的表自动生成接口、方法、映射文件，只需要操作对应的Example类就可以操作数据库。 接口方法示例。 123456//升序还是降序:字段+空格+asc(desc)protected String orderByClause;//去除重复:true是选择不重复记录,false,反之protected boolean distinct;//自定义查询条件protected List&lt;Criteria&gt; oredCriteria; 123456789101112131415@Testpublic void testFindUserByName()&#123; //通过criteria构造查询条件 UserExample userExample = new UserExample(); userExample.setOrderByClause(&quot;username asc&quot;); //asc升序,desc降序排列 userExample.setDistinct(false); //去除重复,true是选择不重复记录,false反之 UserExample.Criteria criteria = userExample.createCriteria(); //构造自定义查询条件 criteria.andUsernameEqualTo(&quot;张三&quot;); //自定义查询条件可能返回多条记录,使用List接收 List&lt;User&gt; users = userMapper.selectByExample(userExample); System.out.println(users);&#125; 逆向工程生成的内容会有一定问题，如果表中的字段存在sql语句中的关键字，需要自己手动在mapper.xml文件中添加转义字符。 TypeHandlerTypeHandler是Mybatis输入输出映射过程中的类型处理器，用于处理jdbcType和JavaType间的转换。 主要方式是实现TypeHandler接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 类型映射配置@MappedTypes(Integer[].class)@MappedJdbcTypes(JdbcType.VARCHAR)public class IntegerArrayTypeHandler implements TypeHandler&lt;Integer[]&gt; &#123; ObjectMapper objectMapper = new ObjectMapper(); // 输入映射过程 // insert into market_user (id,username,password,role_ids) values (?,?,?,?) @Override public void setParameter(PreparedStatement preparedStatement, int index, Integer[] integers, JdbcType jdbcType) throws SQLException &#123; String value = null; try &#123; value = objectMapper.writeValueAsString(integers); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; // 为第几个占位符提供的值是什么 preparedStatement.setString(index,value); &#125; // 输出映射过程 @Override public Integer[] getResult(ResultSet resultSet, String columName) throws SQLException &#123; // 获得结果 String result = resultSet.getString(columName); return transfer(result); &#125; @Override public Integer[] getResult(ResultSet resultSet, int index) throws SQLException &#123; // 获得结果 String result = resultSet.getString(index); return transfer(result); &#125; @Override public Integer[] getResult(CallableStatement callableStatement, int i) throws SQLException &#123; // 获得结果 String result = callableStatement.getString(i); return transfer(result); &#125; private Integer[] transfer(String result) &#123; Integer[] integers = new Integer[0]; // 使用jackson将字符串转换Integer[] try &#123; integers = objectMapper.readValue(result, Integer[].class); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return integers; &#125;&#125; 配置自定义的TypeHandler 12mybatis: type-handlers-package: com.cskaoyan.typehandler Shiro框架Shiro安全框架，Apache Shiro是一个开源安全框架，提供身份认证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。 Shiro在SpringMVC应用程序中以Filter的形式存在。 Shiro的一些核心术语如下。 Authentication，认证是身份验证的过程 -您正在尝试证明用户是他们所说的人。为此，用户需要提供系统理解和信任的某种身份证明。认证其实就是我们通常所说的登录。 Authorization，授权或访问控制是指定对资源的访问权限的功能。换句话说，谁可以访问什么。比如是否允许用户编辑此数据，这些都是决定用户有权访问的内容的决定。我们当前主要针对的是URL级别的权限访问控制。 Subject，主体，在Shiro中所做的几乎所有操作都基于当前正在执行的用户，也就是基本上Shiro的操作都是使用Subject操作的，Subject指的就是当前操作的用户。在代码中的任何位置都可以轻松获得Subject，通过Subject可以方便的操作Shiro。比如我们可以使用Subject提供的方法来执行认证、判断是否认证等操作。 Principals，主体鉴定后的参数，也就是认证后的用户信息，可以是姓名、用户id、用户对象等形式。 Credentials，用来验证身份的秘密数据，通常指密码，生物数据比如指纹、面部、瞳孔等。 Realms，域或领域，安全的特殊数据存储对象（DAO），Shiro中的Realm主要是让你能够获得对应的认证信息和授权信息。 Token，令牌，Shiro中的Token是作为登录操作的参数。 Shiro的核心组件如下： SecurityManager，安全管理器 Authenticator，认证器 SessionManager，会话管理器 Realm，域 CacheManager，缓存管理器 Cryptography，密码学 Shiro提供的Filter类型如下。 Filter名称 Filter类 说明 anon org.apache.shiro.web.filter.authc.AnonymousFilter 匿名Filter，作用范围内的请求不需要认证和授权 authc org.apache.shiro.web.filter.authc.FormAuthenticationFilter 认证Filter，作用范围内的请求需要完成认证 perms org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter 权限Filter，作用范围内的请求需要完成认证和授权 我们可以设置不同类型的Filter分别映射一些不同的URL范围，当请求发送到应用程序时，根据请求URL分别判断使用哪一些Filter，在Filter中决定是否继续访问流程。在SpringBoot中，主要在配置文件中配置。 RealmShiro中的Realm主要是让你能够获得对应的认证信息和授权信息。 一般通过自定义Realm来使用，需要继承一个抽象类AuthorizingRealm，并实现两个抽象方法： doGetAuthenticationInfo ：获得认证信息，即根据token中的用户名查询该用户在系统中的Credentials，并且构造AuthenInfo。 doGetAuthorizationInfo ：获得授权信息，即根据Principal（放入AuthenInfo中的第一个参数）查询该用户在系统中的权限信息。 在这两个方法中去写获得用户认证信息和授权信息的业务代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Componentpublic class CustomRealm extends AuthorizingRealm &#123; //通常把doGetAuthenticationInfo方法放在上面 //该方法的形参 → 来源于subject的login方法 // 传入该值，为了根据用户名查询到该用户在系统中的密码（数据库中维护） → 来构造认证信息 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; String username = token.getUsername(); //根据username查询数据库中对应password String password = selectPasswordByUsername(username); // principal信息 → 当前放的是什么信息，后续取出的就是什么信息 // 密码 → 该密码会和Token中的password做比较 // realm名称 → 没啥用 return new SimpleAuthenticationInfo(username,password,getName()); &#125; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; // 根据用户信息拿到所有的权限（数据库） // doGetAuthenticationInfo方法返回值的第一个参数就是用户信息 // 在第21行代码放入的是字符串类型的Principal信息，取出的时候就可以以字符串格式取出 String primaryPrincipal = (String) principalCollection.getPrimaryPrincipal(); List&lt;String&gt; permissions = getPermissionsByUsername(primaryPrincipal); SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); simpleAuthorizationInfo.addStringPermissions(permissions); return simpleAuthorizationInfo; &#125; private String selectPasswordByUsername(String username) &#123; // 应该通过MyBatis根据用户名查询获得结果 return &quot;123456&quot;; &#125; private List&lt;String&gt; getPermissionsByUsername(String username) &#123; // 应该通过MyBatis根据用户名查询获得结果 return Arrays.asList(&quot;admin:user:list&quot;, &quot;admin:admin:list&quot;); &#125;&#125; 认证在对应请求中获得subject，并执行subject的login方法。 因为登录请求不需要权限，需要将其权限设为anon subject对象可以在所有组件中获得，方式为Subject subject = SecurityUtils.getSubject() 在绝大多数场景下，login方法的参数都为AuthenticationToken接口，可以直接使用其实现类UsernamePasswordToken： subject.login(new UsernamePasswordToken(username,password)) 如果需要获得sessionId，可以使用subject获得： subject.getSession().getId() 123456789101112131415161718192021222324252627@PostMapping(&quot;login&quot;)public BaseRespVo&lt;LoginUserData&gt; login(@RequestBody Map map) &#123; String username = (String)map.get(&quot;username&quot;); String password = (String)map.get(&quot;password&quot;); // 整合Shiro // 获得操作的主体 Subject subject = SecurityUtils.getSubject(); // login方法传入的参数AuthenticationToken → 认证的令牌 // subject执行login → 认证器执行认证方法 → realm.doGetAuthenticationInfo // AuthenticationToken → UsernamePasswordToken → 直接封装了username和password // username和password通过Handler方法的形参传入 subject.login(new UsernamePasswordToken(username,password)); if (subject.isAuthenticated()) &#123; System.out.println(&quot;认证成功&quot;); &#125; LoginUserData loginUserData = new LoginUserData(); AdminInfoBean adminInfo = new AdminInfoBean(); adminInfo.setAvatar(&quot;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif&quot;); adminInfo.setNickName(&quot;admin123&quot;); loginUserData.setAdminInfo(adminInfo); // 携带SessionId信息 loginUserData.setToken((String) subject.getSession().getId()); return BaseRespVo.ok(loginUserData);&#125; 认证后可以通过subject.getPrincipals().getPrimaryPrincipal()来获取用户在数据库中的其他信息。该方法的返回值为Object，可以直接转换为对应的用户信息PO类。 可以通过subject.logout()登出用户。 HibernateValidation在需要对一些参数进行校验时，可以在Handler方法的形参上增加注解@Valid或@Validated，或在引用类型中的成员变量上增加校验功能的注解。 常见注解如下。 1234567891011121314151617181920常见的注解 （Bean Validation 中内置的 constraint） @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 Date @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator 附加的 constraint @NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内"},{"title":"学习总结（2022.05.27-2022.06.07）","path":"2022/06/05/学习总结（2022-05-27-2022-06-05）/","text":"HTTP协议详细过程： 域名解析 TCP建立连接 发送HTTP请求报文 返回HTTP响应报文 浏览器解析HTML代码，渲染页面，呈现给用户 其中请求报文的格式为： 请求行。请求行由请求方法(GET&#x2F;POST)，请求资源，请求协议(HTTP&#x2F;1.1)组成 请求头。 空行。 请求体。 响应报文的格式为： 响应行。响应行由版本协议，状态码(200,301,404,500…)，原因短语组成。 响应头。 响应体。 状态码中比较重要的有： 200 过程正常 301，302，307 重定向 404 未找到，意味着没有对应的资源文件 500 服务器异常，意味服务器代码出现bug ServletServlet 是一个在 Web 服务器中运行的小型 Java 程序。Servlet 接收和响应来自 Web 客户端的请求，通常通过HTTP协议来实现。 Servlet有两种写法：一种是通过继承GenericServlet并重写service方法；一种是通过继承HttpServlet并重写doGet方法和doPost方法。其中HttpServlet继承了GenericServlet，并将它的service方法分解成了doGet和doPost，以更好地处理GET请求和POST请求。 在Servlet中，可以通过注解的方式来配置本地程序与URL的映射关系，称为url-pattern，主要通过@WebServlet配置。一个Servlet可以配置多个url-pattern，但是一个url-pattern只能对应一个Servlet。 设置url-pattern时，可以使用通配符，如：/*、 *.html，且具有优先级，优先级判定如下： &#x2F;xxx优先级高于*.xxx 如果都是&#x2F;xxx，那么匹配程度越高，优先级越高 在访问静态文件时，其实访问的是一个url-pattern为/*的Servlet，该Servlet称为缺省Servlet，由tomcat提供，默认逻辑是将请求地址当作静态文件。它可以被重写，只需要在项目中设置一个url-pattern为/*的Servlet即可。 Servlet有三个生命周期，分别是init，service，destory，可以通过重写其生命周期方法来完成一些需要在这个生命周期中完成的操作。比如用init()读取文件，service()修改文件，destory()保存文件。此外，init()方法只有在浏览器第一次访问当前Servlet时调用，需要在注解中设置load-on-startup=1来令init()方法可以随着应用加载而触发执行。 ServletContextServlet具有一个ServletContext对象，它代表的是Servlet中的Context域，每个应用中只有唯一的一个Context域，无论哪个Servlet都可以拿到域中的数据，所以它一般用于Servlet间的共享。 API： 123456789101112// 获取servletContextServletContext servletContext = getServletContext();// 设置Context中的键值对servletContext.setAttribute(key,value);// 根据key获取Context中的valueservletContext.getAttribute(key);// 删除键值对servletContext.removeAttribute(key);// 获取Servlet设置servletContext.getServletConfig();// 获取一个相对应用根目录的绝对路径servletContext.getRealPath(String s); ServletRequestServletRequest是客户端提供给Servlet的请求报文的封装体，Tomcat创建ServletRequest对象并将其作为参数传给service方法。HttpServletRequest继承了ServletRequest，主要用于封装HTTP格式的请求报文。 Request对象和对象间可以通信，这种方式叫做转发。 Request与Context相似，也拥有一个Request域，但是Request域只存在在一个Request对象中，且会随着Request对象的销毁而销毁，在多个Request对象中，Request域不共享，只有通过转发才能与其他对象共享。所以Request域一般用于存放不频繁使用的数据。 API： 123456789101112131415161718192021222324252627282930313233343536373839// 获取请求报文// 获取请求行getMehtod();// 获取请求URLgetRequestURL();// 获取请求URI，URL=协议+主机IP地址+端口号+URIgetRequestURI();// 获取请求协议getRequestProtocol();// 获取所有请求头getHeaderNames();// 获取单个请求头getHeader(key);// 获取请求体getInputStream();// 获取客户机信息// 获得客户机IP地址getRemoteAddr();// 获得客户机端口号getRemotePort();// 获取服务器主机信息// 获得主机IP地址getLocalAddr();// 获得主机端口getLocalPort();// 获取请求参数// 根据key获取单个valuegetParameter(key);// 根据key获取多个valuegetParameterValues(key);// 获取所有key值getParameterNames();// 获取key、value映射的mapgetParameterMap();// 设置请求体的编码集，需要在读取请求参数前调用setCharacterEncoding(&quot;utf-8&quot;); ServletResponseServletResponse是客户端提供给Servlet的响应报文的封装体，Tomcat创建ServletResponse对象并将其作为参数传给service方法。HttpServletResponse继承了ServletResponse，主要用于封装HTTP格式的响应报文。 API： 12345678// 设置响应报文setStatus(200);// 在响应头添加属性，如设置响应报文字符集setHeader(&quot;Content-type&quot;,&quot;text/html;charset=utf-8&quot;);// 获取字符流，在响应体添加内容getWriter();// 获取字节流，在响应体添加内容getOutputStream(); 会话技术HTTP协议存在无状态性，即所有客户端发送的请求报文是完全相同的，服务器不可能通过请求报文区分客户端，也无法为每个独立的客户端处理数据。解决HTTP无状态性的即是会话技术。 会话技术分为客户端技术和服务端技术，即Cookie和Session。 CookieCookie数据产生于服务器，产生之后会通过HTTP响应报文传输给客户端，客户端来保存这些数据，在客户端再次访问服务器时，会把这些数据通过HTTP请求报文再次携带回来，这样服务器就了解请求来自于哪个客户端。Cookie的本质就是在请求报文中加入了Cookie请求头，在响应报文中加入了set-Cookie请求头。 Cookie的使用方式如下 123456// 构造函数生成CookieCookie cookie = new Cookie(String name, String value);// response中添加Cookieresponse.addCookie(cookie);// request中获取CookieCookie[] cookies = request.getCookies(); Cookie可以进行一些设置，设置方式如下 1234567// 设置存活时间// 设置正数表示在硬盘中存活多久；负数表示存在于浏览器的内存中；0表示删除Cookiecookie.setMaxAge(180);// 设置路径，仅访问指定路径才会携带Cookiecookie.setPath(String path);// 设置域名，访问指定域名才会携带Cookiecookie.setDomain(String addr); Cookie轻便，可以跨多主机间数据共享，而且因为存储在客户端，减轻了服务器的压力；但是Cookie只能存储字符串类型，大小也有限制，而且Cookie的安全性存在问题，只能存储一些不敏感的数据。 Session因为数据的产生与存储均是在服务器完成，所以服务器可以在特定场景下给客户端单独开辟一块空间（即对象），该对象专门只为这个客户端服务，这个对象就被称为Session对象。 Session的本质是服务器生成一个Session对象，将该对象的编号通过Cookie返回给客户端，后续客户端访问服务器时，都会把Session的编号携带过来，那么服务器就可以获取到对应的Session对象，就能在该对象中进行只针对该客户端的数据的存取和处理。 Session的使用方式如下 123456// 获取Session对象Session session = request.getSession();// Session中存储数据session.setAttribute(String name,Object object);// Session中获得数据session.getAttribute(String name); 至此可以知道，服务器存在三个域：Context域，Session域，Request域。 Context域最大，一个服务器应用中只有一个，主要用于存储一些全局性的数据；Session域其次，一个客户端对应一个Session对象，一般存储客户端特有的数据；Request域最小，一个Servlet请求对应一个Request对象，一般存储访问频次不高的数据。 Session对象不会随着浏览器关闭而销毁，只是新的浏览器无法访问之前浏览器创建的Session对象；Session对象会随着服务器关闭而销毁，但是Session数据并不会被销毁，而是被序列化保存在硬盘中，只有在有效期到达，或者服务器主动调用invalidate()方法，才会被销毁。 ListenerListener，即监听器，是EE三大组件之一，主要负责监听对象。常用的Listener为servletContextListener，用于监听ServletContext对象的创建和销毁，以替代Servlet中的init()方法和destory()方法。 Listener的实现方式如下 123456789101112131415@WebListenerpublic class MyServletContextListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent servletContextEvent) &#123; System.out.println(&quot;当servletContext对象被创建时，会调用该方法&quot;); ServletContext servletContext = servletContextEvent.getServletContext(); &#125; @Override public void contextDestroyed(ServletContextEvent servletContextEvent) &#123; System.out.println(&quot;当servletContext对象被销毁时，会调用该方法&quot;); &#125;&#125; FilterFilter，即过滤器，是EE三大组件之一，主要负责权限验证，对请求进行放行或拦截，可以在请求到达关联的Servlet前，检查修改Request对象，也可以在响应返回到客户端前，检查修改Response对象。 Filter的实现方式如下 123456789101112131415161718192021222324@WebFilter(&quot;/filter1&quot;)public class FirstFilter implements Filter &#123; //filter的初始化阶段 //init阶段和servlet略有不同；当应用的启动，init方法就会被执行 @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;init&quot;); &#125; //类似于servlet的service方法，每次访问filter时，都会经过该方法 @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;doFilter&quot;); //下面这行代码对于请求的放行是至关重要的；如果没有，则执行的是拦截操作；如果有，则执行的是放行操作 filterChain.doFilter(servletRequest, servletResponse); &#125; //当应用卸载、服务器关闭，会调用该方法 @Override public void destroy() &#123; System.out.println(&quot;destroy&quot;); &#125;&#125; Filter与Servlet生成关联的方式有 Filter与Servlet设置相同的url-pattern Filter设置&#x2F;*（常用） Filter与Filter之间可以生成关联，具体方式为设置相同的url-pattern，Filter的执行顺序由类的首字母ASCII顺序（注解声明）或filter-mapping声明的先后顺序（web.xml声明）。 完整请求处理流程 浏览器解析域名，与服务器建立TCP连接 浏览器发送HTTP请求报文，被服务器中的Connector接收，Connector将其解析为Request对象，同时新建一个Response对象 Connector对象将两个对象传给Enginee对象，Enginee对象进一步传递给Host对象。 Host挑选一个合适的Context对象，再将两个对象传输给Context对象。 Context对象根据路径查找是否有匹配的Filter需要处理该请求，如果有则交由Filter处理，Filter处理完毕再将请求发送给对应的Servlet；如果没有则直接发送给Servlet。 Servlet接收到请求后执行service方法，执行完毕后，如果存在对应的Filter，则将处理后的两个对象返回给Filter，Filter处理完毕后再原路返回；如果没有则直接原路返回。 最后Connector获得Response对象，读取其中的数据后按照HTTP响应报文的格式要求，生成响应报文，发送给客户端。 客户端接收响应报文，解析、渲染，形成页面。 MVCMVC分别是模型层(model)，视图层(view)和控制层(controller)，将应用的代码按照MVC模式分离，以达到解耦的目的。 模型层：主要存放数据的模型和对数据的操作。 视图层：主要用于显示页面或将数据结果返回给前端显示。 控制层：用于接收来自模型层的数据，并将处理后的数据返回给视图层，起到了连接模型层和视图层的作用。 MVC的核心思想就是在请求到来后，首先交给控制层处理，控制层调用模型层的代码处理数据，返回的结果再由控制层交给视图层。 三层架构是MVC设计模式的一种演进，可以将MVC进一步抽象成三个模块，分别是展示层(view、controller)、业务层(service)和数据层(Dao)。 为了进一步降低代码的耦合性，可以将模型层中对数据的操作部分提取出来，命名为dao(Data Access Object)，该层可以设计一个接口，因为对数据操作时，参数类型和返回值都是不变的；这样我们就可以设计不同的实现类来实现接口，从而完成对数据的不同操作。 service层则是在controller和dao之间的业务层，主要任务是保证业务处理的实现方式的多样性。如果存在多个业务处理方式，那么就需要对controller层进行反复修改，违反了设计模式的开闭原则（对新增代码开放，对修改代码关闭），所以需要一个service层来保证可以存在多个业务处理方式。service层与dao层一样，只需要设计一个接口以保证参数类型和返回值不变，之后只需要设计实现类实现接口，并在controller层的相应位置调用即可。"},{"title":"学习总结（2022.05.24-2022.05.26）","path":"2022/05/26/学习总结（2022-05-24-2022-05-26）/","text":"RedisRedis是一个NoSQL数据库，因为它基于内存存储，有很高的读取性能，但同时也不能存储大量数据，无法有SQL的容量，所以一般作为SQL的缓存使用。使用方式是：Java应用首先在Redis中查询数据，如果没有获得结果再去SQL中查询。 放在内存中意味着Redis的数据并不能一直储存，且随着机器故障或者重启有丢失数据的风险，所以Redis有将内存中的数据存储至硬盘的功能，这种功能叫做持久化。 Redis的持久化有两种：RDB和AOF。 RDBRDB，即通过快照技术（保存某一时刻内存中数据的状态）保存数据的一种持久化策略。由于保存的是内存状态，所以保存的文件是比较小的，且是不可读的二进制文件。RDB默认是开启的 RDB默认的保存策略如下。 123456# 每900秒内key存在1次变化，触发RDBsave 900 1 # 每300秒内key存在10次变化，触发RDBsave 300 10# 每60秒内key存在10000次变化，触发RDBsave 60 10000 但是RDB并不是完全的策略，因为在两次RDB触发事件间发生数据丢失则无法恢复，所以需要另外一种策略填补。 AOFAOF是通过不断往日志文件中写入Redis的写操作相关命令，通过命令恢复数据的一种持久化策略。 AOF默认的保存策略如下。AOF默认是关闭的。 123456# always：只要收到一条写命令，就保存至日志appendfsync always# everysec：每秒保存一次至日志appendfsync everysec# no：从不保存appendfsync no AOF和RDB的区别如下： RDB恢复数据的速度较快，AOF因为要读取日志文件的命令来恢复数据，所以速度较慢。 RDB存储的数据文件较小，而AOF因为会不断在日志文件中写入命令，日志文件会越来越大。 所以RDB适合用于容灾备份，AOF适合用于日常备份。 数据结构Redis常用的有五种数据结构，分别是string，hash，list，set，sortset。 string：存储的是一对键值对，一般用于需要计数的场景，如用户的访问次数，文章转发数等。 常用命令如下。 1234567891011121314# 设置一个键值对set# 获取一个键对应的值get# 给整数类型的值+1incr# 给整数类型的值加指定的值incrby# 设置多个键值对mset# 获取多个键的值mget# 设置一个键值对，并设置过期时间setex hash：存储的是一个二维表，适合存储对象，所以一般用于存储商品信息，用户信息等。 常用命令如下。 1234567891011121314# 设置一个键值对hset# 获取一个field对应的值hget# 设置多个键值对hmset# 获取多个field对应的值hmget# 获取表中所有field和valuehgetall# 获取表中所有fieldhkeys# 获取表中所有valuehvals list：是一个有序，可重复的线性表，可以从两头插入和删除，但不支持随机查找，一般用于消息队列。 常用命令如下。 123456789101112131415161718# 列表左边推入元素lpush# 列表右边推入元素rpush# 列表左边弹出元素lpop# 列表右边弹出元素rpop# 计算元素个数llen# 获取指定下标的值，最左边元素index为0lindex# 插入一个元素linsert# 查询范围内元素lrange# 删除指定的前几个元素lrem set：是一个无序的集合，但不可存储重复的键值对。因为Redis支持通过多个set查询它们的交&#x2F;并&#x2F;差集，所以一般用于查找共同好友、发现共同关注等。 常用命令如下。 12345678910111213141516171819202122# 添加元素sadd# 查询所有元素smembers# 判断一个元素是否在集合中sismember# 查询元素数量scard# 移动元素至另一集合smove# 删除元素srem# 随机取出一个元素并删除spop# 随机取出一个元素，不删除srandmember# 求集合交集sinter# 求集合并集sunion# 求集合差集sdiff zset：是一个有序的集合，可以根据集合中的score对数据进行排序，一般用于直播礼物排行榜、游戏积分排行榜等。 常用命令如下。 123456789101112131415161718192021222324# 添加成员及分数zadd# 统计成员个数zcard# 统计一个分数区间内成员的数量zcount# 获取一个成员的分数zscore# 为成员增加分数zincrby# 获取一个成员的升序排名zrank# 获取一个成员的降序排名zrevrank# 查找指定排名区间的成员zrange# 查找指定排名区间的成员，倒序排列zrevrange# 查找指定分数区间的成员zrangebyscore# 查找指定分数区间的成员，倒序排列zrevrangebyscore# 删除指定成员zrem 内存淘汰策略Redis是将数据存储在内存上的，如果内存已满，就需要淘汰一些不需要的数据，以保证之后的数据写入成功。Redis有八种内存淘汰策略。 volatile-lru：从已经设置过期时间的数据集中，选择最近使用次数最少的数据淘汰。 volatile-lfu：从已经设置过期时间的数据集中，选择一段时间内使用次数最少的数据淘汰。 volatile-ttl：从已经设置过期时间的数据集中，选择最近将要过期的数据淘汰。 volatile-random：从已经设置过期时间的数据集中，随机选择数据淘汰。 allkeys-lru：从所有数据集中，选择最近使用次数最少的数据淘汰。 allkeys-lfu：从所有数据集中，选择一段时间内使用次数最少的数据淘汰。 allkeys-ttl：从所有数据集中，选择最近将要过期的数据淘汰。 allkeys-random：从所有数据集中，随机选择数据淘汰。 理论上volatile-lru是最合理的，但也是最慢的，而allkeys-random是速度最快的，所以应对不同的业务场景，需要采取不同的内存淘汰策略。 Linux常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107# 基础命令# 查看当前路径pwd# 进入指定路径（相对路径/绝对路径）# .: 当前路径# ..: 上一级路径cd# 显示路径下所有文件# -a: 显示隐藏文件# -l: 显示文件信息ls# 文件与目录管理# 创建新的目录文件mkdir# 删除空目录文件rmdir# 复制文件或目录# -r: 表示递归复制# -f: 表示强制cp# 删除文件或目录# -r: 表示递归删除# -f: 表示强制rm# 移动文件或目录mv# 创建文件touch# 查看文件中的内容cat# 以分页形式查看文件内容less# 查看文件的前几行head# 查看文件的后几行tail# 重定向&gt;# 追加&gt;&gt;# 压缩tar -zxvf# 解压tar -zcvf# 文本编辑# 命令模式# 删除光标所在字符x# 删除光标所在行dd# 删除光标所在行直到文件末尾dG# 删除光标所在位置直到文件末尾D# 插入模式# 在光标所在位置编辑i# 在光标所在行末尾编辑A# 移动到下一行编辑o# 移动到上一行编辑O# 末行模式# 退出q# 保存w# 强制!# 用户管理# 添加用户useradd# 删除用户userdel# 修改用户usermod# 查看用户id# 组管理# 添加组groupadd# 权限管理# 修改权限chmod# 进程管理# 查看父进程idps -ef | grep# 查看资源使用情况px aux | grep# 终止进程kill# 网络管理# 查看ipifconfig# 查看端口占用情况netstat -anp | grep# 软件安装sudo apt install Git常用命令1234567891011121314151617181920# 下载远程仓库，并在本地创建一个同名文件夹git clone# 查看工作区和缓冲区变化git status# 将工作区的变化提交到缓冲区git add# 将缓冲区的变化提交到本地仓库git commit# 把本地仓库的变化推送到远程仓库git push# 拉取远程仓库的变化到本地仓库git pull# 查看仓库的所有版本信息git log# 将工作区的变化回退git checkout# 将缓冲区的变化回退到工作区git reset# 将本地仓库回退至历史版本git reset --hard Git处理冲突如果push时发现本地仓库版本低于远程仓库版本，会push失败，只有使用pull将本地仓库版本更新，才能继续修改。 修改后推送到本地仓库时，如果修改的是同一个文件和同一个内容，会提示产生冲突，需要人为处理；如果不是同一文件或不是同一内容，则不会提示。 由上可知，使用git时应该注意尽量不要开发同一个文件，不然容易产生冲突；且push前最好pull一下，防止push失败。 Git忽略文件git可以在push时忽略一些文件，不对这些文件进行版本控制。使用方式是将这些文件放在.gitignore文件夹下。"},{"title":"学习总结（2022.05.17-2022.05.23）","path":"2022/05/23/学习总结（2022-05-17-2022-05-23）/","text":"索引索引是一种帮助提高查询速度的数据结构，可以提高MySQL的查询语句的效率。 索引的数据结构的选择有两个指标：单值查询和范围查询。各个数据结构的查询效率如下： 数组：单值查询慢，范围查询慢。 链表：单值查询慢，范围查询慢。 二叉树：单值查询较慢，范围查询慢。 B树：单值查询较快，范围查询慢。 B+树：单值查询较快，范围查询较快（MySQL官方推荐数据结构） Hash表：单值查询快，范围查询慢（MySQL内部使用，不开放给用户） B+树是对B树的一种优化。叶子节点之间维护一个指针，方便了范围查找；所有非叶子节点会在叶子节点中冗余一份，并且自身不再存储数据，而只存储key值，这样就降低了树的高度。 为什么要降低树的高度？因为数据库读取数据时是按树的层序读取，而每一次读取都要经历一次磁盘IO，所以树的高度越低，磁盘IO的次数越少，效率越高。 为什么MySQL使用主键自增策略？因为无序的插入索引会导致树的结构发生较多较大的变化，而改变结构是要消耗时间的。在主键自增的策略下，每次新建的数据的主键索引就永远插入到索引树的右侧，这样就能保证树的结构不会发生较大的改变。 索引是不是声明的越多越好？首先，声明索引需要建立索引树，需要占用空间；其次，每次对数据的增删改都会影响索引树的结构，如果索引树太多势必会导致维护这些索引树的代价提升。所以索引并不是越多越好。 数据库的组成结构连接器：校验用户名和密码，和客户端建立连接。 分析器：进行语法分析，编译SQL语句。 优化器：优化SQL语句的性能，主要操作为 选择哪个索引进行查询。 多表查询时，选择表连接的顺序。 执行器：执行SQL语句编译后的指令。 存储引擎：存储数据。 存储引擎目前MySQL使用的引擎有MyISAM和InnoDB。 MyISAM：MyISAM有三种文件，分别是表结构定义文件、数据文件和索引文件。因为它的数据和索引是分开存储的，所以MyISAM的索引叫非聚集索引。索引分为两种类型：主键索引和非主键索引，根据索引树是否是由主键生成来区分。在MyISAM中： 主键索引的key值为主键值，data为数据对应的地址值。 非主键索引的key值为指定的队列值，data也为数据对应的地址值。 InnoDB：InnoDB有两种文件。分别是表结构定义文件、数据&#x2F;索引文件。因为它的数据和索引放在一个文件中，所以InnoDB的索引叫聚集索引。在InnoDB中： 主键索引的key值为主键值，data为主键对应的数据。不同于MyISAM存储的是数据的地址，因为InnoDB存储的是数据本身，这就要求InnoDB必须有一列主键，否则就无法构建索引树。如果用户建表时不声明主键，那么InnoDB会维护一个隐藏列作为主键。MySQL推荐自定义主键的原因就是如果我们不声明主键，我们也无法通过隐藏的索引列来进行查询，这就浪费了主键索引的性能。 非主键索引的key值为指定的队列值，data为数据对应的主键值。 MyISAM与InnoDB的区别： InnoDB支持事务，MyISAM不支持事务。 InnoDB支持外键，MyISAM不支持外键。 InnoDB支持表锁和行锁，MyISAM只支持表锁。 那么什么情况下使用MyISAM？因为MyISAM不支持事务，且只支持表锁，会导致增删改查的效率下降，并有发生隔离问题的可能，所以一般存储不需要更改的数据，比如历史数据。 索引语法1234567891011121314151617-- 查询索引show index from tableName;-- 建立索引create table tableName( id int PRIMARY KEY, index idx_name(name) using BTREE)ENGINE=InnoDB character set utf8;-- 查看索引show index from tableName;-- 删除索引alter table tableName drop index idx_name;-- 添加索引alter table tableName add index idx_name; 回表回表是指在一次查询中，需要根据非主键索引查询出主键值，再根据主键值在主键索引中找到数据，这样就查询了两条索引树，导致查询的效率变低了。 如何避免回表？主要的方式有： 尽量使用主键查询。因为只有使用非主键索引才会发生回表。 尽量避免使用select * from。因为如果准确列出列名，且列名中包含非主键索引，那么该列的值会直接使用非主键索引中的值，而非去使用获得主键，并在主键索引树查询得到的值。 可以考虑使用联合索引。这样可以降低非主键索引树的高度，能更快的查到主键值。 MavenMaven是一个项目管理工具，主要功能是编译项目、将项目打包为jar包、依赖管理。 Maven有以下指令： clean：删除编译好的项目文件夹target。 validate：验证项目中文件的合法性和权限。 compile：编译项目，生成target文件夹。 test：可以运行test包下的所有测试方法。 package：将项目打包成.jar或.war。 verify：验证打包是否有效且合法。 install：可以将打包生成的jar包复制到本地仓库中。 site：建立远程站点。 deploy：把本地仓库传输到远端部署。 依赖管理scope作用域：在导入依赖时，可以对依赖所影响的作用域进行限制，使用标签即可。 作用域有以下几种： test：仅在test包下有效，在main包下无效。 provide：在编译时生效，在运行时失效。主要用于对依赖的版本控制，如对旧依赖使用provide作用域。 runtime：在编译时失效，在运行时生效。主要用于面向接口编程时对编程的规范，如JDBC，在使用JDBC的方法时，由于编译时使用的是java自带的接口，运行时才使用导入的驱动包中的实现类，所以此时编译并不会报错，且可以正常运行。 compile：默认作用域，作用于全局。 依赖传递：依赖具有传递性。如A依赖引入了B依赖，B依赖引入了C依赖，那么A依赖就一定也会引入C依赖。 依赖冲突：在同一个项目中，导入同一依赖的不同版本，就会发生冲突。冲突的解决方法有： 声明优先原则：指同一依赖的不同版本中，谁先在pom.xml声明，就优先使用谁。 就近原则：指在依赖传递时，谁传递的次数比较少，就优先使用谁。就近原则的优先级高于声明优先原则。 手动排除。 提取常量。在pom.xml顶部事先提取依赖版本，这样就可以避免依赖冲突。 1234567891011121314151617&lt;properties&gt; &lt;!-- 1. 提取了常量之后，可以避免依赖冲突的问题 2. 提取了常量之后，可以方便我们后期管理这些依赖（查看版本，更换版本） --&gt; &lt;spring.version&gt;5.3.3&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 清理Maven在本地仓库下寻找含有lastupdated和part关键字的文件，删除之。 JunitJunit是一种测试工具，可以运行指定的方法。 Junit有以下五种注解： @Test：单元测试。修饰的方法必须是public void，必须没有参数。 @After：在测试执行后执行。 @Before：在测试执行前执行。 @AfterClass：在测试类类加载前执行。 @BeforeClass：在测试类中的全部方法执行完毕后执行。 其中，@AfterClass、@BeforeClass必须修饰静态方法。 测试类必须放在test包下。 测试类一般命名为XxxTest，测试方法一般命名为testXxx。 MybatisMybatis是一种ORM框架。ORM意为对象关系映射，即是将SQL中的数据转化为Java对象，或是将Java对象转化为SQL记录。Mybatis可以帮我们在Java中更高效的操作数据库。 Mybatis需要一个主配置文件，用于获取SqlSessionFactory。SqlSessionFactory时一个工厂，用于生产SqlSession实例对象。SqlSession是一种Mybatis框架与数据库的连接，里面封装了Connection对象。 配置文件样例如下。 123456789101112131415161718192021222324252627&lt;configuration&gt; &lt;settings&gt; &lt;!-- 添加日志的配置 --&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt; &lt;!-- 环境的配置，其实就是去配置数据库连接--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/40th?useSSL=false&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--&lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 其中标签用于放置SQL语句的配置文件，一般命名为XxxMapper.xml，并放置于Maven项目中的src&#x2F;main&#x2F;resources文件下，且要与src&#x2F;main&#x2F;java中的Mapper接口在相同的路径下。 Mapper配置文件样例如下。 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- mapper.xml 映射文件中的标签没有顺序要求 --&gt;&lt;!-- namespace: 命名空间，需要唯一 --&gt;&lt;mapper namespace=&quot;cskaoyan&quot;&gt; &lt;!--&lt;insert id=&quot;&quot;--&gt; &lt;!--&lt;delete id=&quot;&quot;--&gt; &lt;!--&lt;update id=&quot;&quot;--&gt; &lt;!--&lt;select id=&quot;&quot;/&gt;--&gt; &lt;!-- 后续如何找到这个标签中的SQL语句呢？ namespace.id = 这个SQL语句的坐标 id: 指这个SQL语句的位置，每一个标签的id不能重复 resultType：结果的类型 --&gt; &lt;select id=&quot;selectAccountById&quot; resultType=&quot;com.cskaoyan.bean.Account&quot;&gt; select * from account where id = #&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;selectAccountList&quot; resultType=&quot;com.cskaoyan.bean.Account&quot;&gt; select * from account &lt;/select&gt;&lt;/mapper&gt; Mybatis的动态代理功能可以根据Mapper配置文件和由用户制定的Mapper接口，自动生成接口的代理对象，但是对Mapper接口有如下要求： 接口的全限定名需与Mapper.xml下的标签中的值保持一致。 接口的方法要与Mapper.xml下的 标签 一一对应，并且方法名要和标签的id值保持一致。 方法的返回类型必须与标签中的resultType保持一致。 接口文件名和配置文件名需保持一致，且配置文件在resources文件夹下的相对路径要与接口文件在java文件夹下的相对路径一致。 Mybatis的使用样例如下。 1234567891011121314151617181920212223public static void main(String[] args) throws IOException &#123; // 目的：要去执行sql语句 // 1. 读取配置文件 InputStream stream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); // 2. 获取SqlSessionFactory SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(stream); // 3. 执行SQL语句,其中true表示自动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(true); // 获取代理对象 StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); // 找到对应给的SQL语句，并且执行 String name = studentMapper.selectNameById(1); System.out.println(name);&#125; 输入映射在Mapper接口中的参数需要映射至Mapper配置文件中，需要遵守一些规则。 传入的参数在Mapper中需要使用#&#123;XXX&#125;来取值。 如果在Mapper接口中对参数进行了@Param注解修饰别名，那么在Mapper配置文件中必须使用该别名。 如果Mapper接口中传入的是对象，那么在Mapper配置文件中必须使用#&#123;成员变量名&#125;来取值。如果对象有注解，可以通过#&#123;注解值.成员变量名&#125;来取值。 传值时可以使用#{}和${}两种不同的传值方式，其中#{}表示是预编译占位，${}表示是字符串拼接。一般而言，我们都使用#{}传值，但是如果我们需要对SQL语句传入表名和列名时，则需要使用${}。 输出映射在Mapper配置文件中执行SQL语句后的结果会转换为一个Java对象，转换时也需要遵守一些规则。 映射的类型由Mapper配置文件中SQL语句标签里的resultType或resultMap指定，且Mapper接口中的返回类型要与其一致。 如果返回有多个值，在Mapper接口中需定义数组或集合，但是resultType只需要指定单个元素的类型即可。 如果返回的有多个列，那么需要在java文件中定义一个JavaBean对象来作为返回类型。此时Mybatis会把对象中的成员变量名和查询结果的列名一一映射，如果原始表中的列名与成员变量名不一致，可以通过@Param取别名，或者是resultMap来解决。在声明JavaBean对象的成员变量时，尽量使用包装类型，方便寻找错误。 resultMap一般用于对SQL的查询结果进行再次映射，一般用于修改原始表列名和多表查询。resultMap的使用样例如下。 12345678910111213141516171819&lt;resultMap id=&quot;studentMap&quot; type=&quot;com.cskaoyan.bean.Student&quot;&gt; &lt;!-- id:映射主键值的标签 column: 列名 property: 成员变量名 result: 映射普通列的 --&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectStudentByIdWithResultMap&quot; resultMap=&quot;studentMap&quot;&gt; select id,name,age,gender from student where id = #&#123;id&#125;&lt;/select&gt; 动态SQLMybatis可以根据传入的条件，动态的改变SQL语句。 ：可以自动拼接where关键字，并去除相邻的and或or关键字；如果where中没有SQL片段需要拼接，不会拼接where关键字。 ：可以判断传入的参数是否符合条件。需要注意的是，判断中的大于号和小于号为了避免与xml文件中的标签符号冲突，需要写为&amp;gt;和&amp;lt;。 和：可以提取公共的SQL语句，负责引入中的内容。为了保证SQL语句的可读性，并不会滥用这两个标签，它们一般用于提取列名。 ：可以自动拼接set关键字，并去除标签中的最后一个,。 ：可以在SQL中循环取值。一般用于in查询。例子如下。 Mapper.java 12// in 查询List&lt;User&gt; selectUserListByIds(List&lt;Integer&gt; ids); Mapper.xml 123456789&lt;select id=&quot;selectUserListByIds&quot; resultType=&quot;com.cskaoyan.bean.User&quot;&gt; &lt;!-- select * from user where id in (?,?,?,?,?,?,?)--&gt; select &lt;include refid=&quot;all_column&quot;/&gt; from user where id in &lt;foreach collection=&quot;collection&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/select&gt; : 可以在执行目标SQL语句之前或之后执行一条额外的SQL语句。例子如下。 1234567891011&lt;insert id=&quot;insertUserWithReturnId&quot;&gt; insert into user values (null,#&#123;user.name&#125;,#&#123;user.age&#125;,#&#123;user.nickname&#125;)&lt;!--order: 表示在目标SQL执行之前或者是之后执行 AFTER | BEFOREkeyProperty： 表示执行的结果映射到哪个参数中resultType: SQL语句返回的类型--&gt;&lt;selectKey order=&quot;AFTER&quot; keyProperty=&quot;user.id&quot; resultType=&quot;int&quot;&gt; select LAST_INSERT_ID()&lt;/selectKey&gt;&lt;/insert&gt; useGeneratedKeys：仅在insert语句中使用，可以获取插入数据的自增主键。（注意：此时对应的接口返回值仍然是影响行数，id值则是被放在传入的keyProperty中，上面的同理）例子如下。 123456789&lt;!--开启配置：useGeneratedKeys=&quot;true&quot; 映射到对应的参数中：keyProperty=&quot;user.id&quot;--&gt;&lt;insert id=&quot;insertUserWithReturnIdUseGeneratedKeys&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;user.id&quot;&gt; insert into user values (null,#&#123;user.name&#125;,#&#123;user.age&#125;,#&#123;user.nickname&#125;)&lt;/insert&gt; 多表查询多表查询的方式分为分次查询和连接查询。 首先在建立JavaBean对象时，需要在直接查询的A表所映射的对象中放入B表所映射的对象的成员变量。 分次查询：在Mybatis中，一个SQL语句标签只能执行一句SQL语句，分次查询即是使用resultMap来连接两个SQL语句，用一个SQL语句的结果作为另一个SQL语句的传入值。 分次查询的样例如下。 1234567891011121314151617181920212223242526272829303132&lt;!-- 分次查询 --&gt;&lt;select id=&quot;selectUserByName&quot; resultMap=&quot;userMap&quot;&gt; select id,username,nickname,gender,age from user where username = #&#123;name&#125;&lt;/select&gt;&lt;resultMap id=&quot;userMap&quot; type=&quot;com.cskaoyan.bean.User&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;nickname&quot; property=&quot;nickname&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;!-- association：关联单个bean的时候，使用 property：成员变量的名字 javaType: 成员变量的类型 select：关联的第二次查询的SQL语句的坐标，第二次查询和第一次查询在同一个文件中的时候，namespace可以省略 column: 给第二次查询传递的值的列名 --&gt; &lt;association property=&quot;userDetail&quot; javaType=&quot;com.cskaoyan.bean.UserDetail&quot; select=&quot;com.cskaoyan.mapper.UserDetailMapper.selectUserDetailById&quot; column=&quot;id&quot;/&gt; &lt;!-- 第二次查询 --&gt; &lt;select id=&quot;selectUserDetailById&quot; resultType=&quot;com.cskaoyan.bean.UserDetail&quot;&gt; select id,user_id as userId,height,weight,pic from user_detail where user_id = #&#123;id&#125; &lt;/select&gt; 连接查询：连接查询即是利用inner join和resultMap来连接表。 连接查询的样例如下。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- 连接查询 --&gt;&lt;select id=&quot;selectUserByNameUseCrossQuery&quot; resultMap=&quot;userCrossMap&quot;&gt; SELECT user.id, user.username, user.nickname, user.gender, user.age, user_detail.id as uid, user_detail.user_id as userId, user_detail.weight as weight, user_detail.height as height, user_detail.pic as pic FROM user left JOIN user_detail ON user.id = user_detail.user_id WHERE user.username = #&#123;name&#125;&lt;/select&gt;&lt;resultMap id=&quot;userCrossMap&quot; type=&quot;com.cskaoyan.bean.User&quot;&gt; &lt;!-- 映射 user--&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;nickname&quot; property=&quot;nickname&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;!-- 映射userDetail--&gt; &lt;association property=&quot;userDetail&quot; javaType=&quot;com.cskaoyan.bean.UserDetail&quot;&gt; &lt;id column=&quot;uid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;userId&quot; property=&quot;userId&quot;/&gt; &lt;result column=&quot;weight&quot; property=&quot;weight&quot;/&gt; &lt;result column=&quot;height&quot; property=&quot;height&quot;/&gt; &lt;result column=&quot;pic&quot; property=&quot;pic&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; 懒加载和缓存懒加载是指在Mybatis进行分次查询的时候，假如第二次查询的内容没有被使用到的话，那么就不去执行第二次查询的SQL语句，等到用到第二次查询的内容的时候再去执行第二条SQL语句。 Mybatis的默认配置是关闭懒加载，要开启懒加载需要在Mybatis的配置文件中加入如下配置。 123456&lt;settings&gt; &lt;!-- 懒加载 true: 表示开启 false:默认值，表示关闭 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 缓存是指在Mybatis中，单独开辟一块内存空间（map），来存储查询的信息。后续假如再次调用了到了同样的查询，那么就直接查询缓存。 缓存分为一级缓存和二级缓存。 一级缓存是一个SqlSession级别的缓存。缓存的内容存储在SQLSession中。一级缓存是默认开启的，且无法关闭，只有在SqlSession关闭时，或者SqlSession调用commit方法会让一级缓存失效。 二级缓存是一个NameSpace级别的缓存，每一个NameSpace都有自己的缓存空间。二级缓存是默认开启的。 在实际工作中，Mybatis的缓存机制并不好用，主要是它无法解决脏数据的问题，且用户不能直接操作缓存，所以在实际工作中会使用Redis替代。"},{"title":"学习总结（2022.05.10-2022.05.16）","path":"2022/05/16/学习总结（2022-05-10-2022-05-16）/","text":"关系型数据库与非关系型数据库关系型数据库：不仅存储数据，也存储数据与数据间的关系。一般存储在磁盘上，读取较慢。 非关系型数据库：仅仅用于存储数据，不能存储数据间的关系。但是一般存储在内存中，读取较快。 SQL语句库的操作 123456create database dbName;# 添加库drop database dbName;# 删除库alter database dbName character set utf8 collate utf8_bin;# 修改库的字符集和校对规则(不能修改名字)show databases;# 查询所有的库show create database dbName;# 查询对应库的建库语句use dbName;# 选中库(重要) 表的操作 123456789101112131415create table tableName( columnName1 dataType, columnName2 dataType, ... ) character set utf8 collate utf8_bin;# 创建表(后面为设置表的字符集和校对规则)drop table tableName;# 删除表rename table tableName to newTableName;# 修改表名alter table tableName character set latin1 collate latin1_bin;# 修改表的字符集和校对规则alter table tableName add columnName dataType;# 添加列(列名后跟列的数据类型)alter table tableName drop columnName;# 删除列alter table tableName modify columnName dataType;# 修改列的类型alter table tableName change columnName newColumnName dataType;# 修改列的类型和名字show tables;# 查询所有表describe tableName;# 查询表结构show create table tableName;# 查询建表语句 数据的操作 123456789insert into tableName values (...), (...), ...;# 插入数据delete from tableName columnName = ...;# 删除数据update tableName set columnName = ... where columnName = ...;# 修改数据select * from tableName;# 查找所有数据select columnName from tableName;# 查找该列数据 关键字： where：寻找符合条件的指定数据行。 distinct：过滤结果相同的记录。 limit：限制显示的行数。 as：别名，对查询结果的列和表起名。 order by：排序。可接desc表示降序。 group by：分组。可接having对分组后的结果进行过滤。 聚合函数： max：最大值 min：最小值 avg：平均值 sum：总和 count：计数 SQL语句执行顺序 1234567(5) SELECT column_name, ... (1) FROM table_name, ... (2) [WHERE ...] (3) [GROUP BY ...] (4) [HAVING ...] (6) [ORDER BY ...](7) [Limit ...] 数据完整性实体完整性：确定表中数据是唯一且不重复的，确保用户不会输入重复的数据，实现的关键是主键。主键是一行数据中唯一不允许重复和值为null的字段。主键一般可以自增。在建表时可以声明一个字段为主键。 123create table tableName( columnName dataType PRIMARY KEY auto_increment# 声明为主键且自增) auto_increment=1000# 设置自增的起始数 域完整性：每一个字段都应该有类型以约束值。也可以使用unique（值唯一）和not null（值不为空）来约束值。unique修饰的字段可以为空。 参照完整性：一个表如果存在外键，那么这个外键应该与另一个表的主键相对应。外键使用foreign key来声明。 三大范式第一范式：每一列应该保持原子性。原子性表示表中的数据都是一个不可拆分的最小单元。 第二范式：数据应该有唯一性。唯一性表示每一条数据都有唯一的标识，如主键。 第三范式：数据不应该冗余。 多表查询内连接inner join 12select * from user inner join user_detail on user.id = user_detail.user_id; 外连接outer join 外连接分为左连接和右连接，使用左连接时会保留左表数据，右连接反之。 12select * from user left outer join user_detail on user.id = user_detail.user_id; 嵌套查询 一个SQL语句的结果可以作为另一个SQL语句的条件。 12select * from student where clazz_id = (select id from clazz where name = &#x27;一班&#x27;); JDBCJDBC是java的一套连接数据库的标准接口。但JDBC只提供接口，具体的实现(如何连接数据库)由数据库厂家的驱动实现，如MySQL的mysql-connector。 JDBC的使用如下。 123456789101112131415161718192021222324252627282930313233343536373839// 1.加载驱动 DriverManager.registerDriver(new Driver());// String url = &quot;协议 + ip + 端口 + 路径 + 参数&quot;; String url = &quot;jdbc:mysql://localhost:3306/40th?useSSL=false&amp;characterEncoding=utf8&quot;; String username = &quot;root&quot;; String password = &quot;123456&quot;; // 2.发送用户名和密码，建立连接 // 返回的当前是一个Connection接口，但是实际上在运行的时候，返回是Connection接口的实现类的实例 Connection connection = DriverManager.getConnection(url, username, password); // 3.获取statement对象 Statement statement = connection.createStatement(); // 4.发送SQL语句// 增删改使用executeUpdate方法 int affectedRows = statement.executeUpdate(&quot;insert into stu values (4,&#x27;云飞兄&#x27;,20,&#x27;358班&#x27;)&quot;);// 查使用executeQuery方法ResultSet resultSet = statement.executeQuery(&quot;select * from stu&quot;); // 5.解析结果集 System.out.println(&quot;affectedRows:&quot; + affectedRows);while (resultSet.next()) &#123; int id = resultSet.getInt(&quot;id&quot;); String name = resultSet.getString(&quot;name&quot;); int age = resultSet.getInt(&quot;age&quot;); String className = resultSet.getString(&quot;class&quot;); System.out.println(&quot;id:&quot; + id); System.out.println(&quot;name:&quot; + name); System.out.println(&quot;age:&quot; + age); System.out.println(&quot;className:&quot; + className);&#125; // 6.断开连接resultSet.close(); statement.close(); connection.close(); 数据库注入在使用Statement时，如果输入的SQL语句是字符串拼接而成的，那么用户就可能输入一些包含SQL关键字的字符，这样就可能改变SQL语句的格式，引发安全性的问题。 解决方式是使用PreparedStatement(预编译的Statement)。 1234567891011// 在创建PreparedStatement的时候，PreparedStatement会把当前这个没有参数的SQL语句，发送给MySQL服务器，执行预编译// 预编译：其实就是去解析这个SQL语句中的关键字，变成MySQL可以执行的命令// 在预编译之后，后续输入的字符串，就只会被MySQL当成纯文本来解析PreparedStatement preparedStatement = connection.prepareStatement(&quot;select * from user where name = ? and password = ?&quot;);// 设置参数preparedStatement.setString(1,username);preparedStatement.setString(2,password);// 传递参数，执行SQL语句ResultSet resultSet = preparedStatement.executeQuery(); 在安全性上，PreparedStatement要比Statement安全；在效率上，因为PreparedStatement需要与数据库通信两次，一次传输预编译的SQL语句，一次传输参数，所以相比于只通信一次的Statement要慢一些。 批处理对SQL语句有三种批处理的方式： for循环插入 12345678910111213// for循环public static void batchUseForEach() throws SQLException &#123; Statement statement = connection.createStatement(); for (int i = 0; i &lt; 10000; i++) &#123; String sql = &quot;insert into user values (&quot;+i+&quot;,&#x27;foreach&#x27;,null,null)&quot;; statement.executeUpdate(sql); &#125;&#125; statement批处理 12345678910111213// Statement处理public static void batchUseStatement() throws SQLException &#123; Statement statement = connection.createStatement(); for (int i = 10000; i &lt; 20000; i++) &#123; String sql = &quot;insert into user values (&quot;+i+&quot;,&#x27;batchUseStatement&#x27;,null,null)&quot;; statement.addBatch(sql); &#125; // 发送SQL语句，执行 statement.executeBatch();&#125; PreparedStatement批处理 需要在数据库的url后面加上配置rewriteBatchedStatements=true ，表示开启批处理。 12345678910111213141516// PreparedStatement处理public static void batchUsePrepapreStatement() throws SQLException &#123; // 获取PreparedStatement PreparedStatement preparedStatement = connection.prepareStatement(&quot;insert into user values (?,?,null,null)&quot;); // 循环，设置参数 for (int i = 20000; i &lt; 30000; i++) &#123; preparedStatement.setInt(1,i); preparedStatement.setString(2,&quot;PrepapreStatement&quot;); preparedStatement.addBatch(); &#125; // 把参数发送给MySQL服务器，执行SQL语句 preparedStatement.executeBatch();&#125; 由代码可知，三种方式与SQL服务器的通信次数、SQL语句的编译次数和执行次数如下表。 通信次数 编译次数 执行次数 时间 for循环 n n n 最长 Statement 1 n n 次之 PreparedStatement 2 1 1 最短 然而通过实际测试发现在数据较大（&gt;&#x3D; 1000000）的情况下statement批处理的时间要长于for循环，可能原因是操作系统对内存的分配：在for循环中，每一次循环时操作系统不必去一直维护内存，在一次循环结束后可以将内存释放；而statement批处理时操作系统需要维护内存去记录sql语句，这导致了statement批处理的时间变长。 事务事务是指组成事务的一组操作，这些操作要么一起操作成功，要么一起操作不成功。 事务具有四个特性： 原子性。事务是一个不可分割的操作单元，里面的一组操作要么都成功，要么都不成功。 一致性。事务必须使数据库从一个一致性状态到另一个一致性状态（比如无论怎么转账，所有账户的总金额应该不变）。 隔离性。事务与事务间应该互相隔离，互不影响。 持久性。一个事务一旦生效，对数据库的改变是永久的，即事务提交以后就无法回滚。 针对事务的隔离性，提出了事务的四个隔离级别： 读未提交 读已提交 可重复读 串行化 在这些隔离级别中，会出现如下三个隔离问题： 脏读。即一个事务读取到了另一个事务还未提交的数据。 不可重复读，即在同一个事务中读取同一个数据，前后读取的数据不一致。一般是一个事务读取到了另一个事务修改的数据。 虚幻读，即在同一个事务中读取同一个数据，前后读取的数据不一致。一般是一个事务读取到了另一个事务插入或删除的数据。 四个隔离级别在处理三个隔离问题的能力如下 脏读 不可重复读 虚幻读 读未提交（read uncommitted） √ √ √ 读已提交（read committed） X √ √ 可重复读（repeatable read） X X √ 串行化（serializable） X X X 在MySQL中，默认的隔离级别是可重复读。MySQL通过自身解决了部分虚幻读的问题，但并没有完全解决。 串行化虽然安全级别最高，但是此时数据库完全丧失了多线程的能力，在一个事务操作期间，其他事务都会变成阻塞状态，数据库的效率会因此下降。 在JDBC中，开启事务的API如下。 12345678// 开启事务connection.setAutoCommit(false);// 提交事务connection.commit();// 回滚事务connection.rollback(); DatasourceDatasource具体指的是数据库连接池。数据库连接池是利用池化的思想，把数据库连接存放在池中，在我们需要连接时，从池里获取连接；用完之后再放回池中，这样就避免了反复创建、销毁连接，提高程序的效率。 目前使用的第三方数据库连接池有三个：DBCP、c3p0、Druid。 DBCP：需要使用properties配置文件配置。 123456username=rootpassword=123456url=jdbc:mysql://localhost:3306/40thdriverClassName=com.mysql.jdbc.DriverconnectionProperties=useSSL=false;characterEncoding=utf8initialSize=10 1234567// 加载配置文件Properties properties = new Properties();properties.load(new FileInputStream(&quot;dbcp.properties&quot;));// 获取连接DataSource dataSource = BasicDataSourceFactory.createDataSource(properties);Connection connection = dataSource.getConnection(); c3p0：需要使用xml文件配置。 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 在xml文件中，有一些特殊字符会有歧义，会报错，这些字符需要写转义字符 &amp; &gt; &lt; 转义字符 &amp; &amp;amp; &lt; &amp;lt; &gt; &amp;gt; --&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/40th?useSSL=false&amp;amp;characterEncoding=utf8&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxStatements&quot;&gt;200&lt;/property&gt; &lt;/default-config&gt;&lt;/c3p0-config&gt; 使用方式同DBCP，只是dataSource改为c3p0的。 1dataSource = new ComboPooledDataSource(); Druid：需要使用properties配置文件配置。 1234username=rootpassword=123456url=jdbc:mysql://localhost:3306/40th?useSSL=false&amp;characterEncoding=utf8driverClassName=com.mysql.jdbc.Driver 使用方式同DBCP，只是dataSource改为Druid的。 1dataSource = DruidDataSourceFactory.createDataSource(properties); DBUtilsDBUtils是一个可以帮助提高JDBC开发效率的框架。主要使用下面三个类。 DBUtils：可以关闭连接、提交事务等。 1234567891011// 关闭连接public static void close(Connection conn) throws SQLException;// 关闭ResultSetpublic static void close(ResultSet rs) throws SQLException;// 关闭statementpublic static void close(Statement stmt) throws SQLException;// 提交并且关闭public static void commitAndClose(Connection conn) throws SQLException; QueryRunner：可以执行SQL语句并获取结果集。 12345678// 构造无参的queryRunnerQueryRunner queryRunner = new QueryRunner();// 构造QueryRunnerDataSource dataSource = DruidUtils.getDataSource();QueryRunner queryRunner = new QueryRunner(dataSource);// 获取增删改影响的行数int affectedRows = queryRunner.update(&quot;update stu set name = ? where id = ?&quot;, &quot;嘉靖皇帝&quot;, 4); ResultSetHandler：可以帮助解析结果集，但本身是接口，实际用的是以下的具体实现。 // BeanHandler，把结果集中的第一行数据转化为一个JavaBean Stu stu = queryRunner.query(&quot;select id,name,age,class as clazz from stu where id = ?&quot;,new BeanHandler&lt;&gt;(Stu.class),2); // BeanListHandler，把结果集对象解析为一个 BeanList List&lt;Stu&gt; stuList = queryRunner.query(&quot;select id,name,age,class as clazz from stu&quot;,new BeanListHandler&lt;&gt;(Stu.class)); // MapHandler，把结果集中的第一行记录解析为一个Map Map&lt;String, Object&gt; map = queryRunner.query(&quot;select * from stu&quot;, new MapHandler()); // MapListHandler，把结果集中的记录 映射到一个 List&lt;map&lt;String,Object&gt;&gt; 对象中 List&lt;Map&lt;String, Object&gt;&gt; mapList = queryRunner.query(&quot;select * from stu&quot;, new MapListHandler()); // ColumnListHandler，用来接收单列值的解析结果。 List&lt;Object&gt; list = queryRunner.query(&quot;select name from student&quot;, new ColumnListHandler&lt;&gt;()); // ScalarHandler，用来处理查询结果是单个值的情况。 Long count = queryRunner.query(&quot;select count(*) from student&quot;, new ScalarHandler&lt;Long&gt;());"},{"title":"学习总结（2022.05.01-2022.05.09）","path":"2022/05/10/学习总结（2022-05-01-2022-05-09）/","text":"HTMLHTML是一个用标签描述的文本语言。 HTML初始格式为： 12345678910&lt;!DOCTYPE html&gt; 语法声明: 声明使用HTML5语法&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; meta: 描述网页的元信息 &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; 重要标签（了解即可）： 123456789101112&lt;hr&gt; : 横线标签, 单标签&lt;br&gt; : 换行标签, 单标签&lt;h1&gt;&lt;h2&gt;&lt;h3&gt;&lt;h4&gt;&lt;h5&gt;&lt;h6&gt; : 标题标签, 双标签&lt;div&gt; : 分区或者节给一个页面, 双标签&lt;p&gt; : 段落标签, 双标签&lt;a&gt; : 超链接标签, 双标签&lt;img&gt; : 图片标签, 单标签&lt;ol&gt;: 有序列表, 和&lt;li&gt;标签共同构成一套标签&lt;ul&gt;: 无序列表, 和&lt;li&gt;标签共同构成一套标签&lt;table&gt;: 表格标签, 定义一个表格 (和tr, td, th ...构成成套标签) &lt;tr&gt; : 一个表格中的一行 &lt;td&gt; : 一行中的一个单元格 表单元素：表单元素会根据元素内的内容生成一个url，对后端发起请求，并根据请求获得内容。生成的url中分为非参数部分和参数部分，例子如下： 12https://s.taobao.com/search?q=鞋子 非参数 | 参数 非参数部分由表单元素的action属性提供，参数则由表单元素的其他属性提供。 表单元素中有一个method属性，它决定了表单元素在提交表单时使用的HTTP方法：GET&#x2F;POST。GET一般用于获取数据，POST一般用于提交数据；GET请求一般把请求参数直接拼接在url之后，POST请求一般把参数放在传输的正文中；GET请求不安全（可以被用户直接观察到），POST请求安全。 表单元素根据自身的name属性和value属性生成一个键值对数据，通过传输该数据完成与后端的交互。 常见表单元素： 123&lt;input&gt; : 单标签, 表示一个输入框&lt;textarea&gt; : 多行文本, 相当于一个可以输入多行内容的input&lt;select&gt; : 下拉选择, 和&lt;option&gt; 是一套标签 CSSCSS主要用于对HTML的文本、图片和版面的布局等显示样式。 CSS通过选择器将HTML代码和CSS代码关联。选择器的类型有标签选择器&#x2F;类选择器&#x2F;id选择器。 12345678910111213141516171819202122&lt;style&gt; /* 标签选择器 */ div&#123; width: 100px; height: 100px; background: red; &#125; /* 类选择器 */ .div1&#123; width: 100px; height: 100px; background: red; color: white; font-size: 30px; &#125; /* id选择器 */ #div2&#123; width: 100px; height: 100px; background: #c9ffe3; &#125;&lt;/style&gt; 选择器的优先级是id选择器 &gt; 类选择器 &gt; 标签选择器。如果存在两个同优先级选择器，优先选择较近的选择器（本质是HTML的解析模式为从上到下解析）。 盒子模型：一个HTML标签在页面上占据的空间。这个空间分为四个结构：元素内容区域、内边距区域(padding)、边框区域(border)、外边距区域(margin)。盒子模型的作用是使布局模块化，方便整个布局和个体布局的设计。根据盒子模型种类的不同，可以将标签元素分为三种： 块级元素：独占一行，从上到下排布；可以直接控制宽高&#x2F;内外边距，一般用于大布局的搭建。如：div、p、form、table 行级元素：不独占一行，与其他行级元素从左到右一行显示；只能控制内外边距，宽高受本身内容大小控制；一般用于小结构的搭建。如：span、a、br 行内块：本质属于行级元素，但是可以设置宽高。如：input、img、select JavaScriptJS是一种轻量级、弱类型的语言，主要用于在HTML中添加交互行为。 JS的引入方式有两种。一种是直接在HTML中的script标签内部引入，一种是在script标签的src属性中导入外部的JS文件。 类型：统一用var声明，数据类型由赋值类型决定。数据类型一般有：Number，String，Array 函数：使用function声明。 DOMDOM全称为文档对象模型，是一种将HTML文档视为树结构的理论，这种树结构也被称为DOM树。 DOM树的节点拥有层级关系，从顶端的文档节点开始，依次往下是： 由HTML元素构成的元素节点 HTML属性构成的属性节点 HTML元素内文本构成的文本节点 根据DOM理论，可以知道一个HTML文件的加载顺序： 解析HTML结构，构建DOM树 加载外部脚本(JS)和样式表文件(CSS) 解析并执行脚本代码 构造DOM模型，完成后根据DOM树显示页面。 JS中与DOM相关的操作有： 获取节点： document.getElementById()document.getElementsByName()document.getElementsByTagName() 添加节点： document.appendChild() 删除节点： document.removeChild() 替换节点： document.replaceChild()"},{"title":"Hexo美化记录","path":"2022/05/04/Hexo美化记录/","text":"一些Hexo美化技术分享 live 2D在git中输入$ npm install --save hexo-helper-live2d安装live 2D插件。 在_config.yml文件下添加如下配置 1234567891011live2d: enable: true scriptFrom: local model: use: live2d-widget-model-haruto #模型选择，与文件包同名 display: position: right #模型位置 width: 150 #模型宽度 height: 300 #模型高度 mobile: show: false #是否在手机端显示 再次在git中输入npm install packagename，packagename为https://github.com/xiazeyu/live2d-widget-models下的live 2D文件包。 动态背景在主题文件夹下的layout\\layout.ejs中加入如下代码 1234&lt;!--动态线条背景--&gt;&lt;script type=&quot;text/javascript&quot;color=&quot;220,220,220&quot; opacity=&#x27;0.7&#x27; zIndex=&quot;-2&quot; count=&quot;200&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt; 注意一定要放在&lt;body&gt;中。 网页标题优化在主题文件夹下的source\\js中新建一个FunnyTitle.js 文件，在里面填写如下代码： 12345678910111213141516var OriginTitle = document.title;var titleTime;document.addEventListener(&#x27;visibilitychange&#x27;, function () &#123; if (document.hidden) &#123; $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/img/trhx2.png&quot;); document.title = &#x27;ヽ(●-`Д´-)ノ你丑你就走！&#x27;; clearTimeout(titleTime); &#125; else &#123; $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/img/trhx2.png&quot;); document.title = &#x27;ヾ(Ő∀Ő3)ノ你帅就回来！&#x27; + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125;&#125;); 在主题文件夹下的layout\\layout.ejs中加入如下代码： 12&lt;!--浏览器搞笑标题--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;\\js\\FunnyTitle.js&quot;&gt;&lt;/script&gt; 更多美化可以访问该知乎文章：https://zhuanlan.zhihu.com/p/69211731"},{"title":"学习总结（2022.04.25-2022.04.30）","path":"2022/04/30/学习总结（2022-04-25-2022-04-30）/","text":"数组和链表数组添加的时间复杂度: o(n) 数组删除的时间复杂度: o(n) 数组按下标查找的时间复杂度: o(1) 无序数组按值查找的时间复杂度: o(n) 有序数组按值查找的时间复杂度: o(logn) 链表的添加时间复杂度: o(1) 链表的删除时间复杂度: o(1) 链表的查找时间复杂度: o(n) 泛型泛型，就是参数化类型，在不确定传入的类型时，可以先设置一个参数来代指（类似于形参）。 基本语法如下： 123class 类名&lt;泛型类型1,…&gt;interface 接口名&lt;泛型类型1…&gt;public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 .) 可以定义多个泛型，但是最好不超过两个，如果需要两个以上的泛型，说明设计有问题。 在泛型类上定义的泛型，作用域仅在类名和类体内，即使是子类也不能继承。 泛型通配：？为泛型通配符，没有明确，就是Object以及任意类；？ extends E为向下限定，只能是E及其子类；？ super E为向上限定，只能是E及其父类。 泛型擦除：java中的泛型并不是真正的泛型，在编译之后，泛型会变成Object以及类型强转，泛型只是防止程序员对类型的随意转换。 红黑树红黑树是一个特殊的二叉搜索树，每个节点有红色和黑色两种颜色。 其中根节点和叶子（nil，叶子节点下的空节点）必须是黑色；父子节点不能都是红色节点；从叶子到根节点的路径上，黑色节点的数目是一样的。（黑高平衡） 红黑树通过旋转（类似于二叉搜索树）和分裂（类似于B树，向上和向下）保证黑高平衡和无连续红色节点。 集合类CollectionCollection是Collection集合体系的顶级接口，定义为一个数据容器。 Collection的子实现一些存储元素有序，一些存储元素无序；一些允许存储重复元素，一些不允许存储重复元素；一些允许存储null，一些不允许存储null。 API： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ------------------------------增删改查相关的api------------------------------// boolean add(E e)// 确保此 collection 包含指定的元素（可选操作）。// boolean addAll(Collection&lt;? extends E&gt; c)// 将指定 collection 中的所有元素都添加到此 collection 中（可选操作）。// boolean contains(Object o)// 如果此 collection 包含指定的元素，则返回 true。// boolean containsAll(Collection&lt;?&gt; c)// 如果此 collection 包含指定 collection 中的所有元素，则返回 true。 // boolean remove(Object o)// 从此 collection 中移除指定元素的单个实例，如果存在的话（可选操作）。// boolean removeAll(Collection&lt;?&gt; c)// 移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）。// boolean retainAll(Collection&lt;?&gt; c)// 仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）。 // ---------------------------------------集合类都具有的辅助方法----------------- // void clear()// 移除此 collection 中的所有元素（可选操作）。// boolean equals(Object o)// 比较此 collection 与指定对象是否相等。// int hashCode()// 返回此 collection 的哈希码值。// boolean isEmpty()// 如果此 collection 不包含元素，则返回 true。// int size()// 返回此 collection 中的元素数。 // ------------------------------------------特殊方法--------------------------// Object[] toArray()// 返回包含此 collection 中所有元素的数组。 // &lt;T&gt; T[] toArray(T[] a)// 返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同。// 只有数组类型与存储的数据类型相匹配，才能正常运行；如果传入的数组够长，那么返回的数组和传入的数组是一个数组，反之则不是；如果传入的数组过长，那么空位位置会置为null。// Iterator&lt;E&gt; iterator()// 返回在此 collection 的元素上进行迭代的迭代器。// Iterator类型的方法：// hasNext(): 向后还有没有元素可以遍历// next(): 向后遍历// remove(): 删除刚刚遍历过的元素; // 注意：java中的增强for循环就是由iterator方法实现的（数组不一样，数组的增强for循环在编译中是变成普通的fori循环） 并发修改异常：collection的一些子实现是线程不安全的，在使用Iterator遍历时会产生线程安全问题。所以一些子实现会维护一个标记，记录修改次数，每次修改次数都会增加。 Iterator对象遍历前，都会检查修改次数是否与原集合类一致，如果不一致，就会认为数据被其他线程修改，从而抛出并发修改异常。 但是即使在单线程情况下，如果在遍历过程中直接使用集合类的修改方法，也会抛出并发修改异常。所以在Iterator对象遍历时不要修改数据。 ListList是Collection的子接口，描述的数据结构是线性表。 List有序，允许存储重复元素，允许存储null。 API： 12345678910111213141516171819202122232425262728293031// void add(int index, E element)// 在列表的指定位置插入指定元素（可选操作）。 // boolean addAll(int index, Collection&lt;? extends E&gt; c)// 将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作）。 // E get(int index)// 返回列表中指定位置的元素。 // int indexOf(Object o)// 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。 // int lastIndexOf(Object o)// 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。// E remove(int index)// 移除列表中指定位置的元素（可选操作）。 // E set(int index, E element)// 用指定元素替换列表中指定位置的元素（可选操作）。// ListIterator&lt;E&gt; listIterator()// 返回此列表元素的列表迭代器（按适当顺序）。// ListIterator&lt;E&gt; listIterator(int index)// 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。// ListIterator类型的方法：// hasNext(): 向后还有没有元素可以遍历// next(): 向后遍历// remove(): 删除刚刚遍历过的元素; // hasPrevious(): 向前是否可以遍历// previous(): 向前遍历// List&lt;E&gt; subList(int fromIndex, int toIndex)// 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图。// subList并不是从源集合类中复制了数据，而是维护了一些标记指向源数据，在subList上操作，本质还是在操作源数据。// 所以不建议在使用subList中修改源数据，可能抛出并发修改异常。 ArrayListArrayList是List的子实现，描述的数据结构是线性表。 其底层结构是数组，数组默认长度为10，扩容倍数为1.5倍。 ArrayList存储结构有序，允许存储重复元素，允许存储null。 ArrayList线程不安全。 构造方法： 123456// ArrayList() // 构造一个初始容量为 10 的空列表。 // ArrayList(Collection&lt;? extends E&gt; c) // 构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。 // ArrayList(int initialCapacity) // 构造一个具有指定初始容量的空列表。 API： 123456// Object clone()// 返回此 ArrayList 实例的浅表副本。// void ensureCapacity(int minCapacity)// 如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。// void trimToSize()// 将此 ArrayList 实例的容量调整为列表的当前大小。 VectorVector是List的子类。描述的数据结构是线性表。 其底层结构是数组，数组默认长度为10，扩容倍数为2倍。 Vector存储结构有序，允许存储重复元素，允许存储null。 Vector线程安全。 LinkedListLinkedList是List的子实现，也是Deque的子实现。描述的数据结构是线性表&#x2F;队列&#x2F;双端队列&#x2F;栈 其底层是双向链表。 LinkedList存储结构有序，允许存储重复元素，允许存储null。 LinkedList线程不安全。 构造方法： 1234// LinkedList() // 构造一个空列表。 // LinkedList(Collection&lt;? extends E&gt; c) // 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。 API: 123456789101112131415161718192021222324252627// 队列API// boolean offer(E e)// 将指定元素添加到此列表的末尾（最后一个元素）。// E poll()// 获取并移除此列表的头（第一个元素）// E peek()// 获取但不移除此列表的头（第一个元素）。// 双端队列API// boolean offerFirst(E e)// 在此列表的开头插入指定的元素。// boolean offerLast(E e)// 在此列表末尾插入指定的元素。// E peekFirst()// 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。// E peekLast()// 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。// E pollFirst()// 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。// E pollLast()// 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。// 栈API// E pop()// 从此列表所表示的堆栈处弹出一个元素。// void push(E e)// 将元素推入此列表所表示的堆栈。 QueueQueue是Collection的子接口，描述的数据结构是队列。 Queue存储元素有序，允许存储重复元素，不允许存储null。（因为Queue的poll方法返回null表示队列无元素，为避免混淆，所以不允许存储null） API: 123456789101112// boolean offer(E e)// 在队列中添加数据// E peek()// 查看队头元素// E poll()// 出队头// boolean add(E e)// 添加数据// E element()// 查看头元素// E remove()// 删除头元素 DequeDeque是Queue接口的一个子接口，描述的数据结构是队列&#x2F;双端队列&#x2F;栈。 Deque存储元素有序，允许存储重复元素，不允许存储null。 ArrayDequeArrayDeque是Deque接口的子实现。描述的数据结构是队列&#x2F;双端队列&#x2F;栈。 其底层结构是循环数组，数组默认长度为16，扩容倍数为2倍。 ArrayDeque存储元素有序，允许存储重复元素，不允许存储null。 ArrayDeque线程不安全。 BlockingQueueBlockingQueue是Queue的一个子接口，描述的数据结构是阻塞队列。 阻塞队列：大小有限的队列，常用于线程池。队满时，添加线程等待；队空时，删除线程等待。 SetSet接口是Collection的一个子接口，描述的数据结构是集合。 Set的子实现一些有序，一些无序；都不允许存储重复元素；一些允许存储null，一些不允许存储null。 HashSetHashSet是Set接口的子实现。 其底层结构是HashMap，HashSet添加的对象其实是HashMap的key值。 HashSet存储元素无序；不允许存储重复元素；允许存储null。 HashSet线程不安全。 构造方法： 12345678// HashSet() // 构造一个新的空 set，其底层 HashMap 实例的默认初始容量是 16，加载因子是 0.75。 // HashSet(Collection&lt;? extends E&gt; c) // 构造一个包含指定 collection 中的元素的新 set。 // HashSet(int initialCapacity) // 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和默认的加载因子（0.75）。 // HashSet(int initialCapacity, float loadFactor) // 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和指定的加载因子。 LinkedHashSetLinkedHashSet是HashSet的子类. 其底层结构是LinkedHashMap。 LinkedHashSet存储元素有序；不允许存储重复元素；允许存储null。 LinkedHashSet线程不安全。 TreeSetTreeSet是Set接口的子实现。 其底层结构是TreeMap。 TreeSet存储元素有序；不允许存储重复元素；不允许存储null。 TreeSet线程不安全。 MapMap是Map集合体系的顶级接口，存储key-value数据。 Map的子实现一些存储元素有序，一些存储元素无序；都不允许存储重复数据；一些允许存储null，一些不允许存储null（仅仅指key） API： 123456789101112131415161718192021222324252627282930313233 // -----------------------增删改查的api-------------------------// V put(K key, V value)// 将指定的值与此映射中的指定键关联（可选操作）。// void putAll(Map&lt;? extends K,? extends V&gt; m)// 从指定映射中将所有映射关系复制到此映射中（可选操作）。// V remove(Object key)// 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。// V get(Object key)// 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。// boolean containsKey(Object key)// 如果此映射包含指定键的映射关系，则返回 true。// boolean containsValue(Object value)// 如果此映射将一个或多个键映射到指定值，则返回 true。 // -----------------------集合类都有的api-------------------------// void clear()// 从此映射中移除所有映射关系（可选操作）。// boolean equals(Object o)// 比较指定的对象与此映射是否相等。// int hashCode()// 返回此映射的哈希码值。// boolean isEmpty()// 如果此映射未包含键-值映射关系，则返回 true。 // int size()// 返回此映射中的键-值映射关系数。 // -----------------------视图方法-------------------------// Set&lt;K&gt; keySet()// 返回此映射中包含的键的 Set 视图。// Collection&lt;V&gt; values()// 返回此映射中包含的值的 Collection 视图。// Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()// 返回此映射中包含的映射关系的 Set 视图。 HashMapHashMap是Map接口的具体子实现，底层结构是数组+链表+红黑树。数组的默认初始容量为16，扩容机制为2倍，默认的加载因子为0.75。 （加载因子用来控制HashMap的饱和度，默认阈值为16 * 0.75 &#x3D; 12，如果超过12对键值对，HashMap扩容） HashMap存储元素无序；不允许存储重复的key；允许存储null作为key。 HashMap线程不安全。 HashMap中键值对的Hash值计算：(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); 如果一个新加入的key-value对，它的key值与已经存在的key值满足hash值相等，而且也满足值相等（&#x3D;&#x3D;或equals），说明key值重复，此时会将新value值覆盖掉旧value值，并将旧value值返回出来。 HashMap在某一链表长度大于8时进行以下其中一种操作：当数组长度小于64时，会扩容数组并进行再散列；当数组长度大于等于64时，则会将链表转化为红黑树。 HashMap在删除节点时，如果删除的是红黑树上的节点，且该节点是红黑树的根节点&#x2F;根节点的左右节点&#x2F;根节点的左节点的左节点，此时会认为红黑树上节点过少，从而使红黑树转化为链表；HashMap在扩容进行再散列时，红黑树会被拆分，如果拆分后红黑树中的节点小于6个，红黑树转化为链表。 构造方法： 12345678// HashMap() // 构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。 // HashMap(int initialCapacity) // 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。 // HashMap(int initialCapacity, float loadFactor) // 构造一个带指定初始容量和加载因子的空 HashMap。 // HashMap(Map&lt;? extends K,? extends V&gt; m) // 构造一个映射关系与指定 Map 相同的新 HashMap。 HashMap没有额外的API，基本继承了Map接口的API。 LinkedHashMapLinkedHashMap是HashMap的一个子类，基本上完全复用了HashMap的底层结构和方法。 LinkedHashMap额外维护了一个双向链表保证迭代顺序。 LinkedHashMap存储元素有序；不允许存储重复的key；允许存储null作为key。 LinkedHashMap线程不安全。 TreeMapTreeMap是Map接口的子实现，描述的数据结构是红黑树。 其底层结构是链表。 TreeMap存储的元素有序；不允许存储重复的key；不允许存储null作为key。 因为TreeMap底层的数据结构是红黑树，所以key值需要比较大小，此时有两种实现比较的方式：存储的key值自身可以实现自然排序；TreeMap提供比较器。 构造方法： 12345678// TreeMap() // 使用键的自然顺序构造一个新的、空的树映射。 // TreeMap(Comparator&lt;? super K&gt; comparator) // 构造一个新的、空的树映射，该映射根据给定比较器进行排序。 // TreeMap(Map&lt;? extends K,? extends V&gt; m) // 构造一个与给定映射具有相同映射关系的新的树映射，该映射根据其键的自然顺序 进行排序。 // TreeMap(SortedMap&lt;K,? extends V&gt; m) // 构造一个与指定有序映射具有相同映射关系和相同排序顺序的新的树映射。 API: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// ------------------------TreeMap定义大小操作相关的api------------------------// Map.Entry&lt;K,V&gt; ceilingEntry(K key)// 大于等于给定key的最小键值对// K ceilingKey(K key)// 大于等于给定key的最小key// Map.Entry&lt;K,V&gt; floorEntry(K key)// 小于等于key的最大的键值对// K floorKey(K key)// 小于等于key最大的key// Map.Entry&lt;K,V&gt; higherEntry(K key)// 大于给定key的最小键值对// K higherKey(K key)// 大于给定key的最小key// Map.Entry&lt;K,V&gt; lowerEntry(K key)// 小于key的最大的键值对// K lowerKey(K key)// 小于key最大的key// Map.Entry&lt;K,V&gt; firstEntry()// 返回最小的键值对// K firstKey()// 返回最小的key// Map.Entry&lt;K,V&gt; lastEntry()// 返回最大的键值对// K lastKey()// 返回最大的key// Map.Entry&lt;K,V&gt; pollFirstEntry()// 删除最小的键值对// Map.Entry&lt;K,V&gt; pollLastEntry()// 删除最大的键值对// ---------------------视图方法-----------------------------// NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)// 返回此映射的部分视图，其键的范围从 fromKey 到 toKey。// SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey)// 返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。// SortedMap&lt;K,V&gt; tailMap(K fromKey)// 返回此映射的部分视图，其键大于等于 fromKey。// NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive)// 返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey。// SortedMap&lt;K,V&gt; headMap(K toKey)// 返回此映射的部分视图，其键值严格小于 toKey。// NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive)// 返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey。 HashTableHashTable是Map的子实现。 其底层结构是数组+链表。数组的初始容量为11，扩容倍数为2倍+1。 HashTable存储的元素无序；不允许存储重复的key；不允许存储null作为key，也不允许存储null作为value。 HashTable线程安全。 StreamStream流是jdk1.8时提供的一种处理集合数据的方法。它提供一种内部迭代的方式，允许我们用多个中间操作来串联成一个管道，如同流式风格，避免了我们在对数据集合进行操作时带来的代码冗长问题。 一个Stream流包括三个模块： 一个数据源，创建流。 多个中间操作，形成流。 一个终止操作，执行流，生成结果。 创建流： 12Collection collection = new ArrayList();Stream stream = collection.stream(); 形成流： 12345678910111213141516171819202122232425262728293031323334353637383940 List&lt;Person&gt; personList = StudentList.personList;// filter:用于通过设置条件过滤元素 // 获取所有北京地区的同学 List&lt;Person&gt; collect = personList.stream() .filter(d -&gt; d.getAddress().equals(Person.Address.BJ)) .collect(Collectors.toList());// distinct:去除重复元素 // 去除重复的同学 List&lt;Person&gt; collect = personList.stream() .distinct() .collect(Collectors.toList());// limit:获取指定数量的元素 // 获取三个年龄大于22岁的同学 List&lt;Person&gt; collect = personList.stream() .filter(d -&gt; d.getAge() &gt; 22) .limit(3) .collect(Collectors.toList());// skip:跳过前n个元素 // 获取年龄大于22岁的同学并跳过第一个 List&lt;Person&gt; collect2 = personList.stream() .filter(d -&gt; d.getAge() &gt; 22) .skip(1) .collect(Collectors.toList());// map:映射每个元素到对应的结果 // 获取所有学生姓名 List&lt;String&gt; collect = personList.stream() .map(a -&gt; a.getName()) .collect(Collectors.toList());// sorted:对流进行排序 // 对高于180的同学根据身高进行排序 List&lt;Person&gt; collect = personList.stream() .filter(a -&gt; a.getHeight() &gt; 180) .sorted(Comparator.comparing(Person::getHeight)) .collect(Collectors.toList()); 执行流： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// anyMatch:检查是否匹配一个元素 // 判断是否存在北京的同学 boolean b1 = personList.stream() .anyMatch(a -&gt; &#123; return a.getAddress() == Person.Address.BJ; &#125;);// allMatch:检查是否匹配所有元素 // 判断是否都是北京的同学 boolean b1 = personList.stream() .allMatch(a -&gt; &#123; return a.getAddress() == Person.Address.BJ; &#125;);// nonematch:检查是否没有匹配元素 // 判断是否不存在深圳的同学 boolean b1 = personList.stream() .noneMatch(a -&gt; &#123; return a.getAddress() == Person.Address.SZ; &#125;);// findAny:返回任意元素（默认第一个） // Optional类作为一个容器代表一个值存在或不存在，方法如下 // isPresent(): 如果 Optional包含值返回true, 否则返回false // ifPresent(代码块): 会将Optional包含的值, 传给指定的代码块 // get(): 如果Optional包含值, 返回包含的值, 否则抛出异常 // orElse(默认值): 如果Optional包含值, 返回包含的值, 否则返回默认值 // 返回任意一个同学 Optional&lt;Person&gt; any = personList.stream() .findAny();// findFirst:返回第一个元素 // 获得年龄最小的同学 Optional&lt;Person&gt; first = personList.stream() .sorted(Comparator.comparing(Person::getAge)) .findFirst();// forEach:遍历输出元素 // 遍历列表，输出学生姓名 personList.stream() .sorted(Comparator.comparing(Person::getAge)) .forEach(a -&gt; System.out.println(a.getName()));// count:返回元素数量 // 北京同学的数量 long count = personList.stream() .filter(a -&gt; a.getAddress() == Person.Address.BJ) .count();// reduce:计算元素 // reduce有双参方法，第一个元素为identity，为计算的初始值 // 班级同学年龄总和 Optional&lt;Integer&gt; reduce1 = personList.stream() .map(Person::getAge) .reduce((a, b) -&gt; &#123; return a + b; &#125;);// collect:收集结果 // 收集结果可以放进List、Map、Set、Collection中 // 获取所有学生姓名，放进List中 List&lt;String&gt; collect = personList.stream() .map(a -&gt; a.getName()) .collect(Collectors.toList());"},{"title":"剑指offer-day23","path":"2022/04/29/剑指offer-day23/","text":"数组中出现次数超过一半的数字最简单的想法当然是用哈希表或者排序，但是最优解是一个算法，叫摩尔投票法。 算法的大致思想是：记录一个投票数，与众数相同则投票数+1，否则-1。因为众数的数量超过数组长度的一半，那么统计整个数组的投票数会大于0。知道这个规律后，唯一的问题是怎么确定一个数是众数。那么就涉及到了第二个规律：数组中的某部分的投票数总和为0，并不会影响整体的票数。现在可以假设数组的第一个元素是众数，向后遍历，遇到相同的数时票数+1，否则-1，如果遇到票数为0的情况，则放弃这一块的遍历情况，转而设置下一个数为众数…直到遍历完成，此时票数一定大于0，指向的数即为众数。 123456789101112131415161718192021class Solution &#123; public int majorityElement(int[] nums) &#123; int vote = 0; int x = 0; for(int num : nums)&#123; // 当票数为0时，假设遍历至此的数为众数 if(vote == 0)&#123; x = num; &#125; // 如果后续遍历的数与该数相等，票数+1，否则-1 if(x == num)&#123; vote++; &#125; else&#123; vote--; &#125; &#125; // 返回最后指向的数 return x; &#125;&#125; 构建乘积数组提示了无法使用除法，那么只能使用乘法，最优解选择的方式是对原数组遍历两遍：第一遍只累乘在自己之前的数，第二遍则累乘在自己之后的数，这样就得到答案了。 1234567891011121314151617181920212223class Solution &#123; public int[] constructArr(int[] a) &#123; // 特殊情况：a为空数组，返回空数组 if(a.length == 0)&#123; return new int[0]; &#125; int[] b = new int[a.length]; // 因为第一个数只有自己之后的数的累乘，所以将b的第一个数置为1 b[0] = 1; // 遍历第一遍，b[i]的值都是在自己之前的数的累乘 for(int i = 1; i &lt; a.length; i++)&#123; b[i] = b[i - 1] * a[i - 1]; &#125; // 记录一个临时值，用来记录b[i]之后的数的累乘 int tmp = 1; // 因为最后一个数只有自己之前的数的累乘，之前已经计算完毕，所以从倒数第二个数开始 for(int i = a.length - 2; i &gt;= 0; i--)&#123; tmp *= a[i + 1]; b[i] *= tmp; &#125; return b; &#125;&#125;"},{"title":"剑指offer-day22","path":"2022/04/28/剑指offer-day22/","text":"数组中数字出现的次数Ⅰ说实话，位运算方面的算法真的很难想，基本都要靠别人的思路，代码虽然简洁但是很难看懂。 这道题目非常像只出现一次的数字，但是只出现一次的数字变成了两个，这说明原来遍历并异或的思路行不通了，但是这个思路是个出发点。在遍历并异或后，就可以获得两个不同的数异或的值，由于异或的特性（一者为0一者为1，结果为1，否则为0），可以确定在结果的二进制中，最低位的1所在的位，在两个数中分别是1和0，那么可以根据这个线索将数组分成两个，一个在该位全是1，另一个则全是0，而且相同的数，它们在该位的数一定相同，那么这两个数组中就是数对相同的数和一个不同的数，对这两个数组进行异或运算，得出来的就是结果了。 1234567891011121314151617181920212223242526272829class Solution &#123; public int[] singleNumbers(int[] nums) &#123; int sum = 0; // 获得整个数组异或后的值 for(int i : nums)&#123; sum ^= i; &#125; int n = 1; // 结果跟1进行与运算，等于0说明结果的倒数第一位是0，n左移一位让1从最低位移到倒数第二位，重复至找到第一个和结果进行与运算的值为1的n，此时n就是结果里最低位为1，其他位为0的值。 while((sum &amp; n) == 0)&#123; n &lt;&lt;= 1; &#125; int x = 0; int y = 0; // 根据n来对数组里每个数进行与运算，数的二进制在该位为0和在该位为1的值分成两组，对这两组分别进行异或运算 for(int i : nums)&#123; if((i &amp; n) != 0)&#123; x ^= i; &#125; else&#123; y ^= i; &#125; &#125; int[] res = &#123;x,y&#125;; return res; &#125;&#125; 数组中数字出现的次数Ⅱ这道题目的最优解引入了一个算法，叫有限状态转换机，但是我看不懂这个算法，只能作罢，直接背代码算了。 123456789101112// 看不懂class Solution &#123; public int singleNumber(int[] nums) &#123; int one = 0; int two = 0; for(int i : nums)&#123; one = one ^ i &amp; ~two; two = two ^ i &amp; ~one; &#125; return one; &#125;&#125; 其实题目并没有限制o(n)时间和o(1)空间，完全是可以用hashmap做的。"},{"title":"剑指offer-day21","path":"2022/04/27/剑指offer-day21/","text":"后面开始涉及位运算与数学知识了，由于这方面比较薄弱，题目基本都是不会做的，就直接看答案吧，争取把答案看懂就行。 二进制中1的个数最简单的想法就是把二进制转为字符串，遍历得到1的个数，当然这不是最优解，最优解是对每一位的数和1进行与运算（与运算，即只有在两数都是1时才返回1，其余可能都返回0），当返回值是1，说明该位位数是1，对计算总和+1，否则+0。然后再将二进制数往右移1位，一直移至n的所有位数都为0（即数的十进制为0）即可。（java中，&gt;&gt; 是右移位数的意思，后面跟的值是右移几位的意思，而 &gt;&gt;&gt; 则是右移的同时在缺失的高位补0）。 1234567891011public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int res = 0; while(n != 0)&#123;// 当n=0时，跳出循环 res += (n &amp; 1);// res累加n和1进行与运算的结果 n &gt;&gt;&gt;= 1;// n右移1位，高位补0 &#125; return res; &#125;&#125; 不用加减乘除做加法题目摆明了要用位运算，最优解是通过观察加法的规律来得出位运算的解决方案。 观察得知，当位数都是0时，它们的和是0，进位是0；当位数有一个是1时，它们的和是1，进位是0；当位数都是1时，它们的和是0，进位是1。可以发现和的计算跟异或运算是一样的（异或运算，即是当两数不相同时，返回值为1，两数相同则返回0），进位的计算跟与运算后是一样的。那么加法可以换算成和与进位的和（其中进位需要左移一位，这样才能体现进位）。 12345678910class Solution &#123; public int add(int a, int b) &#123; while(b != 0) &#123; // 当进位为 0 时跳出 int c = (a &amp; b) &lt;&lt; 1; // c = 进位 a ^= b; // a = 非进位和 b = c; // b = 进位 &#125; return a; &#125;&#125;"},{"title":"剑指offer-day20","path":"2022/04/26/剑指offer-day20/","text":"重建二叉树又是一道知道思路但是不知道怎么实现的题目，直接放答案吧。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int[] preorder; Map&lt;Integer, Integer&gt; inorderMap = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) &#123; this.preorder = preorder; for(int i = 0; i &lt; inorder.length; i++)&#123; inorderMap.put(inorder[i], i); &#125; return recur(0, 0, inorder.length - 1); &#125; public TreeNode recur(int root, int left, int right)&#123; if(left &gt; right)&#123;// 发生越界，返回null return null; &#125; int i = inorderMap.get(preorder[root]);// 获得根节点在中序序列的下标 TreeNode node = new TreeNode(preorder[root]);// 新建根节点 node.left = recur(root + 1, left, i-1);// 根节点的左节点连接递归生成的左子树 node.right = recur(root + 1 + i - left, i+1, right);// 右节点连接递归生成的右子树 return node; &#125;&#125; 数值的整次方如果用简单的迭代会超时，就是摆明了不准用迭代，正确的方式是用变化的二分法，每次将幂数折半，将要累乘的数换成该数的二次方，如果幂数是奇数的话就把多出来的一个数乘进返回值里。 123456789101112131415161718class Solution &#123; public double myPow(double x, int n) &#123; double res = 1; long b = n;// 用long来接int值，防止负数转正数时发生溢出 if(b &lt; 0)&#123;// 幂数小于0，底数要变为分数 b = -b; x = 1 / x; &#125; while(b &gt; 0)&#123; if(b % 2 == 1)&#123;// 幂数为奇数，将多出的数放入答案 res *= x; &#125; x *= x;// 底数变成平方 b /= 2;// 幂数变为一半，向下取整 &#125; return res; &#125;&#125; 二叉搜索树的后序遍历序列完全不会，直接放答案。 1234567891011121314151617class Solution &#123; public boolean verifyPostorder(int[] postorder) &#123; // 用栈存储倒序的后序遍历，即是“根，右，左”的逆序先序遍历 Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int root = Integer.MAX_VALUE; for(int i = postorder.length - 1; i &gt;= 0; i--) &#123; // 因为按照遍历逻辑当前节点一定是父节点的左孩子，如果出现左孩子的值大于父节点，说明不是后序遍历序列，返回false if(postorder[i] &gt; root) return false; // 如果栈顶大于当前节点，说明栈内有当前节点的父节点，出栈至栈空，栈底为父节点 while(!stack.isEmpty() &amp;&amp; stack.peek() &gt; postorder[i]) root = stack.pop(); // 当前节点压栈 stack.add(postorder[i]); &#125; return true; &#125;&#125;"},{"title":"剑指offer-day19","path":"2022/04/25/剑指offer-day19/","text":"求1+2+…+n感觉本质上是一道脑筋急转弯题目，因为迭代和递归的方式都被锁死了，只能另辟蹊径完成，答案用的是逻辑运算符的短路，也见到有人用异常的，我没有想出来，就以答案为标准吧。 123456789class Solution &#123; int res = 0; public int sumNums(int n) &#123; // 运用逻辑运算符短路，递归至n=1时发生短路，后面的递归计算终止 boolean x = n &gt; 1 &amp;&amp; sumNums(n-1) &gt; 0; res += n; return res; &#125;&#125; 二叉搜索树的最近公共祖先自己想出来了递归，答案给的最优解是迭代，但是实际实验过发现两者并没有差别，那就放自己的答案吧。 因为是二叉搜索树，可以利用搜索树的特性，判断两个节点是否在一侧，在哪一侧则往哪边遍历，否则就返回当前的根节点。 12345678910111213141516171819202122/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; // 在左子树往左遍历，在右子树往右遍历 if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123; return lowestCommonAncestor(root.left,p,q); &#125; else if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123; return lowestCommonAncestor(root.right,p,q); &#125; // 两边各一个返回当前根节点 return root; &#125;&#125; 二叉树的最近祖先相比上题少了一个搜索树的条件，显然变难了，自己写的是递归+遍历，有很高的时间复杂度，最优解只使用了递归。 1234567891011121314class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; // 递归终止条件：root为空，或root为p、q中的一个 if(root == null || root == p || root == q) return root; // 递归遍历根节点的左右子树，返回null、p或q TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); // left为空表示p、q都在右子树，返回右子树的根节点，反之同理 if(left == null) return right; if(right == null) return left; // 两者都不为空表示p、q在异侧，直接返回根节点 return root; &#125;&#125;"},{"title":"剑指offer-day18","path":"2022/04/25/剑指offer-day18/","text":"二叉树的深度第一道自己写出来的树题！可以说非常具有纪念意义了，时空复杂度也不输最优解，自豪地放上自己的解。 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int depth; int max; public int maxDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; depth = 0; max = 0; preorder(root); return max; &#125; public void preorder(TreeNode root)&#123;// 前序遍历 depth++;// 遍历该节点，深度+1 if(root == null)&#123;// 若节点为空，说明到达叶节点，深度-1并记录此时的最大深度 depth--; max = Math.max(max,depth); return; &#125; preorder(root.left);// 递归遍历左节点和右节点 preorder(root.right); depth--;// 遍历完成，深度-1 &#125;&#125; 平衡二叉树半写半抄完成的，用的是从上到下的递归，然而并不是最优解，最优解是从下到上的递归+剪枝。使用后序遍历从叶子节点往上遍历，每次遍历时看以该节点为根的子树是否是平衡二叉树，如果是则返回该子树的高度，否则返回-1，表示该树不是平衡二叉树。 123456789101112131415161718class Solution &#123; public boolean isBalanced(TreeNode root) &#123; return recur(root) != -1; &#125; private int recur(TreeNode root) &#123;// 返回平衡二叉树的高度，不是平衡二叉树则返回-1 if (root == null) return 0;// 遍历至叶子节点，返回高度为0 // 遍历左右子树，如果左右子树不是平衡二叉树，返回-1 int left = recur(root.left); if(left == -1) return -1; int right = recur(root.right); if(right == -1) return -1; // 如果左右子树的高度差&lt;2,表示是平衡二叉树，返回该根节点的高度，否则返回-1 return Math.abs(left - right) &lt; 2 ? Math.max(left, right) + 1 : -1; &#125;&#125;"},{"title":"剑指offer-day17","path":"2022/04/23/剑指offer-day17/","text":"最小的k个数非常简单的题目，如果利用Arrays.sort()基本等于白给，可是这就是明着考你排序算法的。我自己手动写了一个快排，虽然还是不太熟悉，多写写就好了。 最优解是利用快排的特点，在基准值左边的数都小于基准值，当基准值的下标为k时，左边则是答案了。 1234567891011121314151617181920212223242526class Solution &#123; public int[] getLeastNumbers(int[] arr, int k) &#123; if (k &gt;= arr.length)&#123;// 特殊值返回：如果k大于数组的长度，直接返回数组 return arr; &#125; return quickSort(arr, k, 0, arr.length - 1); &#125; private int[] quickSort(int[] arr, int k, int l, int r) &#123; int i = l, j = r;// 定义两个指针指向数组的头和尾 while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[j] &gt;= arr[l]) j--;// 找到基准值右边小于基准值的值 while (i &lt; j &amp;&amp; arr[i] &lt;= arr[l]) i++;// 找到基准值左边大于基准值的值 swap(arr, i, j);// 交换值 &#125; swap(arr, i, l);// 交换头/尾指针和基准值指针，使得基准值左边都小于基准值，右边都大于基准值 if (i &gt; k) return quickSort(arr, k, l, i - 1);// 如果基准值在k的右边，则对基准值左边的数组进行快排 if (i &lt; k) return quickSort(arr, k, i + 1, r);// 如果基准值在k的左边，则对基准值右边的数组进行快排 return Arrays.copyOf(arr, k);// 返回0-(k-1)的下标的数组 &#125; private void swap(int[] arr, int i, int j) &#123;// 交换方法 int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125;&#125; 数据流中的中位数看完题目我还嗤之以鼻，这也叫hard题？刷刷写完一提交，过是过了，跑了1600ms… 看了最优解，用到了大根堆和小根堆的知识，代码是不一定看得懂了，只能说尽力而为吧。 12345678910111213141516171819class MedianFinder &#123; Queue&lt;Integer&gt; A, B; public MedianFinder() &#123; A = new PriorityQueue&lt;&gt;(); // 小顶堆，保存较大的一半 B = new PriorityQueue&lt;&gt;((x, y) -&gt; (y - x)); // 大顶堆，保存较小的一半 &#125; public void addNum(int num) &#123; if(A.size() != B.size()) &#123;// 插入数量为奇数， A.add(num); B.add(A.poll()); &#125; else &#123; B.add(num); A.add(B.poll()); &#125; &#125; public double findMedian() &#123; return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;// 如果两堆容量相等，说明此时为偶数，各取堆顶值/2；反之说明为奇数，只取小顶堆中的值。 &#125;&#125;"},{"title":"剑指offer-day16","path":"2022/04/23/剑指offer-day16/","text":"把数组排成最小的数看到题目就想到自然排序了，但是直接使用是不可以的，正确的排序方式应该是看两字符串x和y，是否满足x+y&lt;y+x（比如3和30，如果按默认的字典序排列应该是3在前，但是两者的组合330明显大于303，所以应该是看是否满足330&lt;303,不满足则30排在前面） 1234567891011121314class Solution &#123; public String minNumber(int[] nums) &#123; StringBuffer res = new StringBuffer(); String[] s = new String[nums.length]; for(int i = 0; i &lt; nums.length; i++)&#123;// 将int转为String s[i] = String.valueOf(nums[i]); &#125; Arrays.sort(s, (s1,s2) -&gt; (s1+s2).compareTo(s2+s1));// 实现comparable接口的自然排序 for(String str : s)&#123; res.append(str); &#125; return res.toString(); &#125;&#125; 扑克牌的顺子一开始没有很好的想法，就放弃看答案了。 123456789101112131415class Solution &#123; public boolean isStraight(int[] nums) &#123; int zeroCount = 0; Arrays.sort(nums);// 对数组排序 for(int i = 0; i &lt; nums.length - 1; i++)&#123; if(nums[i] == 0)&#123; zeroCount++;// 记录大小王的个数，在0-2之间 &#125; else if(nums[i] == nums[i+1])&#123;// 出现相等的数表示无法成为顺子 return false; &#125; &#125; return nums[nums.length-1] - nums[zeroCount] &lt; 5;// 用最大的数减去最小的非0数，如果差值小于5说明可以成为顺子 &#125;&#125;"},{"title":"学习总结（2022.04.19-2022.04.24）","path":"2022/04/22/学习总结（2022-04-19-2022-04-24）/","text":"类加载器分类： Bootstrap ClassLoader 根类加载器，负责核心类的加载 Extension ClassLoader 扩展类加载器，负责扩展目录中jar包的加载 Sysetm(App) ClassLoader 系统类加载器&#x2F;应用加载器，负责自定义类的加载 User ClassLoader 自定义类加载器，自定义的类加载器 双亲委派模型：当自定义类进行类加载时，并不是一开始就由系统类加载器进行加载的，而是会交给扩展类加载器，扩展类加载器又会交给根类加载器，但是根类加载器在核心类的jar包中找不到自定义的类，于是又会原路返回至系统类加载器，最后还是由系统类加载器执行。 注解注解是代码里面的一些特殊标记，可以在编译、类加载、运行时被读取，并执行相应的处理。注解可以在不改变原有逻辑的情况下，补充一些信息。注解作为一种数据类型，跟class、interface具有同等地位。 注解的使用方式与修饰符一样，可以给任何一种数据写上注解（类、接口、构造器、变量…） 自定义注解： 123456789101112// 语法权限修饰符 @interface 注解名字&#123; // 注解体 属性类型 属性名(); 属性类型 属性名(); 属性类型 属性名(); .....&#125;//举例public @interface MyAnno &#123;&#125; 注解的使用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// @注解名(属性1 = value1,属性2 = value2) // 注解使用 @MyAnno3(name = &quot;zs&quot;,age = 20) public static void func() &#123; &#125;// 例子：获取注解信息public class Demo &#123; public static void main(String[] args) throws Exception&#123; //获取Login注解里的信息 打印一下 // 获取字节码文件对象 Class&lt;?&gt; c = Class.forName(&quot;_23annotation.com.cskaoyan._04handle.Demo&quot;); // 获取方法对象 Method method = c.getDeclaredMethod(&quot;login&quot;); // 再判断方法上使用了注解 isAnnotationPresent boolean annotationPresent = method.isAnnotationPresent(Login.class); System.out.println(annotationPresent); if (annotationPresent) &#123; // 是 , 获取这个注解实例 getAnnotation Login annotation = method.getAnnotation(Login.class); // 获取属性 String name = annotation.name(); String password = annotation.password(); System.out.println(name); System.out.println(password); &#125; &#125; @Login public static void login() &#123; &#125;&#125;// 使用元注解修饰@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@interface Login &#123; // 定义属性 String name() default &quot;root&quot;; String password() default &quot;123456&quot;;&#125; 元注解：描述注解的注解。常用的元注解有： @Retention元注解，来定义我们自己定义的注解的保留级别. 123RetentionPolicy.RUNTIMERetentionPolicy.CLASS // 默认RetentionPolicy.SOURCE @Target元注解，注解可以作用的目标 1234ElementType.TYPE// 整个类ElementType.FIELD// 成员变量 ElementType.CONSTRUCTOR// 构造方法 ElementType.METHO// 成员方法 GC如何确定垃圾： 引用计数算法：给对象添加一个引用计数器，每当有引用指向它，计数器+1；每当引用失效，计数器-1。当计数器为0，表示该对象不可被引用。但是引用计数算法无法应用在循环引用中。 根搜索算法：以一个叫”GC Roots”的对象为起点向下搜索，看一个对象是否存在连接至GC Root的引用链，如果没有表示该对象不可被引用。GC使用根搜索算法。 如何回收垃圾： 标记清除算法：首先标记出所有需要回收的对象，再统一回收；或者标记出所有存活的对象，统一回收未被标记的对象。虽然实现简单，但是会产生很多内存碎片。 标记复制算法：将一块内存划分成容量相等的两块，每次使用其中一块，当内存用完后，将还存活的对象复制至另一块内存中，再把已满的内存全部清理。虽然实现简单且不容易产生内存碎片，但是内存利用率降低了，且存活对象较多时，会产生许多不必要的开销，降低效率。 标记整理算法：同标记清除算法一样，将所有需要回收的对象标记，但是它不会直接清理，而是将存活的对象都往一端移动，移动完成后清除边界外的所有对象。这样虽然不会产生内存碎片，但是效率却降低了。 分代收集算法：根据对象的存活时间将内存划分为新生代、老年代和永久代，新生代中的对象大部分都是存活时间较短的，老年代中的对象则是存活时间较长的。 新创建的对象会放入新生代中，新生代空间使用的是标记复制算法，将新生代空间划为一个eden空间和两个survivor空间（survivor1、survivor2），其中eden空间用来放置新建的对象，survivor1和survivor2则用来放置复制一遍和复制两遍后存活的对象。当过了一定时间后，survivor2中的对象会放至老年代。 老年代中因为存活对象较多，一般使用标记整理算法。 何时回收垃圾： 申请堆空间失败，表示堆空间已满，触发GC。 系统进入休眠一段时间触发GC。 主动调用GC。 设计模式五大原则： 单一职责原则：每个类只负责自己的部分。 开闭原则：一个类或模块应该对拓展开放，对修改关闭。 里氏替换原则：任何父类可以出现的地方，子类都可以出现。 接口隔离原则：一个接口只提供一个对外的功能。 依赖倒置原则：上层模块不应该依赖于底层模块，而应该依赖于抽象类或接口；抽象类或接口不应该依赖于具体实现类，具体实现类应该依赖于抽象类或接口。 单例设计模式： 保证一个类只有一个对象，防止频繁的创建和销毁对象，避免对共享资源的多重占用。 实现方法：构造方法私有；提供返回实例的静态方法；提供自身类型的全局变量。 123456789101112131415161718public class Singleton1 &#123; //- 提供自身类型的全局的成员变量 private static Singleton1 instance; // - 构造方法私有 private Singleton1() &#123; &#125; //- 提供静态方法,返回实例 public static Singleton1 getInstance() &#123; // 最终要返回singleton1对象 // 做判断 if (instance == null) &#123; instance = new Singleton1(); &#125; return instance; &#125;&#125; 工厂设计模式： 可以通过一个工厂批量生产对象，同时隐藏创建对象的一些细节，标准化产生实例。 123456789101112131415161718192021222324252627282930313233public class FruitFactory &#123; // 提供1个静态方法 返回具体水果对象 public static Fruit getInstance(String name) &#123; Fruit fruit = null; if (&quot;apple&quot;.equals(name)) &#123; fruit = new Apple(); &#125; else if (&quot;orange&quot;.equals(name)) &#123; fruit = new Orange(); &#125; else if (&quot;banana&quot;.equals(name)) &#123; fruit = new Banana(); &#125; else &#123; System.out.println(&quot;生产不了!&quot;); &#125; // 返回水果对象 return fruit; &#125; // 不修改原有的代码逻辑 实现功能 public static Fruit getInstance2(String className) throws Exception &#123; // 根据全限定名 获取字节码文件对象 Class&lt;?&gt; c = Class.forName(className); // 获取构造方法 Constructor&lt;?&gt; declaredConstructor = c.getDeclaredConstructor(); // 实例化对象 Fruit fruit = (Fruit) declaredConstructor.newInstance(); // 返回对象 return fruit; &#125;&#125;"},{"title":"剑指offer-day15","path":"2022/04/22/剑指offer-day15/","text":"二叉树中和为某一值的路径完全没思路，直接放答案。 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();// 定义一个path来记录每次递归结束后的结果 LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int target) &#123; firstOrder(root,target);// 先序遍历 return res; &#125; public void firstOrder(TreeNode root, int target)&#123; if(root == null)&#123;// 节点为空时返回 return; &#125; path.add(root.val);// path添加递归的值 target -= root.val;// 目标值减去当前递归的值 if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null)&#123;// 如果目标值为0且该节点为叶子节点，将已经递归完成的path放入答案列表中 res.add(new LinkedList(path)); &#125; pathSum(root.left,target);// 递归遍历左节点 pathSum(root.right,target);// 递归遍历右节点 path.removeLast();// 执行至此表示寻找符合的叶子节点失败，将本次遍历的节点退出，回溯至上个节点 &#125;&#125; 二叉搜索树与双向链表这道题想到了中序遍历，但是对双链表还是不太熟悉，没做出来，半抄了一个答案。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val,Node _left,Node _right) &#123; val = _val; left = _left; right = _right; &#125;&#125;;*/class Solution &#123; Node head;// 定义头节点和尾节点 Node pre; public Node treeToDoublyList(Node root) &#123; if(root == null)&#123;// 树为空返回null return null; &#125; inorder(root);// 以尾节点为指针，进行中序遍历 head.left = pre;// 遍历完成，将头尾节点连接 pre.right = head; return head; &#125; public void inorder(Node root)&#123; if(root == null)&#123;// 遍历至空节点返回 return; &#125; inorder(root.left); if(pre != null)&#123;// 此时尾节点若还没赋值表示头尾节点未初始化，需要初始化头节点；反之则让尾节点指向当前节点 pre.right = root; &#125; else&#123; head = root; &#125; root.left = pre;// 当前节点的尾指针指向尾节点 pre = root;//尾节点跳至当前节点 inorder(root.right); &#125;&#125; 二叉搜索树的第k大节点这道题倒是写出来了，但是还是老问题，时空复杂度非常感人，看了答案发现用了一个逆序的中序遍历，而且提前终止了遍历，所以能有非常优秀的时空复杂度。 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int res; int k; public int kthLargest(TreeNode root, int k) &#123; this.k = k; inorder(root);// 逆序中序遍历 return res; &#125; public void inorder(TreeNode root)&#123; if(root == null || k == 0)&#123;// 当遍历至空节点时返回；当k已经为0时，提前终止遍历 return; &#125; inorder(root.right); if(--k == 0)&#123;// 当k-1 = 0时，表示当前遍历的节点就是答案，赋值给res res = root.val; &#125; inorder(root.left); &#125;&#125;"},{"title":"剑指offer-day14","path":"2022/04/21/剑指offer-day14/","text":"矩阵中的路径涉及到图的范围了，只能说是力所不能及，直接放答案吧，主要是DFS的思想怎样用代码表现出来。 123456789101112131415161718192021222324252627282930class Solution &#123; public boolean exist(char[][] board, String word) &#123; char[] words = word.toCharArray(); for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[0].length; j++)&#123; if(dfs(board,words,i,j,0))&#123;// 遍历找到第一个等于字符串头的字母，开始DFS return true; &#125; &#125; &#125; // 没有找到或者没有路径，返回false return false; &#125; public boolean dfs(char[][] board, char[] word, int i, int j, int k)&#123; // 终止条件有：遍历时超出边界值；遍历的值不等于字符串中的值 if(i &lt; 0 || i &gt;= board.length || j &lt; 0 || j &gt;= board[0].length || board[i][j] != word[k])&#123; return false; &#125; // k为字符串的下标，如果此时k等于字符串长度，说明寻找到路径，直接返回true if(k == word.length - 1)&#123; return true; &#125; board[i][j] = &#x27;\\0&#x27;;// 遍历过的地方设为空，防止遍历回来 boolean res = (dfs(board,word,i+1,j,k+1) || dfs(board,word,i-1,j,k+1) || dfs(board,word,i,j+1,k+1) || dfs(board,word,i,j-1,k+1));// 分别遍历上下左右，只要有一个符合条件即可 board[i][j] = word[k];// 将遍历过的地方重新赋值，防止影响下一次遍历 return res;// 返回结果 &#125;&#125; 机器人的运动范围跟上题有些相似，就是返回值从boolean改成了int，参考着答案跌跌撞撞地写下来了。 123456789101112131415161718192021222324class Solution &#123; boolean[][] visited;// 定义一个boolean数组，来表示该元素是否被访问过 public int movingCount(int m, int n, int k) &#123; visited = new boolean[m][n]; return dfs(0,0,m,n,k);// 从左上角开始遍历 &#125; public int bitSum(int m, int n)&#123;// 计算位数和，因为题目只取两位数，就方便着写 int m1 = m % 10; int m2 = m / 10; int n1 = n % 10; int n2 = n / 10; return m1+m2+n1+n2; &#125; public int dfs(int i,int j, int m, int n,int k)&#123; // 遍历失败条件：遍历超出范围；遍历的位置的位数和大于要求数；该位置早被遍历过 if(i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || bitSum(i,j) &gt; k || visited[i][j])&#123; return 0;// 返回0表示此处不是机器人能到达的地方，不能计入总数 &#125; visited[i][j] = true;// 遍历成功，将这个位置设为已访问过 return 1+dfs(i+1,j,m,n,k)+dfs(i-1,j,m,n,k)+dfs(i,j+1,m,n,k)+dfs(i,j-1,m,n,k);// 因为成功，所以总数+1 &#125;&#125;"},{"title":"剑指offer-day13","path":"2022/04/21/剑指offer-day13/","text":"调整数组顺序一开始是想的最简单的方法，用两个数组来记录奇数和偶数，遍历原数组一遍就行，但是明显不是最优解。最优解是用双指针从数组两边往中间遍历，头指针记录奇数，尾指针记录偶数，如果头指针遇到偶数就停止，转而遍历尾指针；尾指针遇到奇数就跟头指针的偶数交换，遍历直至两指针相遇。 123456789101112131415161718class Solution &#123; public int[] exchange(int[] nums) &#123; int i = 0; int j = nums.length - 1; while(i &lt; j)&#123;// 遍历直至两指针相遇 while(nums[i] % 2 != 0 &amp;&amp; i &lt; j)&#123;// 头指针遇到偶数停止 i++; &#125; while(nums[j] % 2 == 0 &amp;&amp; i &lt; j)&#123;// 尾指针遇到奇数停止 j--; &#125; int tmp = nums[i];// 交换 nums[i] = nums[j]; nums[j] = tmp; &#125; return nums;// 返回原数组 &#125;&#125; 和为s的两个数字还是双指针…用一个头指针和一个尾指针指向数组两端，求两个指针所指元素的和，大于目标值尾指针向前移，反之头指针向后移，直至等于目标值，返回两个指针指向的元素。 12345678910111213141516171819class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int i = 0;// 维护一个头指针和一个尾指针 int j = nums.length - 1; while(i &lt; j)&#123;// 如果头指针超过尾指针，推出循环 while(nums[i] + nums[j] &lt; target &amp;&amp; i &lt; j)&#123;// 小于target，头指针后移 i++; &#125; while(nums[i] + nums[j] &gt; target &amp;&amp; i &lt; j)&#123;// 大于target，尾指针前移 j--; &#125; if(nums[i] + nums[j] == target)&#123;// 等于target，退出循环 break; &#125; &#125; int[] res = &#123;nums[i],nums[j]&#125;; return res; &#125;&#125; 翻转单词顺序一开始是用split()方法来分割字符串的，虽然写出来了但是时空复杂度不好，看了答案也发现并不推荐这种做法，利用双指针会更好。 用两个指针都指向string的尾部，前指针i遍历至空格，与后指针j一起获取了第一个不含空格的子字符串，用一个StringBuffer接住该字符串，i则继续遍历，不过此时是遍历至第一个字符，再将j移到此处，重复至遍历完成。 12345678910111213141516171819class Solution &#123; public String reverseWords(String s) &#123; s.trim();// 将s头尾的空格去掉 int i = s.length() - 1;// 维护两个指针 int j = i; StringBuffer sb = new StringBuffer(); while(i &gt;= 0)&#123; while(i &gt;= 0 &amp;&amp; s.charAt(i) != &#x27; &#x27;)&#123;// 找到第一个空格 i--; &#125; sb.append(s.substring(i+1,j+1) + &quot; &quot;);// 获取并添加子字符串+&quot; &quot; while(i &gt;= 0 &amp;&amp; s.charAt(i) == &#x27; &#x27;)&#123;// 找到第一个字符 i--; &#125; j = i;// 后指针指向第一个字符 &#125; return sb.toString().trim();// 完成后尾部会多出一个空格，除去空格 &#125;&#125;"},{"title":"剑指offer-day12","path":"2022/04/21/剑指offer-day12/","text":"合并两个排序的链表还是双指针的题目，一开始是想直接在两个链表上处理的，后来发现会出现漏元素的问题，就跟着答案老老实实地用一条新链表来接。 思路很简单，用两个指针p和q遍历两个链表，p&lt;&#x3D;q时将p指向的元素放入新建的链表，反之则放入q指向的元素，遍历至一个指针遍历完成，将新链表指向未遍历完的那个指针就完成了。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null)&#123; return l2; &#125; if(l2 == null)&#123; return l1; &#125; ListNode p = l1;// 创建两个指针 ListNode q = l2; ListNode head = new ListNode(-1);// 创建新链表头和一个头指针 ListNode pre = head; while(p != null &amp;&amp; q != null)&#123;// 遍历两个链表 if(p.val &lt;= q.val)&#123; ListNode cp = p; head.next = cp; head = head.next; p = p.next; &#125; else&#123; ListNode cq = q; head.next = cq; head = head.next; q = q.next; &#125; &#125; if(p != null)&#123;// 其中一个链表遍历完成，遍历另一个链表 head.next = p; &#125; if(q != null)&#123; head.next = q; &#125; return pre.next; &#125;&#125; 两个链表的第一个公共节点这个并没有想出来怎么做，还是看答案吧。 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA == null || headB == null)&#123;// 其中一个节点为空，返回null return null; &#125; ListNode p = headA;// 建立两个指针 ListNode q = headB; while(p != q)&#123; if(p == null)&#123;// 当headA的指针遍历完成后，改为从headB再遍历一次 p = headB; &#125; else&#123; p = p.next; &#125; if(q == null)&#123;// 当headB的指针遍历完成后，改为从headA再遍历一次 q = headA; &#125; else&#123; q = q.next; &#125; &#125; // p、q相等时，跳出循环并输出p，这就是公共节点 return p; &#125;&#125;"},{"title":"剑指offer-day11","path":"2022/04/21/剑指offer-day11/","text":"删除链表的节点思路很简单，维护一个双指针，一个指向现节点，一个指向前节点，找到要删除的节点，让前节点指向现节点的下一个节点，再让现节点指向空指针即可。主要是删除头节点的问题，我选择再维护一个头指针preHead，而答案是将其作为特殊情况处理，直接返回头节点指向的链表。 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode deleteNode(ListNode head, int val) &#123; ListNode pre = new ListNode(-1);// pre指向头指针 ListNode preHead = pre;// preHead指向头指针 ListNode cur = head;// cur指向链表中的头指针 pre.next = cur;// 将自建的头指针和链表中的头指针连接 while(cur != null)&#123; if(cur.val == val)&#123;// 删除节点 pre.next = cur.next; cur.next = null; &#125; pre = cur; cur = cur.next; &#125; return preHead.next; &#125;&#125; 链表中倒数第k个节点跟上面一样，维护一个双指针，都先指向头节点，根据k值让p节点向前移动，当两个节点相距k-1时q节点和p节点一起前移，到p节点指向链表尾节点时结束，返回q节点所指向的链表即可。 12345678910111213141516171819202122/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode getKthFromEnd(ListNode head, int k) &#123; ListNode p = head;// 维护两个节点p、q ListNode q = head; for(int i = 0; i &lt; k-1; i++)&#123;// 迁移p节点 p = p.next; &#125; while(p.next != null)&#123;// p节点和q节点一起前移 q = q.next; p = p.next; &#125; return q;// 返回q节点指向的链表 &#125;&#125;"},{"title":"剑指offer-day10","path":"2022/04/20/剑指offer-day10/","text":"把数字翻译成字符串有一点像青蛙跳台阶，但是递归条件有点不一样。 维护三个指针a&#x3D;f(0)&#x3D;1、b&#x3D;f(1)&#x3D;1、c &#x3D; 1，遍历整个数字（为了方便遍历需要把数字转为字符串），从第二个数字开始，如果该数字和前一个数字组成的数&gt;&#x3D;10且&lt;&#x3D;25，说明这个数字的翻译方法有f(0)+f(1)种，否则只有f(1)种。c的值等于这个数的翻译方法，此时c指向该数字，a指向b，b指向c，循环至遍历结束。 1234567891011121314151617181920class Solution &#123; public int translateNum(int num) &#123; String s = String.valueOf(num); int a = 1;// 代表f(0) int b = 1;// 代表f(1) int c = 1;// 代表f(0)+f(1)，防止只有一个数的特殊情况，初始值为1 for(int i = 1; i &lt; s.length(); i++)&#123; int n = Integer.parseInt(s.substring(i-1,i+1)); if(n &gt;= 10 &amp;&amp; n &lt;= 25)&#123;// 如果遍历的数与前一个数组合符合范围，说明遍历至该数时的翻译方法有f(n-1)+f(n-2)种 c = a + b; &#125; else&#123;// 不符合，明遍历至该数时的翻译方法有f(n-1)种 c = b; &#125; a = b;// a跳至f(n-2) b = c;// b跳至f(n-1) &#125; return c; &#125;&#125; 最长不含重复字符的子字符串自己写了一个虽然过了，但是时空复杂度真的丢人…算是一个暴力解吧。 同样是动态规划思想，用一个哈希表来记录每个字符最后出现的位置，遍历整个字符串，获得一个字符过去出现的最后位置和现在出现的位置，相减获得重复前的子字符串长度。用一个数tmp来记录。最后返回每次记录后tmp的最大值。 12345678910111213141516171819class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); int tmp = 0; int res = 0; for(int i = 0; i &lt; s.length(); i++)&#123; int j = map.getOrDefault(s.charAt(i),-1);//无值则初始化map，初始值设为-1，有值则获取该字符前一次出现的位置 map.put(s.charAt(i),i);// 修改位置至当前 if(tmp &lt; i - j)&#123;// 如果tmp&lt;i-j，说明还未找到相同的字符，tmp长度+1 tmp++; &#125; else&#123;// 如果tmp&gt;=i-j，说明出现了相同的字符，tmp=i-j tmp = i - j; &#125; res = Math.max(tmp,res);// 获取tmp的最大值 &#125; return res; &#125;&#125;"},{"title":"剑指offer-day9","path":"2022/04/20/剑指offer-day9/","text":"连续子数组的最大和思路跟之前的股票的最大利润是一样的，遍历一次数组，如果之前遍历的值的和sum加上这次遍历的值num都小于该值，那么就将起点改为num，并用一个值res来记录每次遍历后的最大值。 1234567891011121314class Solution &#123; public int maxSubArray(int[] nums) &#123; int res = Integer.MIN_VALUE; int sum = 0; for(int num : nums)&#123; sum += num;// 记录遍历至该值的和 if(sum &lt;= num)&#123; sum = num;// 如果总和都没有该值大，将记录的起点改为该值 &#125; res = Math.max(res,sum);// 记录每次遍历后总和间的最大值 &#125; return res; &#125;&#125; 礼物的最大价值相当于上题的加强版，使用一个二维数组，并且增加了一个向下还是向右的判断，但是核心思想是不变的。 遍历数组来记录每次行进的最大总和，放在这次行进的节点中。从左上角开始遍历，因为从第一行遍历和从第一列遍历都是累加的，可以做一个判断：当要遍历的值位于这两个特殊位置时，只需要获取它的左边（或上边）的和，累加至该值并替换。其他时候则需要对左边的值和上边的值进行比较，取较大的累加至该值并替换。最后输出右下角的总和。 123456789101112131415161718192021class Solution &#123; public int maxValue(int[][] grid) &#123; for(int m = 0; m &lt; grid.length; m++)&#123; for(int n = 0; n &lt; grid[0].length; n++)&#123; if(m == 0 &amp;&amp; n == 0)&#123;// 位于起点，跳过遍历 continue; &#125; if(m == 0)&#123;// 位于第一行，只累加左边的值 grid[m][n] += grid[m][n-1]; &#125; else if(n == 0)&#123;// 位于第一列，只累加上边的值 grid[m][n] += grid[m-1][n]; &#125; else&#123;// 其他情况需要判断左边和上边的值，取较大值累加 grid[m][n] += Math.max(grid[m][n-1],grid[m-1][n]); &#125; &#125; &#125; return grid[grid.length - 1][grid[0].length - 1];// 返回右下角值 &#125;&#125;"},{"title":"学习总结（2022.04.12-2022.04.20）","path":"2022/04/18/学习总结（2022-04-12-2022-04-18）/","text":"IO的分类按照数据流向分(以内存为参照物)： 输入：外设-&gt;内存 输出：内存-&gt;外设 按照数据类型分： 字节流(1B &#x3D; 0000 0000) 字符流 字节流一般用于非文本文件；字符流一般用于文本文件。 为什么会有字符流？因为用字节流读取非英文和数字的数据可能会发生错误 4个抽象基类及其子类 字节输出流 字节输入流 字符输出流 字符输入流 抽象父类 OutputStream&lt;br&gt;void write(byte[] b) InputStream&lt;br/&gt;int read(byte[] b) Writer&lt;br&gt;void write(char[] c)&lt;br/&gt;void writer(String s) Reader&lt;br&gt;int read(char[] c) 文件 FileOutputStream(File file, boolean append) FileInputStream(File file) FileWriter(File file, boolean append) FileReader(File file) 缓冲 BufferedOutputStream(OutputSteam out, int size) BufferedInputStream(InputStream in, int size) BufferedWriter(Writer out, int size) BufferedReader(Reader in, int size)&lt;br&gt;String readLine() 转换(字节转字符) OutputStreamWriter(OutputStream out, String charsetName) InputStreamReader(InputStream in, String charsetName) 数据(输入&#x2F;输出java基本类型) DataOutputStream(OutputStream out)&lt;br&gt;void writeInt(int a)... DataInputStream(InputStream in)&lt;br&gt;int readInt()... 打印(输入&#x2F;输出字符串) PrintStream(OutputStream out) &lt;br&gt;int print(int a)... PrintWriter(Writer out)&lt;br&gt;int print(int a) 对象(序列化&#x2F;反序列化) ObjectOutputStream(OutputStream out)&lt;br&gt;void writeObject(Object obj) ObjectInputStream(InputStream in)&lt;br&gt;Object readObject() 换行方式“\\r\\n” System.lineSeparator() 标准IO流System.in本质是InputStream System.out本质是PrintStream 进程&#x2F;线程 同步&#x2F;异步进程是操作系统调度的基本单位，线程是cpu调度的基本单位 同步是调用可以立即得到结果，但是需要等待；异步是调用不能立即得到结果，但是可以不等待 java程序运行原理jvm是多线程的，每次运行至少有两个线程：main线程和GC线程 java是抢占式线程调度，但是java自带的setPriority()方法并不能改变线程的优先级，因为java中的优先级是静态的，只能给操作系统一个建议，实际上操作系统有自己的一套线程优先级 多线程的实现方式 定义一个类继承Thread类，重写run()方法，创建该类对象，通过start()创建线程(如果使用run()只是普通的调用子类方法，并不能达到创建多线程的效果)特点：单继承 定义一个类实现Runnable接口，重写run()方法，创建Runnable子类对象，再创建Thread对象，并将该子类对象作为参数传递。特点：实现接口 定义一个类实现Callable接口，重写call()方法，创建FutureTask对象并将该类的对象作为参数传递，再创建Thread对象将FutureTask对象作为参数传递。特点：有返回值 线程API123456789String getName();// 获得该线程的名称void setName(String name);// 设置该线程的名称Static Thread currentThread();// 返回当前正在执行的线程对象的引用static void sleep(long millis);// 线程休眠，进入阻塞，但是不释放资源void join();// 主线程等待执行该方法的子线程终止。join在哪个线程的代码块中被调用，该线程就是主线程；哪个线程调用了join，该线程就是子线程void setDaemon(boolean on);// 设置一个线程为守护线程。当正在运行的线程都为守护线程时，jvm停止运行；该方法必须在线程启动前调用；GC线程是守护线程。void wait();// 线程进入阻塞并释放资源。void notify();// 线程唤醒随机一个阻塞的进程。void notifyAll();// 线程唤醒全部进入阻塞的进程。 安全中断线程线程执行完毕就会中断。但是很多时候我们需要自己控制线程终止，然而API中的stop()方法存在线程不安全问题，所以一般定义一个成员变量boolean flag来控制。 synchronized关键字基本语法 123synchronized(锁对象)&#123; // 对共享数据的访问操作&#125; 锁对象可以是： 任意一个Object及其子类对象，java中的任意对象都可以当锁，都存在wait()、notify()和notifyAll()方法。 this关键字，即是令包含该代码块的类对象当锁。 字节码文件对象(类名.class) Lock类成员方法： 12lock();// 获取锁unlock();// 释放锁 lock是一把真正的锁类，可以让我们看到加锁解锁的过程。 死锁的原因及解决方法原因：一般出现在同步代码块嵌套，因为2个或以上的线程抢夺资源而造成互相等待。 12345678910synchronized(ObjA)&#123; synchronized(objB)&#123; &#125;&#125;synchronized(objB)&#123; synchronized(ObjA)&#123; &#125;&#125; 解决方式： 更改加锁顺序 12345678910synchronized(ObjA)&#123; synchronized(objB)&#123; &#125;&#125;synchronized(ObjA)&#123; synchronized(objB)&#123; &#125;&#125; 再加一把锁，将非原子操作改为原子操作 1234567891011121314synchronized(ObjC)&#123; synchronized(objB)&#123; synchronized(objA)&#123; &#125; &#125;&#125;synchronized(objC)&#123; synchronized(ObjA)&#123; synchronized(objB)&#123; &#125; &#125;&#125; 线程池线程池有三种子类： ExecutorService newCachedThreadPool()：根据需要创建新线程，也可以自动删除，60s处于空闲状态的线程。线程数量可变。 ExecutorService newFixedThreadPool(int nThreads)：线程数量固定，维护一个无界队列（暂存已提交的来不及执行的任务），按照任务的提交顺序，将任务执行完毕。 ExecutorService newSingleThreadExecutor()：单个线程，其他特点如上。 两种成员方法： 12void submit(Runnable task);// 提交任务void shutdown();// 启动顺序关闭 定时任务与定时器Timer定时器是一种工具，线程用其安排以后在后台线程中执行的任务。可安排任务执行一次，或者定期重复执行。 两种构造方法： 12Timer();// 创建一个新计时器Timer(boolean isDaemon);// 创建一个新计时器，可以指定其相关的线程作为守护程序运行 四种成员方法： 1234schedule(TimerTask task, Date time);// 从time时间开始执行。schedule(TimerTask task, long delay, long period);// 在延迟delay毫秒后，每period毫秒执行一次。schedule(TimerTask task, Date firstTime, long period);// 从firstTime时间开始执行，之后每period毫秒执行一次。scheduleAtFixedRate(TimerTask task, long delay, long period);// 设置一个继承了TimerTask类的定时任务类，在延迟delay毫秒后，每period毫秒执行一次该任务。(TimerTask定时任务，使用时继承该类并重写run()方法) UDP&#x2F;TCPUDP发送端步骤： DatagramSocket datagramSocket = new DatagramSocket(int port); 创建发送端的Socket对象 DatagramPacket sendPacket= newDatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port); 创建用于发送的数据报包 datagramSocket.send(sendPacket); 把包发送出去 datagramSocket.close(); 关闭Socket UDP接收端步骤： DatagramSocket datagramSocket = new DatagramSocket(int port); 创建接收端的Socket对象 DatagramPacket receivePacket = new DatagramPacket(byte[] buf, int offset, int length); 创建用于接收的数据报包 datagramSocket.receive(receivePacket); receive方法进行接收 byte[] data = receivePacket.getData(); 解析数据 datagramSocket.close(); 关闭Socket UDP可以通过多线程优化，达到两端互相通信的效果 TCP客户端步骤： Socket socket = new Socket(String host, int port); 创建客户端的socket对象 OutputStream out = socket.getOutputStream(); 从socket中获取输入&#x2F;输出流 out.write(byte[] b); 利用输入&#x2F;输出流进行读写操作 socket.close(); 关闭Socket TCP服务端步骤： ServerSocket serverSocket = new ServerSocket(int port); 创建服务端的ServerSocket 对象 Socket socket = serverSocket.accept(); 利用accept方法建立连接,得到socket对象 InputStream in = socket.getInputStream(); 从socket中获取输入&#x2F;输出流 in.read(byte[] b); 利用输入&#x2F;输出流进行读写操作 socket.close(); 关闭Socket TCP可以通过ObjectInputStream&#x2F;ObjectOutputStream来实现序列化&#x2F;反序列化传输，也可以通过FileInputStream&#x2F;FileOutputStream来实现文件传输。 反射反射时在类运行时获取其信息的一种技术，具体方式是获取字节码文件（也就是.class文件）对象，然后从对象中获取该类的构造器、变量、方法等成员，且能无视修饰符强行访问。 获取字节码的三种方式： 对象.getClass() 类名.class Class.forName(String classname) classname是全类名 因为第三种才能获取较为完整的对象，一般使用第三种。 反射获得构造方法的方式有： 1234Constructor[] getConstructors();// 获取所有public方法Constructor[] getDeclaredConstructors();// 获取所有构造方法，包括privateConstructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes);// 获取单个public方法Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes);// 获取单个构造方法，包括private 获得构造方法后可以创建对象。 Object o = constructor.newInstance(&quot;张三&quot;, 20, true); 如果构造器非public修饰，需要暴力破解。 constructor.setAccessible(true); 反射获得成员变量的方式有： 1234Field[] getFields();// 获取所有public变量Field[] getDeclaredFields();// 获取所有成员变量Field getField(String name);// 获取指定public成员变量Field getDeclaredField(String name);// 获取指定成员变量 获得成员变量后可以给成员变量赋值。 12Object o = declaredConstructor.newInstance();// 实例化对象nameFiled.set(o, &quot;张三&quot;);// 对该对象的名字成员变量赋值 也可以获得某个成员变量。 Object o1 = nameFiled.get(o); 如果成员变量非public修饰，需要暴力破解，方式同上。 反射获得成员方法的方式有： 1234Method[] getMethods();// 获取所有public方法Method[] getDeclaredMethods();// 获取所有方法Method getMethod(String name, Class&lt;?&gt;... parameterTypes);// 获取指定public方法Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes);// 获取指定方法 可以利用Method调用对象方法。 Object invoke(Object obj, Object... args); 第一个是要调用的对象，后面是多个可变参数类型。 Class类API： 1234String getName();// 获取全类名String getSimpleName();// 获取简单名Class&lt;?&gt; getInterfaces();// 获取接口Class&lt;?&gt; getSuperclass();// 获取父类 Field类API： 12Class&lt;?&gt; getType();// 获取变量类型int getModifiers();// 获取变量类型，以int值表示，可用Modifier.toString()转为String Method类API： 12String getReturnType();// 获取返回值类型Class&lt;?&gt;[] getParameterTypes();// 获取方法参数 配置文件配置文件(properties)里有各种配置信息，以键值对方式存储。 配置文件中注释使用#号。 Properties类表示了一个持久的属性集，可以获得配置文件中的数据。 一种构造方法： ​ Properties() 创建一个无默认值的空属性列表 两种成员方法： 12void load(InputStream inStream);// 从输入流中读取属性列表（键和元素对）String getProperty(String key);// 用指定的键在此属性列表中搜索属性"},{"title":"剑指offer-day8","path":"2022/04/18/剑指offer-day8/","text":"斐波那契数列递归经典题目，但是使用传统递归会超时，需要使用优化的记忆递归。 123456789101112131415161718class Solution &#123; public int fib(int n) &#123; // 超出时间限制 // if(n == 0 || n == 1)&#123; // return n; // &#125; // return fib(n-1) + fib(n-2); int a = 0;// a表示f(0) int b = 1;// b表示f(1) int sum = 0; for(int i = 0; i &lt; n; i++)&#123; sum = (a + b) % 1000000007;// sum表示f(2) = f(0) + f(1) a = b;// a向前移动至f(1) b = sum;// b向前移动至f(2) &#125; return a;// 循环结束，a=f(n) &#125;&#125; 青蛙跳台阶其实就是斐波那契数列，只要记住上一题的解法，这道题就是一模一样，只是初始条件改变了。 12345678910111213class Solution &#123; public int numWays(int n) &#123; int a = 1;// f(0) = 1 int b = 1;// f(1) = 1，f(2) = f(0) + f(1) = 2 int sum = 0; for(int i = 0; i &lt; n; i++)&#123; sum = (a+b) % 1000000007; a = b; b = sum; &#125; return a; &#125;&#125; 股票的最大利润这道题用动态规划没有想出来，看了答案才发现原来这么淳朴…大体思路是遍历整个数组，记录一个最低价，如果后面有更低的价格就更新最低价；没有的话就计算差值，差值最大即为答案。 1234567891011class Solution &#123; public int maxProfit(int[] prices) &#123; int cost = Integer.MAX_VALUE; int profit = 0; for(int price : prices)&#123; cost = Math.min(price,cost);// 更新最低价 profit = Math.max(profit,price - cost);// 更新最大差值 &#125; return profit; &#125;&#125;"},{"title":"剑指offer-day7","path":"2022/04/16/剑指offer-day7/","text":"树的子结构大致思路是有的：通过先序遍历来遍历主树，如果有等于子树根节点的节点，再先序遍历比较。 但是实现得磕磕绊绊，没法了，进行一个答案的抄。 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSubStructure(TreeNode A, TreeNode B) &#123;// 遍历A树 if(A == null || B == null)&#123;// A或B为空，返回false return false; &#125; return (compare(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B)); &#125; public boolean compare(TreeNode A,TreeNode B)&#123;// 比较B树 if(B == null)&#123;// 如果先序遍历完成，返回true return true; &#125; if(A == null || (A.val != B.val))&#123;// 如果A树为空或者两数节点不相等，返回false return false; &#125; return (compare(A.left,B.left) &amp;&amp; compare(A.right,B.right));// 两数节点相等，再先序遍历比较其左节点和右节点 &#125;&#125; 感觉递归的结束条件确实很难想。 二叉树的镜像直接摆烂看答案 1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode mirrorTree(TreeNode root) &#123; if(root == null)&#123;// 遍历至子节点返回null return null; &#125; TreeNode tmp = root.left; root.left = mirrorTree(root.right); root.right = mirrorTree(tmp); return root; &#125;&#125; 可以发现这道题目其实跟交换数字的思路很像，可以靠这个来记忆。 对称二叉树跟第一题很像，都是需要遍历比较。 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root == null)&#123;// root为空返回true return true; &#125; return compare(root.left,root.right); &#125; public boolean compare(TreeNode left, TreeNode right)&#123;// 遍历比较两个节点 if(left == null &amp;&amp; right == null)&#123;// 两个节点同时遍历完毕，说明对称，返回true return true; &#125; if(left == null || right == null || left.val != right.val)&#123;// 其中一个节点先遍历完毕或两节点不相等，返回false return false; &#125; return(compare(left.left,right.right) &amp;&amp; compare(left.right,right.left)); &#125; &#125;"},{"title":"剑指offer-day6","path":"2022/04/14/剑指offer-day6/","text":"从上到下打印二叉树经典题目，使用层序遍历来实现，具体实现方法就是用一个队列来记录节点，一个ArrayList记录答案。当前节点入队后，再将其左右节点入队，随后出队，ArrayList记录节点的值，直至队列为空。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int[] levelOrder(TreeNode root) &#123; LinkedList&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); q.add(root);// 将根节点入队 TreeNode t; while((t = q.peek()) != null)&#123;// 队头为空跳出 if(t.left != null)&#123;// 左节点入队 q.add(t.left); &#125; if(t.right != null)&#123;// 右节点入队 q.add(t.right); &#125; res.add(q.poll().val);// 取出队头获得其值 &#125; int[] arr = new int[res.size()]; for(int i = 0; i&lt;res.size(); i++)&#123;// ArrayList转数组 arr[i] = res.get(i); &#125; return arr; &#125;&#125; 从上到下打印二叉树Ⅱ上一题的变种，加入了对当前层数的判断，需要在之前的代码上做一些修改，主要是用一个int值记录当前层数中的节点数。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); if(root != null)&#123; q.add(root); &#125; while(q.size() != 0)&#123; int i = q.size();// 记录当前层数的节点数 List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); while(i &gt; 0)&#123; TreeNode t = q.poll(); tmp.add(t.val); if(t.left != null)&#123; q.add(t.left); &#125; if(t.right != null)&#123; q.add(t.right); &#125; i--; &#125; res.add(tmp); &#125; return res; &#125;&#125; 从上到下打印二叉树Ⅲ究极加强版，在上一题的基础上加上了蛇形遍历，其实就是需要对层数的奇偶进行判断，而且需要把临时队列tmp更改为双端队列，当层数为奇时从尾部插入，反之从头部插入 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); if(root != null)&#123; q.add(root); &#125; while(q.size() != 0)&#123; int i = q.size(); LinkedList&lt;Integer&gt; tmp = new LinkedList&lt;&gt;(); while(i &gt; 0)&#123; TreeNode t = q.poll(); if(res.size() % 2 == 0)&#123;// 层数判断 tmp.addLast(t.val); &#125; else&#123; tmp.addFirst(t.val); &#125; if(t.left != null)&#123; q.add(t.left); &#125; if(t.right != null)&#123; q.add(t.right); &#125; i--; &#125; res.add(tmp); &#125; return res; &#125;&#125;"},{"title":"剑指offer-day5","path":"2022/04/13/剑指offer-day5/","text":"二维数组中的查找一开始就想到了线性查找，但是是从左上方开始的，发现判定条件不好写后看了看答案，才知道从右上方开始会比较方便（即大于查找值向左移，小于查找值向下移） 提交几次都发现会有边界溢出的情况，无奈只能跟答案一一对照，发现答案事先用了一个int值接住了要判断的值，这样就不会发生边界溢出了。 12345678910111213141516171819202122class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; if(matrix.length == 0)&#123; return false; &#125; int m = 0;// 行数 int n = matrix[0].length - 1;// 列数 while(n &gt;=0 &amp;&amp; m &lt; matrix.length)&#123; int num = matrix[m][n];// 用一个int表示当前值，防止边界溢出 if(num == target)&#123; return true; &#125; if(num &gt; target)&#123; n--; &#125; if(num &lt; target)&#123; m++; &#125; &#125; return false; &#125;&#125; 旋转数组的最小数字不想多说了，就是二分法，重点是怎么设定跳出条件，不然就是寄（是的，我又没做出来） 1234567891011121314// 将数组划分成旋转的和未旋转的// 左指针指向未旋转数组的最后一个元素，右指针指向旋转数组的第一个元素class Solution &#123; public int minArray(int[] numbers) &#123; int i = 0, j = numbers.length - 1; while (i &lt; j) &#123; int m = (i + j) / 2; if (numbers[m] &gt; numbers[j]) i = m + 1;// 说明m还在未旋转数组中，左指针指向m的下一个元素 else if (numbers[m] &lt; numbers[j]) j = m;// 说明m在旋转数组中，右指针指向m else j--;// m正好指向与旋转数组第一个元素相等的元素，右指针左移至与左指针重合 &#125; return numbers[i]; &#125;&#125; 第一个只出现一次的字符一开始就把题目想错了，以为类似为**&quot;aadadaad&quot;**的字符应该返回为空，但是实际上是返回a（a、d两两配对，第一个只剩一个的字母是a） 这道题应该是用哈希表解决的，放出代码。 1234567891011class Solution &#123; public char firstUniqChar(String s) &#123; HashMap&lt;Character, Boolean&gt; dic = new HashMap&lt;&gt;(); char[] sc = s.toCharArray(); for(char c : sc) dic.put(c, !dic.containsKey(c));// 没有则修改为true，有则改为false for(char c : sc) if(dic.get(c)) return c; return &#x27; &#x27;; &#125;&#125;"},{"title":"剑指offer-day4","path":"2022/04/11/剑指offer-day4/","text":"数组中重复的数字最简单的思路当然是使用哈希表来记录重复数，老老实实的写了。 123456789101112131415161718192021class Solution &#123; public int findRepeatNumber(int[] nums) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i : nums)&#123; if(map.containsKey(i))&#123; map.put(i,map.get(i)+1); &#125; else&#123; map.put(i,1); &#125; &#125; int res = 0; for(int i : nums)&#123; if(map.get(i) &gt; 1)&#123; res = i; break; &#125; &#125; return res; &#125;&#125; 结果发现这时空复杂度也太高了…愤而看官方解，发现它也是这么写的…只不过优化了一下过程。 发现自己两年前居然做过这道题，而且时空复杂度都比我现在的优秀，看了一眼： 12345678910class Solution &#123; public int findRepeatNumber(int[] nums) &#123; Arrays.sort(nums); for(int i = 1; i &lt; nums.length;i++)&#123; if(nums[i] == nums[i-1]) return nums[i]; &#125; return 0; &#125;&#125; …也不知道是聪明还是偷懒，利用了题目中 长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内 的条件，自作聪明地用排序来解决问题，不过这应该也算是另辟蹊径吧… 但这道题的最优解还真是利用了这个条件，因为数组内的数不会超过下标值，所以可以利用值对应下标的方法来检测是否有重复，即数字0交换至对应下标0，以此类推，直到交换值和被交换的值相等，说明这个值是重复值。 12345678910111213141516class Solution &#123; public int findRepeatNumber(int[] nums) &#123; int i = 0; while(i &lt; nums.length) &#123; if(nums[i] == i) &#123;// 如果值一开始就对应，则跳过该次循环 i++; continue; &#125; if(nums[nums[i]] == nums[i]) return nums[i];// 交换值和被交换的值相等，说明这个值是重复值 int tmp = nums[i];// 交换两个值 nums[i] = nums[tmp]; nums[tmp] = tmp; &#125; return -1; &#125;&#125; 在排序数组中查找数字 Ⅰ遍历的方法最简单也是最low的，放一个二分法的答案吧。 1234567891011121314151617181920212223class Solution &#123; public int search(int[] nums, int target) &#123; // 搜索右边界 right int i = 0, j = nums.length - 1; while(i &lt;= j) &#123; int m = (i + j) / 2; if(nums[m] &lt;= target) i = m + 1; else j = m - 1; &#125; int right = i; // 若数组中无 target ，则提前返回 if(j &gt;= 0 &amp;&amp; nums[j] != target) return 0; // 搜索左边界 right i = 0; j = nums.length - 1; while(i &lt;= j) &#123; int m = (i + j) / 2; if(nums[m] &lt; target) i = m + 1; else j = m - 1; &#125; int left = j; return right - left - 1; &#125;&#125; 0~n-1中缺失的数字想了很久的二分，但是跳出条件总是写不出，怒而写出暴力解，直接遍历查询。 跟上题一样，还是放出二分的答案吧。 1234567891011121314// 将数组分为两部分：nums[i] == i，nums[i] != i// 用i记录前一数组的最后一个元素，j记录后一数组的第一个元素// 以i &lt;= j来作为跳出条件class Solution &#123; public int missingNumber(int[] nums) &#123; int i = 0, j = nums.length - 1; while(i &lt;= j) &#123; int m = (i + j) / 2; if(nums[m] == m) i = m + 1; else j = m - 1; &#125; return i; &#125;&#125; 感觉静不下心来想二分，都是怎么简单怎么来了，看来得好好练一下二分。"},{"title":"学习总结（2022.04.07-2022.04.11）","path":"2022/04/09/学习总结（2022-04-07-2022-04-11）/","text":"String常量池每次创建字符串常量时，JVM会检查常量池是否存在该常量，如果存在则直接返回该常量的实例引用，没有才会在常量池中创建该常量对象。 例子 123String s1 = &quot;abc&quot;;String s2 = &quot;abc&quot;;System.out.println(s1 == s2)// ==是判断两个引用是否指向同一对象，返回true String两种实例化方式的区别 直接赋值的方式 String s = &quot;abc&quot;; 通过构造方法 String s = new String(&quot;abc&quot;) 第一种只会创建一个对象，第二种则会创建两个对象：一个是与第一种相同的创建方式，一个则是因为new关键字而创建的。虽然两者并不是同一个对象，但它们共用一个value数组（即String类中的char数组）（如果常量池中早已有第0，一种方式创建好的对象，那么第二种方式也只会创建一个对象，即new关键字创建的对象） 第一种会在常量池中创建对象，第二种会在堆上创建对象。 字符串拼接字符串拼接时有两种情况： 在常量池中创建新的对象 在堆上创建新的对象 这两个对象并不是同一个对象，用&#x3D;&#x3D;判别会返回false。 只要拼接的字符串中有一个是以引用变量的形式出现的（比如String s、new String(&quot;abc&quot;)）那么该字符串就是在堆上创建对象。只有拼接时都是以直接赋值的方式创建时，才会在常量池中创建对象（若常量池中已存在拼接后的对象，则不会创建新的，而是使引用指向该对象） 自然排序一般使用Comparable接口和Comparator接口实现。 Comparable接口一般在希望能实现排序的类中实现，通过重写compareTo()方法来达到排序的效果。 a1.compareTo(a2)的返回值若大于0，说明a1对象大于a2，a1排在后面；小于0，说明a1对象小于a2，a1排在前面；等于0则说明a1等于a2。 重写后可以通过Arrays.sort()或Collections.sort()进行自动排序。 Comparator接口一般用于匿名内部类排序，相比Comparable接口更加灵活，依赖于带比较器的Arrays.sort(T[] a, Comparator&lt;? super T&gt; c) ，排序规则跟Comparable接口相同。 示例： 1Arrays.sort(students,(stu1,stu2)-&gt;stu1.getAge() - stu2.getAge());// 根据学生年龄排序 StringBuffer，StringBuilder都是长度可变的字符串类，StringBuilder线程不安全，StringBuffer线程安全。 throws，throwthrows用在方法声明后面，跟的是异常类名；可以跟多个异常类名，用逗号隔开。 throws表示出现异常的一种可能性，并不一定会发生这些异常，且throws修饰的方法由该方法的调用者来处理。 throw用在方法体内，跟的是异常对象名，只能抛出一个异常对象。 throw表示抛出异常，可以由方法体内的语句处理，但执行throw则一定抛出了某种异常。 自定义异常可以自己写一个类并继承Exception 或RuntimeException 来自定义异常。 示例： 123456789101112131415161718192021222324252627282930313233class MyException extends Exception&#123; public MyException() &#123; &#125; public MyException(String message) &#123; super(message); &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; try &#123; func(); &#125; catch (MyException e) &#123; e.printStackTrace(); &#125; &#125; private static void func() throws MyException&#123; // 创建scanner对象 Scanner scanner = new Scanner(System.in); // 输入一个分数 System.out.println(&quot;请输入一个分数&quot;); String score = scanner.nextLine(); int i = Integer.parseInt(score); // 判断一下分数是否满足我们的要求 if (i &lt; 0 || i &gt; 100) &#123; // 认为成绩异常的 // 抛出异常 throw new MyException(&quot;分数异常&quot;); &#125; &#125;&#125; 路径表示对于类 UNIX 平台，绝对路径名的前缀始终是 “&#x2F;“。相对路径名没有前缀。表示根目录的绝对路径名的前缀为 “&#x2F;“ 且名称序列为空。​ 绝对路径： &#x2F;home&#x2F;st&#x2F;6379.conf​ 相对路径： st&#x2F;a.txt​ 根目录： &#x2F; 对于 Microsoft Windows 平台，包含盘符的路径名前缀由驱动器号和一个 “:” 组成。如果路径名是绝对路径名，还可能后跟 “\\“​ 绝对路径： e:\\st\\a.txt​ 相对路径：没有盘符前缀 st\\a.txt 文件过滤器FileFilter接口可以用于实现文件的高级获取功能，通过设置条件来过滤文件，常用匿名内部类实现。 示例： 12File[] files = dir.listFiles((pathname) -&gt; pathname.getName().endsWith(&quot;.java&quot;));// 过滤后缀名为.java的文件"},{"title":"剑指offer-day3","path":"2022/04/09/剑指offer-day3/","text":"替换空格一看到这道题我就优雅地敲下代码 12345class Solution &#123; public String replaceSpace(String s) &#123; return s.replace(&quot; &quot;,&quot;%20&quot;); &#125;&#125; …咳咳，大佬说过，不要成为API Coder，不然35岁就去开滴滴了。 但其实思路还是很简单，因为java的特性，字符串不能被直接修改，只能创建一个新对象，所以在空间复杂度上是怎么都干不过C++的。那么就新建一个可变字符串对象StringBuffer来接收修改后的String对象，可以最大程度优化空间。（其实可以替换为StringBulider，但是在本题中没有明显的优化） 123456789101112131415161718class Solution &#123; public String replaceSpace(String s) &#123; if(s == null || s == &quot;&quot;)&#123; return null; &#125; StringBuilder res = new StringBuilder(); for(int i = 0; i &lt; s.length(); i++)&#123; if(s.charAt(i) == &#x27; &#x27;)&#123; res.append(&quot;%20&quot;); &#125; else&#123; res.append(s.charAt(i)); &#125; &#125; return res.toString(); // return s.replace(&quot; &quot;,&quot;%20&quot;); &#125;&#125; 最后吐槽一下，自己写的方法时空复杂度甚至还没有包装好的replace()低…这道题可能只是单纯用来折磨C++程序员的吧… 左旋转字符串一看到这我又优雅地敲下代码 12345class Solution &#123; public String reverseLeftWords(String s, int n) &#123; return s.substring(n, s.length()) + s.substring(0, n); &#125;&#125; 没想到这么写居然是对的，而且还是最优解… 当然，我一开始并不是这么写的，而是仿造796.旋转字符串的解来写的，用一个字符串来接收两个拼接起来的目标字符串，再返回其中与目标字符串等长的结果字符串。 123456class Solution &#123; public String reverseLeftWords(String s, int n) &#123; String s1 = s + s; return s1.substring(n,s.length() + n); &#125;&#125; 空间复杂度当然没有API好，毕竟自创了一个字符串。 （今天题目挺水的，不过周末了，就放过我吧）"},{"title":"剑指offer-day2","path":"2022/04/08/剑指offer-day2/","text":"从尾到头打印链表简单题，但是实现方法与答案有些不同。 我考虑的是用一个ArrayList来记录链表中的值，最后逆序赋值给一个int数组。答案用的是模拟栈的LinkedList。我尝试了两个方法，发现时空复杂度并没有什么变化，所以就放上自己的答案吧。 12345678910111213141516171819202122/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int[] reversePrint(ListNode head) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(head != null)&#123; list.add(head.val); head = head.next; &#125; int[] res = new int[list.size()]; for(int i = 0; i &lt; list.size(); i++)&#123; res[i] = list.get(list.size() - i - 1); &#125; return res; &#125;&#125; 反转链表经典题目了，但是发现自己死活做不出来，总是有空指针异常，一看答案发现语句顺序错了…但总体思路是对的。利用三个指针来指向前元素、现元素和后元素，然后进行反转操作，操作顺序为： next指针指向当前元素的后一个元素 cur指向的当前元素的指针改为指向pre pre改为指向cur指向的元素 cur改为指向next指向的元素 唯一要注意的点是next指针需要在循环内创建，否则在链表本身为空时会报空指针。 1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head)&#123; ListNode pre = null; ListNode cur = head; while(cur != null)&#123; ListNode next = cur.next;// next指针指向后元素 cur.next = pre;// cur的指针改为指向pre pre = cur;// pre改为指向cur指向的元素 cur = next;// cur改为指向next指向的元素 //next = cur.next;// 自己写的报空指针，不能写在后面，因为当cur在尾指针null时，无法获取next &#125; return pre; &#125;&#125; 之前有想过同上一题目一样，用一个辅助栈来完成反转，看了答案发现这样做并没有三指针快，就放弃这个思路了。 复杂链表的复制完全不会做，选择睡大觉（恼） 好好看了看答案，大概知道思路是怎样的，复述一下。 有两种解法：辅助哈希表和拼接链表，因为后者在空间复杂度上优于前者，所以使用后者。 因为random节点的存在，导致复制时指针可能指向一个还没有创建的节点，所以可以将原链表两倍拉长，使原链表节点先指向复制节点，复制节点再指向原链表的下一个节点。完成复制后进行random节点的指向初始化，通过原节点的信息来让复制节点的指向正确的节点。最后将链表拆开，复制完成。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*// Definition for a Node.class Node &#123; int val; Node next; Node random; public Node(int val) &#123; this.val = val; this.next = null; this.random = null; &#125;&#125;*/class Solution &#123; public Node copyRandomList(Node head) &#123; if(head == null) return null;// 空链表返回空 Node cur = head; // 1. 复制各节点，并构建拼接链表 while(cur != null) &#123; Node tmp = new Node(cur.val);// 新建复制节点，复制原节点的值 tmp.next = cur.next;// 复制节点的指针指向原节点的下一个元素 cur.next = tmp;// 原节点的指针指向复制节点 cur = tmp.next;// cur改为指向复制节点的下一节点，即原链表的下一节点 &#125; // 2. 构建各新节点的 random 指向 cur = head; while(cur != null) &#123; if(cur.random != null) cur.next.random = cur.random.next;// cur.next是复制节点，说明将复制节点的random指针指向原节点的random指针指向的节点的下一个节点，即也是复制节点 cur = cur.next.next;// 跳到原链表的下一个节点 &#125; // 3. 拆分两链表 cur = head.next; Node pre = head, res = head.next; while(cur.next != null) &#123; pre.next = pre.next.next;// 原节点的指针指向原链表的下一个节点 cur.next = cur.next.next;// 复制节点的指针指向复制链表的下一个节点 pre = pre.next;// 跳到原链表的下一个节点 cur = cur.next;// 跳到复制链表的下一个节点 &#125; pre.next = null; // 单独处理原链表尾节点 return res; // 返回新链表头节点 &#125;&#125;// 作者：jyd// 链接：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/jian-zhi-offer-35-fu-za-lian-biao-de-fu-zhi-ha-xi-/// 来源：力扣（LeetCode）// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 可以发现自己对链表还不够熟练，这道题要多加练习。"},{"title":"剑指offer-day1","path":"2022/04/07/剑指offer-day1/","text":"用两个栈实现队列简单且经典的题目，用两个栈来模拟一个队列。 设置两个栈s1和s2，s1用于正常模拟队列的进队。当队列需要出队时，要把是s1中的值依次放入s2，再在s2的栈顶删除s1的栈底元素（也就是队列的队头元素），然后将处理后的元素再依次放入s1中，就模拟了队列的出队过程。 此时需注意：删除元素应该有判空条件。 12345678910111213141516171819202122232425262728class CQueue &#123; Stack&lt;Integer&gt; s1;// 新建两个栈 Stack&lt;Integer&gt; s2; public CQueue() &#123;// 初始化 s1 = new Stack&lt;&gt;(); s2 = new Stack&lt;&gt;(); &#125; public void appendTail(int value) &#123;// 模拟进队 s1.push(value); &#125; public int deleteHead() &#123;// 模拟出队 if(s1.empty())&#123; return -1; &#125; while(!s1.empty())&#123; s2.push(s1.pop()); &#125; int res = s2.pop();// 需要出队的元素 while(!s2.empty())&#123; s1.push(s2.pop()); &#125; return res; &#125;&#125; 看评论说java的stack类会造成速度变慢，可以用LinkedList做容器，但是会不符合题目要求，可以作为优化的一种选项。 包含min函数的栈原本是简单题，但是因为自己想的太复杂了，迟迟没有做出来，参考了一下答案，才把思路理清（👎） 设置一个辅助栈supStack，用于记录主栈入栈操作时栈内的最小值。第一个入主栈的自然要记录，此后若有小于或等于辅助栈栈顶的数，则需要辅助栈将一个相同的数放入栈顶，反之则不用操作。出栈时则需要与辅助栈的栈顶比对，若相等则辅助栈也必须出栈。 123456789101112131415161718192021222324252627282930class MinStack &#123; Stack&lt;Integer&gt; mainStack;// 主栈 Stack&lt;Integer&gt; supStack;// 辅助栈 /** initialize your data structure here. */ public MinStack() &#123;// 初始化 mainStack = new Stack(); supStack = new Stack(); &#125; public void push(int x) &#123; mainStack.push(x); if(supStack.empty() || supStack.peek() &gt;= x)&#123;// 辅助栈空或大于等于要放入的值时，需放入一个同样的值 supStack.push(x); &#125; &#125; public void pop() &#123; if(mainStack.pop().equals(supStack.peek()))&#123;// 当出栈值与辅助栈栈顶相等时，辅助栈也要出栈 supStack.pop(); &#125; &#125; public int top() &#123;// 查看主栈的栈顶 return mainStack.peek(); &#125; public int min() &#123;// 查看辅助栈的栈顶 return supStack.peek(); &#125;&#125; 需要注意的是，pop()中需要使用equals方法而不是==，因为在Integer中，[-128,127]会被缓存记住，只有在这个范围内==才是比较数值，否则比较的是对象，会造成错误。 记忆点1234567// Java Stack类boolean empty();// 判断栈是否为空Object peek();// 返回栈顶Object pop();// 返回并删除栈顶Object push(Object element);// 在栈顶添加新元素int search();// 查找s内的值，返回其在栈内的位置，以1为基数"},{"title":"学习总结（2022.03.31-2022.04.06）","path":"2022/04/06/学习总结（2022-03-31-2022-04-06）/","text":"继承的限制 子类不可以继承父类的私有成员，因为没有访问权限。 子类不可以继承父类的构造器，因为构造器不能算成员。 子类可以访问父类的静态方法，但是并不是继承。 继承中的属性隐藏和方法覆盖对于成员变量的访问范围和访问结果都看引用类型。引用是父类则访问的是父类成员变量，子类则访问子类成员变量。 对于成员方法的访问范围如上相同，看引用类型。 对于成员方法的访问结果则看对象类型。对象是子类则可以调用子类方法、重写或没重写的父类方法，父类则只能调用父类方法。 final关键字final修饰类表示类不可被继承。 final修饰方法表示方法不可被重写，但可以被继承。 final修饰变量表示常量。与static一起用表示全局变量。 instanceof关键字用来判断一个类是否是某个类的子类，一般用于保证向下转型的安全。 抽象类（abstract）抽象类与普通类相同，但是多了一个抽象方法，即不需要实现该方法，而是让子类通过重写的方式来实现。抽象类和抽象类之间可以有继承关系，且继承的抽象类可以选择重写被继承抽象类的抽象方法。 接口（interface）接口是一种开发标准，表示对功能的扩展，只关注行为而不关注属性。一般用来抽象共性行为，与实现其的类为like-a关系。 接口不能创建对象，自然也没有构造器。 接口一般没有成员，只有抽象方法。 接口可以继承接口，但是接口和类之间不能发生继承，类只能实现(implement)接口。 内部类 成员内部类：与普通类相同，但是没有静态声明（允许有静态全局常量）；可以发生继承和实现；与外围类有强依赖关系，可以无视访问权限互相访问。 静态内部类：与普通类完全相同；可以发生继承和实现；与外围类为互相独立的关系，虽然访问不受访问权限限制，但是需要创建对象才可以访问。 局部内部类：不具有访问修饰权限；不具有静态声明；可以发生继承和实现；虽然可以访问外部类的成员，但是外部类无法访问局部内部类的成员。 Lambda表达式Lambda表达式是一种特殊的局部匿名内部类。必须在一个实现了功能接口（有且只有一个必须实现的抽象方法的接口）的类中定义。得到的是这个接口的子类对象。基本格式为： 123(形参列表) -&gt; &#123;// 方法体&#125; ()中是抽象方法的形参列表。 {}中是抽象方法的实现。 在写完Lambda表达式后，需要在表达式前面用(对象名)帮编译器明确对象类型。 Lambda表达式可以简化：当形参只有一个时，可以省略()；当方法体只有一条语句时（包括return语句），可以省略{}。 Lambda表达式的应用：将一个String对象数组映射为所有字符串长度的数组。 1234567891011121314151617181920212223242526/** * @author yzw * @since 2022/04/02 */public class HomeworkImpl &#123; public static void main(String[] args) &#123; String[] s = &#123;&quot;aaa&quot;,&quot;bb&quot;,&quot;c&quot;&#125;;// 实验数组 int[] sLength = mappingObjectLength(s,o -&gt; new int[s.length]);// mapping返回int数组 for(int i : sLength)&#123; System.out.println(i); &#125; &#125; public static int[] mappingObjectLength(Object[] obj, Map map)&#123; int[] result = map.mapping(obj); for (int i = 0; i &lt; obj.length; i++) &#123; result[i] = obj[i].toString().length(); &#125; return result; &#125;&#125;interface Map&#123; int[] mapping(Object o); //返回一个int数组表示每个元素的长度 Object.toString()toString()直接使用是打印对象的全限定类名 + @ + 对象的十六进制地址值。 可以通过重写来展示对象的状态。 Object.equals()和Object.hashcode()equals()直接使用是比较两个引用是否指向相同对象，可以通过重写来修改判断的条件（比如从比较对象的地址修改为比较对象的状态）。 重写遵从闭包原则，即 自反性。x.equals(x) == true 排他性。当比对的不是同种类型的对象或者是一个null时，默认返回false。 对称性。x.equals(y) == true -&gt; y.equals(x) == true。 传递性。x.equals(y) == true &amp;&amp; y.equals(z) == true -&gt; x.equals(z) == true。 其中自反性和排它性需要写代码做判断，而对称性，一致性，传递性，只需要用成员变量的取值来判断对象相等，就自动满足它们。 排他性的选择：getClass()（只能是相同的对象），instanceof（可以是对象的子类） 如果重写equals()，hashcode()也需要重写。因为逻辑上相等的两个对象必须有相同的hash值。 Object.clone()作用是获得一个独立的，与原对象成员一致的新对象。但是在默认的情况下，只能在子类内克隆自己，所以一般需要在类中重写该方法。其次，一个类想实现克隆，需要实现一个标记接口（不含任何抽象方法的接口）java.lang.Cloneable。 浅克隆：如果克隆的类中有引用类型变量，在克隆后该变量会与克隆前的类中的变量指向同一个对象，这样并不能说明这两个类是独立的，这叫做浅克隆。 深度克隆：在clone()中做出如下操作： 将引用指向的对象，也克隆一份。 然后让克隆后的引用指向它。 可以让克隆后的引用类型变量指向一个同样被克隆的新的对象，这样就实现了深度克隆。 示例代码： 123456789101112131415161718class Student&#123; Dog d; //重写clone方法的访问权限 @Override protected Student clone() throws CloneNotSupportedException &#123; //仍然选择调用父类默认实现 //深度克隆的步骤 //1.深度克隆是在浅克隆基础上完成的 Student cloneStu = (Student) super.clone(); //2.需要把Dog对象克隆一份 Dog cloneDog = cloneStu.d.clone(); //3.将拷贝引用指向拷贝对象 cloneStu.d = cloneDog; return cloneStu; //return ((Student) super.clone()); &#125;&#125;"},{"title":"学习总结（2022.03.21-2022.03.30）","path":"2022/04/06/学习总结（2022-03-21-2022-03-30）/","text":"JVM内存 JVM栈。方法执行时占用的内存空间，方法以栈帧形式存储，方法内的局部变量会直接存储在栈帧中，方法执行完毕后出栈销毁，局部变量也被销毁。 堆。存储对象。new关键字即是在堆上开辟空间给对象。当没有引用指向对象时，该对象会被垃圾回收器执行垃圾回收机制(GC)回收内存。 方法区。 本地方法栈。存储JVM的本地(native)方法。 程序计数器：记录当前执行的行数。 传参问题java是值传递，指调用方法时，传入的是实参的拷贝而不是实参本身。 所以下列代码是不可能得出a的两倍的。 123public static void sendIntValue(int a) &#123; a *= 2;&#125; 但是对引用数据类型而言，因为声明的是引用的拷贝，所以内存地址也是会被拷贝的。对引用数据类型进行修改，本身的引用不会发生改变，但是引用和引用的拷贝所指向的对象发生了改变。 所以下列代码b的后面是会加上.zip的。 123public static void sendStringtValue(String b) &#123; b += ”.zip“;&#125; 因为此时b和b的拷贝指向了新的对象b+.zip。 看起来似乎是引用传递，但是下列代码是一个反例。 123456public static void swapArray(int[] arr1,int[] arr2)&#123; int[] temp; temp = arr1; arr1 = arr2; arr2 = temp;&#125; 交换两个拷贝的值，其实就是在交换它们指向的对象，而原先的引用不受影响。在方法结束后，两个拷贝被销毁，交换失败。 类加载JVM认识一个我们创建的类，叫类加载。类加载在一次程序运行中只有一次，且类加载是懒加载的，一些场景会触发类加载，称为类加载的时机，有以下几种： 创建该类对象（new一个对象） 启动该类的main方法 访问某个类的静态成员（包括变量和方法） 子类类加载会触发父类类加载 static修饰的成员是随着类加载完毕就存在的，所以不需要创建对象就可以访问。 创建对象也不依赖于类加载。 类生命周期 类加载过程的三个步骤：加载，连接，初始化 加载主要是将class字节码读取进JVM 连接主要是将静态成员变量进行默认初始化，保证其永远最先进行。 初始化主要执行static相关的内容，包括为静态成员变量赋值，以及执行静态代码块。 成员变量的赋值方式和顺序 默认初始化 显式赋值 构造代码块 构造器赋值 其中默认初始化和构造器赋值永远是第一步和最后一步（掐头去尾） 创建对象过程中结构执行顺序（全） 类加载。首先程序要从有main方法的类中开始执行，所以要先对其进行类加载。（要考虑发生连环类加载的情况，首先有父类存在的话要先执行父类类加载，其次有静态成员变量或者静态代码块创建对象的话要先执行该对象的类加载） 执行静态成员变量的初始化。（包括显式赋值和静态代码块） 创建对象。首先找到对象的构造器，如果有显式调用其他构造器，则跳转至该构造器的类，执行构造代码块和显式赋值，最后执行该构造器。如果没有，则是跳转至父类的无参构造器（无父类则是跳转至Object，但是不影响），执行父类的构造代码块和显式赋值。"},{"title":"Github+hexo搭建博客遇到的坑","path":"2022/04/05/github+hexo搭建博客遇到的坑/","text":"hexo部署问题按照教程部署完后发现页面仍旧没法更改，折腾大半天后发现github最近将默认分支的名字从master改成了main，而_config.yml中一般都将branch设置为master，导致master成为了副分支，github pages默认应用主分支main，所以没法更改页面（所以说政治正确真是害死人…大家约定俗成的事说改就改） 部署慢问题还没有发现问题所在，大概只能理解成访问github困难导致即使push成功网页也会刷新不及时。 图片CDN问题nexmoe主题中的图片使用CDN保存，所以无法使用本地路径，但是图片也不能直接保存至username.github.io中，因为每次push都会导致仓库中保存的图片被删，所以在github中新建了一个仓库用来保存图片。 评论系统gitment已经停止使用！请用gitalk替代。"},{"title":"Hello World","path":"2022/04/05/hello-world/","text":"我的第一篇博客！希望可以一直用下去。"}]