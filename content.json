[{"title":"学习总结（2022.06.15-2022.06.24）","path":"2022/07/04/学习总结（2022-06-15-2022-06-24）/","text":"动态代理JDK动态代理JDK动态代理是基于Java的反射机制实现的，使用jdk中的接口和类实现代理对象的动态创建，但是要求代理对象必须实现接口。 JDK动态代理的实现步骤如下。 新建一个接口，作为目标接口。 1234public interface UserService &#123; public void sayHello();&#125; 为接口创建实现类。 12345678public class UserServiceImpl implements UserService&#123; @Override public void sayHello() &#123; System.out.println(&quot;hello spring&quot;); &#125; &#125; 创建一个类实现InvocationHandler接口及其invoke方法，在method.invoke()前后执行对方法的增强。 123456public class CustomInvocationHandler implements InvocationHandler &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return null; &#125;&#125; 在main方法中调用Proxy.newProxyInstance()创建JDK动态代理，使用代理对象执行方法。 1234567891011121314151617181920@Testpublic void mytest4() &#123; UserService instance = new UserServiceImpl(); // instance 👉 method.invoke(instance,args); // UserServiceImpl 👉 sayHello // Proxy 👉 sayHello UserService userServiceProxy = (UserService) Proxy.newProxyInstance(UserServiceImpl.class.getClassLoader(), UserServiceImpl.class.getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //jdsfkhjasdjyr System.out.println(&quot;jdsfkhjasdjyr&quot;); Object invoke = method.invoke(instance, args); //dfjkasdhjfisdya System.out.println(&quot;dfjkasdhjfisdya&quot;); return invoke; &#125; &#125;); userServiceProxy.sayHello();//invocationHandler.invoke &#125; Cglib动态代理Cglib动态代理只针对类实现代理，不需要实现接口。 Cglib动态代理的实现步骤如下。 创建一个类实现MethodInterceptor接口及其intercept方法。 12345678910111213141516171819public class MyMethodInterceptor implements MethodInterceptor &#123; /** * cglib * * @param o cglib生成的代理对象 * @param method 被代理对象的方法 * @param objects 方法入参 * @param methodProxy 代理方法 * @return * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;before advice...&quot;); Object object = methodProxy.invokeSuper(o, objects); System.out.println(&quot;after advice...&quot;); return object; &#125;&#125; 在main方法中，通过Enhancer获取代理对象。 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; //通过CGLIB动态代理获取代理对象的过程 Enhancer enhancer = new Enhancer(); //设置enhancer对象的父类 enhancer.setSuperclass(HelloService.class); //设置enhancer的回调对象 enhancer.setCallback(new MyMethodInterceptor()); //创建代理对象 HelloService proxy = (HelloService) enhancer.create(); //通过代理对象调用目标方法 proxy.sayHello(); &#125;&#125; IOC&#x2F;DIIOC，控制反转，将生成实例的控制权交由Spring容器，容器只控制实例的生成，而开发人员只需要往容器中注册需要生成实例的类，即组件，并在需要时取出该组件的对象即可。 DI，依赖注入，即具体的IOC实现方式。一般通过配置文件和注解来完成依赖注入。 XML在Spring的XML文件中注册组件。 123456789101112131415&lt;!--注册组件 → 提供信息 → 向容器中放入实例--&gt;&lt;!--id属性：组件在容器中的唯一标识 → 可以省略--&gt;&lt;!--class属性：组件的全限定类名--&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.cskaoyan.dao.UserDaoImpl&quot;/&gt;&lt;!--set方法来维护组件之间的关系--&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.cskaoyan.service.UserServiceImpl&quot;&gt; &lt;!--property标签的name属性 → set方法--&gt; &lt;!--ref属性：reference → 容器中的组件id--&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;orderService&quot; class=&quot;com.cskaoyan.service.OrderServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;&lt;/bean&gt; 取出组件。 123456789101112131415@Testpublic void mytest1() &#123; // 初始化Spring容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application.xml&quot;); // 通过id取出组件 UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); // 通过类型取出组件byType → class 可以写接口、实现类 → 该类型的组件在容器中只有一个 // 建议用接口 UserService userService1 = applicationContext.getBean(UserService.class); UserService userService2 = applicationContext.getBean(UserServiceImpl.class); // 通过id和类型共同取出 OrderService orderService = applicationContext.getBean(&quot;orderService&quot;, OrderService.class);&#125; 注解也可以使用注解注册组件。可以在注解中指定组件id，也可以使用默认的组件id，默认id一般为类名的首字母小写。 1234567891011// 通用注解@Component// service层@Service// dao层@Repository// controller层@Controller 配置类在一个类上加上@Configuration注解，表示该类被注册为一个组件，且该类为一个配置类。类中的方法可以被@Bean注解修饰，表示该方法的返回值的实例会被注册为一个组件。 1234567891011121314151617181920212223242526272829303132@Configuration// @ComponentScan注解表示扫描指定包下的所有类，并将带有@Component等相关注解的类注册为组件@ComponentScan(&quot;com.cskaoyan&quot;)public class SpringConfiguration &#123; /** * 返回值类型：Spring容器中的组件类型 * 返回值：返回值注册为容器中的组件 * 组件ID：默认值是方法名；如果想要指定组件id，可以使用@Bean的value属性 */ @Bean(&quot;druidDatasource&quot;) public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/cskaoyan_db&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;123456&quot;); return dataSource; &#125; /** * 形参：默认按照类型从容器中取出组件;想要指定组件id → @Qualifier */ // 注册一个UserServiceImpl组件 @Bean public UserService userService(@Qualifier(&quot;userDaoImpl&quot;) UserDao userDao) &#123; UserServiceImpl userService = new UserServiceImpl(); // 从容器中取出userDao并且给其赋值 userService.setUserDao(userDao); return userService; &#125;&#125; @Autowired类中的成员变量可以通过@Autowired注解注册为组件，此时该成员变量就不需要开发人员手动初始化。@Autowired的本质是利用容器提供的set方法。 1234@Autowired// 如果该类型的组件不止一个，需要使用@Qualifier来指定组件的id@Qualifier(&quot;userDaoImpl2&quot;)UserDao userDao; 组件的生命周期组件可以使用@Scope注解来确定自己的作用域。如果作用域为singleton，即单例模式，那么每次从容器中取出的组件都是同一个组件；如果使用的是prototype，即原型模式，那么每次取出的都是新的实例。Spring默认使用单例模式。 在单例模式下，容器初始化时就会开始组件的生命周期；如果是原型模式，则只有在获得组件时才开始生命周期。 组件的生命周期如下。 实例化。 给成员变量赋值。一般通过@Autowired等注解实现。 觉醒（Aware），如果组件实现了Aware相关的接口，在这时组件就可以通过该接口的set方法设置一些数据。比如，如果组件实现了BeanNameAware接口，那么就可以调用setBeanName(String beanName)方法。 BeanPostProcessor，提供了两个实现方法：postProcessBeforeInitialization和postProcessAfterInitialization，其作用范围为所有注册的组件。此时触发的是before方法。 InitializingBean的afterPropertiesSet方法 ，或是自定义的init方法。 12345678910@Overridepublic void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;InitializingBean提供的init方法&quot;);&#125;// 自定义init方法，方法名自己定义@PostConstructpublic void init() &#123; System.out.println(&quot;自定义init&quot;);&#125; BeanPostProcessor的after方法。 使用组件。 DisposableBean的destroy方法，或是自定义的destroy方法。 123456789@Overridepublic void destroy() throws Exception &#123; System.out.println(&quot;DisposableBean提供的destroy&quot;);&#125;@PreDestroypublic void customDestroy() &#123; System.out.println(&quot;自定义destroy&quot;);&#125; AOPAOP，面向切面编程，可以将一些与业务无关，但是所有业务都需要调用的逻辑封装起来（如日志，权限控制等），将其作为一种增强。AOP基于动态代理实现，但是相比动态代理，AOP可以更灵活的筛选需要增强的方法以及增强所要做的业务。 现在一般使用AspectJ框架实现AOP。 切入点Pointcut使用execution指定需要增强的方法。 1234567&lt;aop:comfig&gt;&lt;aop:pointcut id=&quot;mypointcut1&quot; expression=&quot;execution(public voidcom.cskaoyan.service.UserServiceImpl.sayHello(String))&quot;/&gt;&lt;aop:pointcut id=&quot;mypointcut2&quot; expression=&quot;execution(* co*..say*(*))&quot;/&gt;&lt;aop:pointcut id=&quot;mypointcut3&quot; expression=&quot;execution(*co*.cskaoyan..UserServiceImpl.sayHello(..))&quot;/&gt;&lt;/aop:config&gt; 使用@annotation指定特殊的增强方法。 1234@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface CountTime &#123;&#125; 12345&lt;aop:config&gt;&lt;!--作用场景：组件中的方法，包含自定义@CountTime注解的方法生效--&gt;&lt;aop:pointcut id=&quot;mypointcut&quot;expression=&quot;@annotation(com.cskaoyan.CountTime)&quot;/&gt;&lt;/aop:config&gt; 通知器Advisor1234&lt;!--advisor → 新的标签 aop标签 → 引入aop的schema约束--&gt;&lt;aop:config&gt; &lt;aop:advisor advice-ref=&quot;countTimeInterceptor&quot; pointcut=&quot;execution(public void com.cskaoyan.service.UserServiceImpl.sayHello(String))&quot;/&gt;&lt;/aop:config&gt; 切面Aspect切面是上面两种的结合，即在指定的切入点写入自定义的通知。切面有五个通知方法，分别是Before、After、Around、AfterReturning、AfterThrowing。Before和After表示在该方法的执行前后的通知；Around类似于InvocationHandler的invoke()和MethodInterceptor的invoke()，可以在执行proceed方法前后进行操作，Around也是使用的最多的通知；AfterReturning是在方法返回值后使用的通知，可以接收方法的返回值；AfterThrowing是在方法抛出异常后使用的通知，可以接收方法的异常。 五个通知的先后顺序是：Before-&gt;Around-&gt;After&#x2F;AfterThrowing-&gt;AfterReturning 可以使用@Aspect注解指定一个组件为切面组件，且在类中的方法要使用@Before、@After、@Around、@AfterReturning、@AfterThrowing注解修饰方法。 @Aspect@Componentpublic class CustomAspect { 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Aspect@Componentpublic class CustomAspect &#123; //@Pointcut注解增加在方法上 → value属性写切入点表达式，方法名作为切入点的id @Pointcut(&quot;execution(* com.cskaoyan.service..*(..))&quot;) public void servicePointcut() &#123; &#125; // 切面组件中的方法，作为对应的通知方法 → 在对应的时间点下会执行到对应的方法 // 通知注解的value属性：可以直接写切入点表达式；也可以引用切入点方法 @Before(&quot;servicePointcut()&quot;) public void beforex() &#123; System.out.println(&quot;before方法&quot;); &#125; @After(&quot;servicePointcut()&quot;) public void after() &#123; System.out.println(&quot;after通知方法&quot;); &#125; // Around通知 → 最强通知 ：返回值为Object，要有委托类方法的执行 // 类似于InvocationHandler的invoke，类似于MethodInterceptor的invoke // 执行委托类的方法：ProceedingJoinPoint proceed方法 @Around(&quot;servicePointcut()&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123; long start = System.currentTimeMillis(); System.out.println(&quot;开始时间：&quot; + start); Object proceed = joinPoint.proceed(); // 执行委托类的方法 long end = System.currentTimeMillis(); System.out.println(&quot;方法执行时间：&quot; + (end - start)); return proceed; // 就是作为代理对象执行方法的返回值 &#125; // afterReturning通知方法的形参，采用Object类型，接收委托类方法的返回值 @AfterReturning(value = &quot;servicePointcut()&quot;,returning = &quot;result&quot;) public void afterReturning(Object result) &#123; System.out.println(&quot;AfterReturning接收到的结果：&quot; + result); &#125; // public void afterThrowing(Exception exception) &#123; @AfterThrowing(value = &quot;servicePointcut()&quot;,throwing = &quot;exception&quot;) public void afterThrowing(Throwable exception) &#123; System.out.println(&quot;afterThrowing通知：&quot; + exception.getMessage()); &#125;&#125; 连接点JoinPoint在Before和Around通知执行过程中可以获得JoinPoint，通过它拿到一些信息，这意味着在通知中可以有更多操作空间。 joinPoint可以直接写在通知方法的形参中，通过调用其方法获取信息。 123456789101112131415@Before(&quot;servicePointcut()&quot;)public void beforex(JoinPoint joinPoint) &#123; // 代理类 Object proxy = joinPoint.getThis(); // 目标类、委托类对象 Object target = joinPoint.getTarget(); // 参数 Object[] args = joinPoint.getArgs(); // 方法 Signature signature = joinPoint.getSignature(); String name = signature.getName(); System.out.println(&quot;正在执行的方法：&quot; + name); System.out.println(&quot;before方法&quot;);&#125; Spring事务Spring事务有三种事务传播行为，分别是REQUIRED、REQUIRES_NEW、NESTED。 REQUIRED：Spring默认。如果外围的方法不包含事务，那么被修饰的内部方法就添加一个新的事务；如果外围方法包含事务，则内部方法加入该事务，要么一起提交要么一起回滚。 REQUIRES_NEW：如果外围的方法不包含事务，那么内部方法就添加一个新的事务；如果外围方法包含事务，内部方法也添加一个事务，且该事务与外围的事务独立。 NESTED：如果外围的方法不包含事务，那么内部方法就添加一个新的事务；如果外围方法包含事务，内部方法也添加一个事务，且该事务与外围的事务成嵌套关系。 Spring事务的开启方式有： PlatFormTransactionManager，平台事务管理器 12345678public interface PlatformTransactionManager extends TransactionManager &#123; // 根据事务的定义，获得事务的状态 → 开启事务 TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException; // 提交 → 参数是TransactionStatus void commit(TransactionStatus var1) throws TransactionException; // 回滚 → 参数是TransactionStatus void rollback(TransactionStatus var1) throws TransactionException;&#125; TransactionTemplate 12345678910111213141516171819202122232425public class TransferTransactionCallBack implements TransactionCallback &#123; AccountMapper accountMapper; Integer fromId; Integer destId; Integer fromMoney; Integer destMoney; public TransferTransactionCallBack(AccountMapper accountMapper, Integer fromId, Integer destId, Integer fromMoney, Integer destMoney) &#123; this.accountMapper = accountMapper; this.fromId = fromId; this.destId = destId; this.fromMoney = fromMoney; this.destMoney = destMoney; &#125; @Override public Object doInTransaction(TransactionStatus transactionStatus) &#123; // 更新money int update1 = accountMapper.update(fromId, fromMoney); int i = 1 / 0; int update2 = accountMapper.update(destId, destMoney); return null; &#125;&#125; 在配置类使用@EnableTransactionManagement注解开启事务，在需要事务的类或方法中使用注解@Transactional。 1234567891011121314151617@Transactional@Overridepublic void transfer(int fromId, int destId, Integer money) &#123; // 查询现有的money是多少 Integer fromMoney = accountMapper.select(fromId); Integer destMoney = accountMapper.select(destId); // 计算转账后的money是多少 fromMoney -= money; destMoney += money; // 更新money int update1 = accountMapper.update(fromId, fromMoney); int i = 1 / 0; int update2 = accountMapper.update(destId, destMoney);&#125; SpringMVC传统的Servlet映射过程繁琐，需要我们自己处理url和Servlet的映射关系，并根据url判断、分发接口至不同的方法中，且请求参数、响应结果都要自己手动拆封json。在SpringMVC中，则只由一个Servlet：DispatcherServlet来解决上述问题。 在SpringMVC中的流程如下。 客户端（浏览器）发送请求，直接请求到 DispatcherServlet。 DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。 解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。 HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。 处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。 ViewResolver 会根据逻辑 View 查找实际的 View。 DispaterServlet 把返回的 Model 传给 View（视图渲染）。 把 View 返回给请求者（浏览器） 在SpringMVC中，可以完全使用JavaConfig代替配置文件，主要有： AACDSI（AbstractAnnotationConfigDispatcherServletInitializer） 1234567891011121314151617181920public class ApplicationInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; // 加载Spring的配置文件application.xml → 配置类 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;SpringConfiguration.class&#125;; &#125; // 加载SpringMVC的配置文件application-mvc.xml → 配置类 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;MvcConfiguration.class&#125;; &#125; // DispatcherServlet的映射范围 @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125;&#125; Spring配置类，用@Configuration修饰 12345@ComponentScan(value = &quot;com.cskaoyan&quot;, excludeFilters = @ComponentScan.Filter(&#123;Controller.class, EnableWebMvc.class&#125;)) // mvc配置类也在扫描包范围@Configurationpublic class SpringConfiguration &#123;&#125; SpringMVC配置类，用@EnableWebMvc修饰 1234@ComponentScan(&quot;com.cskaoyan.controller&quot;)@EnableWebMvcpublic class MvcConfiguration implements WebMvcConfigurer &#123;&#125; @RequestMapping用于url的路径映射，可以写在类或方法上。 同一个RequestMapping可以映射多个路径，通过数组表示。 1234567891011121314@RequestMapping(&#123;&quot;hello&quot;,&quot;hello2&quot;,&quot;hello3&quot;&#125;) @ResponseBody public String hello() &#123; return &quot;hello world&quot;; &#125;/** * 也可以使用通配符 * */ @RequestMapping(&#123;&quot;goodbye/*&quot;, &quot;goodbye*&quot;&#125;) @ResponseBody public String goodbye() &#123; return &quot;byebye&quot;; &#125; 如果请求url包含共同的前缀，可以提取至修饰类的注解中，这称为窄化请求。 1234567891011121314151617181920212223242526272829@Controller@RequestMapping(&quot;user&quot;)public class UserController &#123; //@RequestMapping(&quot;user/login&quot;) @RequestMapping(&quot;login&quot;) @ResponseBody public String login() &#123; return &quot;login&quot;; &#125; //@RequestMapping(&quot;user/register&quot;) @RequestMapping(&quot;register&quot;) @ResponseBody public String register() &#123; return &quot;register&quot;; &#125; //@RequestMapping(&quot;user/modify&quot;) @RequestMapping(&quot;modify&quot;) @ResponseBody public String modify() &#123; return &quot;modify&quot;; &#125; //@RequestMapping(&quot;user/remove&quot;) @RequestMapping(&quot;remove&quot;) @ResponseBody public String remove() &#123; return &quot;remove&quot;; &#125;&#125; @RequestMapping还有多种属性： method：用于限定请求方法。如GET、POST。 12345@RequestMapping(value = &quot;get&quot;,method = RequestMethod.GET) @ResponseBody public String methodGet() &#123; return &quot;Method GET&quot;; &#125; params：用于限定参数。 12345@RequestMapping(value = &quot;login&quot;,params = &#123;&quot;username&quot;,&quot;password&quot;&#125;) // 既要携带username又要携带password @ResponseBody public String login() &#123; return &quot;ok&quot;; &#125; headers：用于限定请求头。 12345@RequestMapping(value = &quot;limit&quot;, headers = &#123;&quot;abc&quot;, &quot;def&quot;&#125;)//既要携带abc、又要携带def这两个请求头 @ResponseBody public String headerLimit() &#123; return &quot;header limit&quot;; &#125; consumes：用于限定Content-Type的值。 produces：用于限定Accept的值 @ResponseBody在Controller上添加注解@ResponseBody，即可将返回值自动包装为json。 123456789@Controllerpublic class JsonController &#123; @RequestMapping(&quot;json&quot;) @ResponseBody public User json() &#123; return new User(&quot;123&quot;,&quot;456&quot;); &#125;&#125; 可以使用@RestController来代替@Controller和 @ResponseBody。 请求参数的接收如果是普通的get请求，可以使用方法形参来接收参数，但要求形参名与参数名必须一致。类型支持： 字符串String 基本类型以及对应包装类 数组 Date（需要使用@DateTimeFormat来标准化日期格式） 文件 1234567891011121314151617181920@RequestMapping(&quot;register5&quot;)public BaseRespVo register5(String username, String password, Integer age, String[] hobbies, Integer[] ids, @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date birthday) &#123; return BaseRespVo.ok();&#125;@RequestMapping(&quot;file&quot;)public BaseRespVo uploadFile(MultipartFile file) throws IOException &#123; // 获得上传的文件的信息 String name = file.getName(); // 请求参数名 → file String originalFilename = file.getOriginalFilename(); //原始文件名 long size = file.getSize(); // 文件的大小 String contentType = file.getContentType(); // 正文类型 → 文件类型 // MultipartFile.transferTo File saveFile = new File(&quot;D:\\\\WorkSpace\\\\j40_workspace&quot;, originalFilename); //File saveFile = new File(&quot;D:\\\\WorkSpace\\\\j40_workspace\\\\dlrb.jpg&quot;); file.transferTo(saveFile); return BaseRespVo.ok();&#125; 除了形参，还可以使用自定义的引用类型对象，如果使用引用类型的对象时，Servlet会去创建一个新的实例。看你这个类中有哪些成员变量，如果成员变量名和请求参数名相同，就会使用成员变量来接收请求参数，使用set方法来进行封装。所以要求请求参数名与引用类中的成员变量名一致。 12345678910@Datapublic class User &#123; String username; String password; Integer age; String[] hobbies; Integer[] ids; @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date birthday;&#125; 1234@RequestMapping(&quot;register6&quot;)public BaseRespVo register6(User user) &#123; return BaseRespVo.ok();&#125; 如果是post请求，那么发送的请求参数一般是json，需要对json转换成对应的实例。此时需要增加@RequestBody注解来修饰json对应的bean类。 1234@RequestMapping(&quot;user/login&quot;)public BaseRespVo login(@RequestBody JsonUser user) &#123; return BaseRespVo.ok(user);&#125; 如果需要获得Cookie，则不能直接获得，需要通过Request获得。 12345678910// 把所有Cookie都遍历打印一下@RequestMapping(&quot;cookies&quot;)public BaseRespVo cookies(HttpServletRequest request) &#123; Cookie[] cookies = request.getCookies(); for (Cookie cookie : cookies) &#123; System.out.println(cookie.getName() + &quot; --&gt; &quot; + cookie.getValue()); &#125; return BaseRespVo.ok();&#125; 而session可以直接获得。 12345@RequestMapping(&quot;session2&quot;)public BaseRespVo session2(HttpSession session) &#123; Object username = session.getAttribute(&quot;username&quot;); return BaseRespVo.ok(username);&#125; @PathVariable获取请求url中指定占位符的值，并将值赋给对应的形参。 1234@RequestMapping(&quot;note/&#123;id&#125;&quot;)public BaseRespVo note(@PathVariable(&quot;id&quot;) Integer id) &#123; return BaseRespVo.ok();&#125; ConverterConverter，类型转换器，使用主要是在请求参数封装的过程中，也就是Handler方法的形参。在形参并不是String的情况下会用到Converter。 一般情况下需要自己定义Converter。如从String转为User。 12345678910public class String2UserConverter implements Converter&lt;String, User&gt; &#123; @Override public User convert(String s) &#123; // 里面的转换业务需要你自己定义 User user = new User(); user.setUsername(s); user.setPassword(s); return user; &#125;&#125; 12345// 提供自定义的转换器@Overridepublic void addFormatters(FormatterRegistry registry) &#123; registry.addConverter(new String2UserConverter());&#125; ResourceHandler因为在SpringMVC中，DispatcherServlet的映射范围是&#x2F;，即除了jsp外的所有请求，之前JavaEE的访问静态资源的方式就无法使用了，所以需要使用ResourceHandler来进行静态资源映射。 123456@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(&quot;/pic/**&quot;).addResourceLocations(&quot;classpath:/&quot;); registry.addResourceHandler(&quot;/jpg/**&quot;).addResourceLocations(&quot;/&quot;); registry.addResourceHandler(&quot;/png/**&quot;).addResourceLocations(&quot;file:D:\\\\spring/&quot;);&#125; HandlerInterceptor在Handler前执行，起到了拦截的功能。 12345678910111213public interface HandlerInterceptor &#123; // 在Handler方法执行之前 // 返回值为boolean，如果为true则继续流程，如果false，则中断流程 default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125; // 在Handler方法执行之后 default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; &#125; // 在整个流程完成之后 default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; &#125;&#125; 异常处理有两种异常处理方式：统一的全局异常处理 HandlerExceptionResolver和自定义异常处理 ExceptionHandler。 HandlerExceptionResolver是一个接口，接口里提供了resolveException方法，重写该方法来处理全局异常。 123456789101112@Componentpublic class CustomHandlerExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123; // 通过它也可以做个性化的异常处理，如果要做，需要你自己来做个性化的东西 if (e instanceof ArithmeticException) &#123; //做个性化的异常处理 System.out.println(e.getMessage()); &#125; return new ModelAndView(&quot;/exception.jsp&quot;); &#125;&#125; ExceptionHandler是一个注解，value是对应的异常，旨在用对应的方法处理对应的异常。一般放在ontrollerAdvice组件中的方法上。 1234567891011@ControllerAdvicepublic class CustomExceptionControllerAdvice &#123; // 在形参中可以直接接收你抛出的异常，你映射的是什么异常，就可以以什么类型的形参来接收 @ExceptionHandler(ArithmeticException.class) @ResponseBody public BaseRespVo method1(ArithmeticException exception) &#123; return BaseRespVo.fail(exception.getMessage()); &#125; &#125; SpringBootSpringBoot本质上就是一个Spring框架，但是它简化了Spring的配置。在没有给具体配置前，SpringBoot会使用默认的配置，只有给到具体的配置，才采用具体的配置。 启动类： 123456789// 该注解就是SpringBoot应用启动类上的注解 → 会配置扫描包目录就是该类所处的包目录@SpringBootApplicationpublic class Demo1FirstSbApplication &#123; // 启动类中一定会包含main方法 → 就是启动SpringBoot应用程序的入口 public static void main(String[] args) &#123; SpringApplication.run(Demo1FirstSbApplication.class, args); &#125;&#125; SpringBoot对web的支持： 12345678910111213141516# tomcat配置server: port: 8083 #Tomcat的端口号配置 servlet: context-path: /demo1 # 应用程序的上下文配置（应用名） # 静态资源映射spring: mvc: static-path-pattern: /pic/**# spring.resources 或 spring.web.resources resources: static-locations: file:d:/spring/ # Converter# Filter SpringBoot对Mybatis的支持： 123456spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/cskaoyan_db?useUnicode=true&amp;characterEncoding=utf-8 username: root password: 123456 12345678910@SpringBootApplication// 需要添加@MapperScan来扫描mapper@MapperScan(&quot;com.cskaoyan.mapper&quot;)public class Demo1FirstSbApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Demo1FirstSbApplication.class, args); &#125;&#125; 逆向工程逆向工程可以根据数据库中的表自动生成接口、方法、映射文件，只需要操作对应的Example类就可以操作数据库。 接口方法示例。 123456//升序还是降序:字段+空格+asc(desc)protected String orderByClause;//去除重复:true是选择不重复记录,false,反之protected boolean distinct;//自定义查询条件protected List&lt;Criteria&gt; oredCriteria; 123456789101112131415@Testpublic void testFindUserByName()&#123; //通过criteria构造查询条件 UserExample userExample = new UserExample(); userExample.setOrderByClause(&quot;username asc&quot;); //asc升序,desc降序排列 userExample.setDistinct(false); //去除重复,true是选择不重复记录,false反之 UserExample.Criteria criteria = userExample.createCriteria(); //构造自定义查询条件 criteria.andUsernameEqualTo(&quot;张三&quot;); //自定义查询条件可能返回多条记录,使用List接收 List&lt;User&gt; users = userMapper.selectByExample(userExample); System.out.println(users);&#125; 逆向工程生成的内容会有一定问题，如果表中的字段存在sql语句中的关键字，需要自己手动在mapper.xml文件中添加转义字符。 TypeHandlerTypeHandler是Mybatis输入输出映射过程中的类型处理器，用于处理jdbcType和JavaType间的转换。 主要方式是实现TypeHandler接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 类型映射配置@MappedTypes(Integer[].class)@MappedJdbcTypes(JdbcType.VARCHAR)public class IntegerArrayTypeHandler implements TypeHandler&lt;Integer[]&gt; &#123; ObjectMapper objectMapper = new ObjectMapper(); // 输入映射过程 // insert into market_user (id,username,password,role_ids) values (?,?,?,?) @Override public void setParameter(PreparedStatement preparedStatement, int index, Integer[] integers, JdbcType jdbcType) throws SQLException &#123; String value = null; try &#123; value = objectMapper.writeValueAsString(integers); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; // 为第几个占位符提供的值是什么 preparedStatement.setString(index,value); &#125; // 输出映射过程 @Override public Integer[] getResult(ResultSet resultSet, String columName) throws SQLException &#123; // 获得结果 String result = resultSet.getString(columName); return transfer(result); &#125; @Override public Integer[] getResult(ResultSet resultSet, int index) throws SQLException &#123; // 获得结果 String result = resultSet.getString(index); return transfer(result); &#125; @Override public Integer[] getResult(CallableStatement callableStatement, int i) throws SQLException &#123; // 获得结果 String result = callableStatement.getString(i); return transfer(result); &#125; private Integer[] transfer(String result) &#123; Integer[] integers = new Integer[0]; // 使用jackson将字符串转换Integer[] try &#123; integers = objectMapper.readValue(result, Integer[].class); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return integers; &#125;&#125; 配置自定义的TypeHandler 12mybatis: type-handlers-package: com.cskaoyan.typehandler Shiro框架Shiro安全框架，Apache Shiro是一个开源安全框架，提供身份认证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。 Shiro在SpringMVC应用程序中以Filter的形式存在。 Shiro的一些核心术语如下。 Authentication，认证是身份验证的过程 -您正在尝试证明用户是他们所说的人。为此，用户需要提供系统理解和信任的某种身份证明。认证其实就是我们通常所说的登录。 Authorization，授权或访问控制是指定对资源的访问权限的功能。换句话说，谁可以访问什么。比如是否允许用户编辑此数据，这些都是决定用户有权访问的内容的决定。我们当前主要针对的是URL级别的权限访问控制。 Subject，主体，在Shiro中所做的几乎所有操作都基于当前正在执行的用户，也就是基本上Shiro的操作都是使用Subject操作的，Subject指的就是当前操作的用户。在代码中的任何位置都可以轻松获得Subject，通过Subject可以方便的操作Shiro。比如我们可以使用Subject提供的方法来执行认证、判断是否认证等操作。 Principals，主体鉴定后的参数，也就是认证后的用户信息，可以是姓名、用户id、用户对象等形式。 Credentials，用来验证身份的秘密数据，通常指密码，生物数据比如指纹、面部、瞳孔等。 Realms，域或领域，安全的特殊数据存储对象（DAO），Shiro中的Realm主要是让你能够获得对应的认证信息和授权信息。 Token，令牌，Shiro中的Token是作为登录操作的参数。 Shiro的核心组件如下： SecurityManager，安全管理器 Authenticator，认证器 SessionManager，会话管理器 Realm，域 CacheManager，缓存管理器 Cryptography，密码学 Shiro提供的Filter类型如下。 Filter名称 Filter类 说明 anon org.apache.shiro.web.filter.authc.AnonymousFilter 匿名Filter，作用范围内的请求不需要认证和授权 authc org.apache.shiro.web.filter.authc.FormAuthenticationFilter 认证Filter，作用范围内的请求需要完成认证 perms org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter 权限Filter，作用范围内的请求需要完成认证和授权 我们可以设置不同类型的Filter分别映射一些不同的URL范围，当请求发送到应用程序时，根据请求URL分别判断使用哪一些Filter，在Filter中决定是否继续访问流程。在SpringBoot中，主要在配置文件中配置。 RealmShiro中的Realm主要是让你能够获得对应的认证信息和授权信息。 一般通过自定义Realm来使用，需要继承一个抽象类AuthorizingRealm，并实现两个抽象方法： doGetAuthenticationInfo ：获得认证信息，即根据token中的用户名查询该用户在系统中的Credentials，并且构造AuthenInfo。 doGetAuthorizationInfo ：获得授权信息，即根据Principal（放入AuthenInfo中的第一个参数）查询该用户在系统中的权限信息。 在这两个方法中去写获得用户认证信息和授权信息的业务代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Componentpublic class CustomRealm extends AuthorizingRealm &#123; //通常把doGetAuthenticationInfo方法放在上面 //该方法的形参 → 来源于subject的login方法 // 传入该值，为了根据用户名查询到该用户在系统中的密码（数据库中维护） → 来构造认证信息 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; String username = token.getUsername(); //根据username查询数据库中对应password String password = selectPasswordByUsername(username); // principal信息 → 当前放的是什么信息，后续取出的就是什么信息 // 密码 → 该密码会和Token中的password做比较 // realm名称 → 没啥用 return new SimpleAuthenticationInfo(username,password,getName()); &#125; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; // 根据用户信息拿到所有的权限（数据库） // doGetAuthenticationInfo方法返回值的第一个参数就是用户信息 // 在第21行代码放入的是字符串类型的Principal信息，取出的时候就可以以字符串格式取出 String primaryPrincipal = (String) principalCollection.getPrimaryPrincipal(); List&lt;String&gt; permissions = getPermissionsByUsername(primaryPrincipal); SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); simpleAuthorizationInfo.addStringPermissions(permissions); return simpleAuthorizationInfo; &#125; private String selectPasswordByUsername(String username) &#123; // 应该通过MyBatis根据用户名查询获得结果 return &quot;123456&quot;; &#125; private List&lt;String&gt; getPermissionsByUsername(String username) &#123; // 应该通过MyBatis根据用户名查询获得结果 return Arrays.asList(&quot;admin:user:list&quot;, &quot;admin:admin:list&quot;); &#125;&#125; 认证在对应请求中获得subject，并执行subject的login方法。 因为登录请求不需要权限，需要将其权限设为anon subject对象可以在所有组件中获得，方式为Subject subject = SecurityUtils.getSubject() 在绝大多数场景下，login方法的参数都为AuthenticationToken接口，可以直接使用其实现类UsernamePasswordToken： subject.login(new UsernamePasswordToken(username,password)) 如果需要获得sessionId，可以使用subject获得： subject.getSession().getId() 123456789101112131415161718192021222324252627@PostMapping(&quot;login&quot;)public BaseRespVo&lt;LoginUserData&gt; login(@RequestBody Map map) &#123; String username = (String)map.get(&quot;username&quot;); String password = (String)map.get(&quot;password&quot;); // 整合Shiro // 获得操作的主体 Subject subject = SecurityUtils.getSubject(); // login方法传入的参数AuthenticationToken → 认证的令牌 // subject执行login → 认证器执行认证方法 → realm.doGetAuthenticationInfo // AuthenticationToken → UsernamePasswordToken → 直接封装了username和password // username和password通过Handler方法的形参传入 subject.login(new UsernamePasswordToken(username,password)); if (subject.isAuthenticated()) &#123; System.out.println(&quot;认证成功&quot;); &#125; LoginUserData loginUserData = new LoginUserData(); AdminInfoBean adminInfo = new AdminInfoBean(); adminInfo.setAvatar(&quot;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif&quot;); adminInfo.setNickName(&quot;admin123&quot;); loginUserData.setAdminInfo(adminInfo); // 携带SessionId信息 loginUserData.setToken((String) subject.getSession().getId()); return BaseRespVo.ok(loginUserData);&#125; 认证后可以通过subject.getPrincipals().getPrimaryPrincipal()来获取用户在数据库中的其他信息。该方法的返回值为Object，可以直接转换为对应的用户信息PO类。 可以通过subject.logout()登出用户。 HibernateValidation在需要对一些参数进行校验时，可以在Handler方法的形参上增加注解@Valid或@Validated，或在引用类型中的成员变量上增加校验功能的注解。 常见注解如下。 1234567891011121314151617181920常见的注解 （Bean Validation 中内置的 constraint） @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 Date @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator 附加的 constraint @NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内"},{"title":"学习总结（2022.05.27-2022.06.07）","path":"2022/06/05/学习总结（2022-05-27-2022-06-05）/","text":"HTTP协议详细过程： 域名解析 TCP建立连接 发送HTTP请求报文 返回HTTP响应报文 浏览器解析HTML代码，渲染页面，呈现给用户 其中请求报文的格式为： 请求行。请求行由请求方法(GET&#x2F;POST)，请求资源，请求协议(HTTP&#x2F;1.1)组成 请求头。 空行。 请求体。 响应报文的格式为： 响应行。响应行由版本协议，状态码(200,301,404,500…)，原因短语组成。 响应头。 响应体。 状态码中比较重要的有： 200 过程正常 301，302，307 重定向 404 未找到，意味着没有对应的资源文件 500 服务器异常，意味服务器代码出现bug ServletServlet 是一个在 Web 服务器中运行的小型 Java 程序。Servlet 接收和响应来自 Web 客户端的请求，通常通过HTTP协议来实现。 Servlet有两种写法：一种是通过继承GenericServlet并重写service方法；一种是通过继承HttpServlet并重写doGet方法和doPost方法。其中HttpServlet继承了GenericServlet，并将它的service方法分解成了doGet和doPost，以更好地处理GET请求和POST请求。 在Servlet中，可以通过注解的方式来配置本地程序与URL的映射关系，称为url-pattern，主要通过@WebServlet配置。一个Servlet可以配置多个url-pattern，但是一个url-pattern只能对应一个Servlet。 设置url-pattern时，可以使用通配符，如：/*、 *.html，且具有优先级，优先级判定如下： &#x2F;xxx优先级高于*.xxx 如果都是&#x2F;xxx，那么匹配程度越高，优先级越高 在访问静态文件时，其实访问的是一个url-pattern为/*的Servlet，该Servlet称为缺省Servlet，由tomcat提供，默认逻辑是将请求地址当作静态文件。它可以被重写，只需要在项目中设置一个url-pattern为/*的Servlet即可。 Servlet有三个生命周期，分别是init，service，destory，可以通过重写其生命周期方法来完成一些需要在这个生命周期中完成的操作。比如用init()读取文件，service()修改文件，destory()保存文件。此外，init()方法只有在浏览器第一次访问当前Servlet时调用，需要在注解中设置load-on-startup=1来令init()方法可以随着应用加载而触发执行。 ServletContextServlet具有一个ServletContext对象，它代表的是Servlet中的Context域，每个应用中只有唯一的一个Context域，无论哪个Servlet都可以拿到域中的数据，所以它一般用于Servlet间的共享。 API： 123456789101112// 获取servletContextServletContext servletContext = getServletContext();// 设置Context中的键值对servletContext.setAttribute(key,value);// 根据key获取Context中的valueservletContext.getAttribute(key);// 删除键值对servletContext.removeAttribute(key);// 获取Servlet设置servletContext.getServletConfig();// 获取一个相对应用根目录的绝对路径servletContext.getRealPath(String s); ServletRequestServletRequest是客户端提供给Servlet的请求报文的封装体，Tomcat创建ServletRequest对象并将其作为参数传给service方法。HttpServletRequest继承了ServletRequest，主要用于封装HTTP格式的请求报文。 Request对象和对象间可以通信，这种方式叫做转发。 Request与Context相似，也拥有一个Request域，但是Request域只存在在一个Request对象中，且会随着Request对象的销毁而销毁，在多个Request对象中，Request域不共享，只有通过转发才能与其他对象共享。所以Request域一般用于存放不频繁使用的数据。 API： 123456789101112131415161718192021222324252627282930313233343536373839// 获取请求报文// 获取请求行getMehtod();// 获取请求URLgetRequestURL();// 获取请求URI，URL=协议+主机IP地址+端口号+URIgetRequestURI();// 获取请求协议getRequestProtocol();// 获取所有请求头getHeaderNames();// 获取单个请求头getHeader(key);// 获取请求体getInputStream();// 获取客户机信息// 获得客户机IP地址getRemoteAddr();// 获得客户机端口号getRemotePort();// 获取服务器主机信息// 获得主机IP地址getLocalAddr();// 获得主机端口getLocalPort();// 获取请求参数// 根据key获取单个valuegetParameter(key);// 根据key获取多个valuegetParameterValues(key);// 获取所有key值getParameterNames();// 获取key、value映射的mapgetParameterMap();// 设置请求体的编码集，需要在读取请求参数前调用setCharacterEncoding(&quot;utf-8&quot;); ServletResponseServletResponse是客户端提供给Servlet的响应报文的封装体，Tomcat创建ServletResponse对象并将其作为参数传给service方法。HttpServletResponse继承了ServletResponse，主要用于封装HTTP格式的响应报文。 API： 12345678// 设置响应报文setStatus(200);// 在响应头添加属性，如设置响应报文字符集setHeader(&quot;Content-type&quot;,&quot;text/html;charset=utf-8&quot;);// 获取字符流，在响应体添加内容getWriter();// 获取字节流，在响应体添加内容getOutputStream(); 会话技术HTTP协议存在无状态性，即所有客户端发送的请求报文是完全相同的，服务器不可能通过请求报文区分客户端，也无法为每个独立的客户端处理数据。解决HTTP无状态性的即是会话技术。 会话技术分为客户端技术和服务端技术，即Cookie和Session。 CookieCookie数据产生于服务器，产生之后会通过HTTP响应报文传输给客户端，客户端来保存这些数据，在客户端再次访问服务器时，会把这些数据通过HTTP请求报文再次携带回来，这样服务器就了解请求来自于哪个客户端。Cookie的本质就是在请求报文中加入了Cookie请求头，在响应报文中加入了set-Cookie请求头。 Cookie的使用方式如下 123456// 构造函数生成CookieCookie cookie = new Cookie(String name, String value);// response中添加Cookieresponse.addCookie(cookie);// request中获取CookieCookie[] cookies = request.getCookies(); Cookie可以进行一些设置，设置方式如下 1234567// 设置存活时间// 设置正数表示在硬盘中存活多久；负数表示存在于浏览器的内存中；0表示删除Cookiecookie.setMaxAge(180);// 设置路径，仅访问指定路径才会携带Cookiecookie.setPath(String path);// 设置域名，访问指定域名才会携带Cookiecookie.setDomain(String addr); Cookie轻便，可以跨多主机间数据共享，而且因为存储在客户端，减轻了服务器的压力；但是Cookie只能存储字符串类型，大小也有限制，而且Cookie的安全性存在问题，只能存储一些不敏感的数据。 Session因为数据的产生与存储均是在服务器完成，所以服务器可以在特定场景下给客户端单独开辟一块空间（即对象），该对象专门只为这个客户端服务，这个对象就被称为Session对象。 Session的本质是服务器生成一个Session对象，将该对象的编号通过Cookie返回给客户端，后续客户端访问服务器时，都会把Session的编号携带过来，那么服务器就可以获取到对应的Session对象，就能在该对象中进行只针对该客户端的数据的存取和处理。 Session的使用方式如下 123456// 获取Session对象Session session = request.getSession();// Session中存储数据session.setAttribute(String name,Object object);// Session中获得数据session.getAttribute(String name); 至此可以知道，服务器存在三个域：Context域，Session域，Request域。 Context域最大，一个服务器应用中只有一个，主要用于存储一些全局性的数据；Session域其次，一个客户端对应一个Session对象，一般存储客户端特有的数据；Request域最小，一个Servlet请求对应一个Request对象，一般存储访问频次不高的数据。 Session对象不会随着浏览器关闭而销毁，只是新的浏览器无法访问之前浏览器创建的Session对象；Session对象会随着服务器关闭而销毁，但是Session数据并不会被销毁，而是被序列化保存在硬盘中，只有在有效期到达，或者服务器主动调用invalidate()方法，才会被销毁。 ListenerListener，即监听器，是EE三大组件之一，主要负责监听对象。常用的Listener为servletContextListener，用于监听ServletContext对象的创建和销毁，以替代Servlet中的init()方法和destory()方法。 Listener的实现方式如下 123456789101112131415@WebListenerpublic class MyServletContextListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent servletContextEvent) &#123; System.out.println(&quot;当servletContext对象被创建时，会调用该方法&quot;); ServletContext servletContext = servletContextEvent.getServletContext(); &#125; @Override public void contextDestroyed(ServletContextEvent servletContextEvent) &#123; System.out.println(&quot;当servletContext对象被销毁时，会调用该方法&quot;); &#125;&#125; FilterFilter，即过滤器，是EE三大组件之一，主要负责权限验证，对请求进行放行或拦截，可以在请求到达关联的Servlet前，检查修改Request对象，也可以在响应返回到客户端前，检查修改Response对象。 Filter的实现方式如下 123456789101112131415161718192021222324@WebFilter(&quot;/filter1&quot;)public class FirstFilter implements Filter &#123; //filter的初始化阶段 //init阶段和servlet略有不同；当应用的启动，init方法就会被执行 @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;init&quot;); &#125; //类似于servlet的service方法，每次访问filter时，都会经过该方法 @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;doFilter&quot;); //下面这行代码对于请求的放行是至关重要的；如果没有，则执行的是拦截操作；如果有，则执行的是放行操作 filterChain.doFilter(servletRequest, servletResponse); &#125; //当应用卸载、服务器关闭，会调用该方法 @Override public void destroy() &#123; System.out.println(&quot;destroy&quot;); &#125;&#125; Filter与Servlet生成关联的方式有 Filter与Servlet设置相同的url-pattern Filter设置&#x2F;*（常用） Filter与Filter之间可以生成关联，具体方式为设置相同的url-pattern，Filter的执行顺序由类的首字母ASCII顺序（注解声明）或filter-mapping声明的先后顺序（web.xml声明）。 完整请求处理流程 浏览器解析域名，与服务器建立TCP连接 浏览器发送HTTP请求报文，被服务器中的Connector接收，Connector将其解析为Request对象，同时新建一个Response对象 Connector对象将两个对象传给Enginee对象，Enginee对象进一步传递给Host对象。 Host挑选一个合适的Context对象，再将两个对象传输给Context对象。 Context对象根据路径查找是否有匹配的Filter需要处理该请求，如果有则交由Filter处理，Filter处理完毕再将请求发送给对应的Servlet；如果没有则直接发送给Servlet。 Servlet接收到请求后执行service方法，执行完毕后，如果存在对应的Filter，则将处理后的两个对象返回给Filter，Filter处理完毕后再原路返回；如果没有则直接原路返回。 最后Connector获得Response对象，读取其中的数据后按照HTTP响应报文的格式要求，生成响应报文，发送给客户端。 客户端接收响应报文，解析、渲染，形成页面。 MVCMVC分别是模型层(model)，视图层(view)和控制层(controller)，将应用的代码按照MVC模式分离，以达到解耦的目的。 模型层：主要存放数据的模型和对数据的操作。 视图层：主要用于显示页面或将数据结果返回给前端显示。 控制层：用于接收来自模型层的数据，并将处理后的数据返回给视图层，起到了连接模型层和视图层的作用。 MVC的核心思想就是在请求到来后，首先交给控制层处理，控制层调用模型层的代码处理数据，返回的结果再由控制层交给视图层。 三层架构是MVC设计模式的一种演进，可以将MVC进一步抽象成三个模块，分别是展示层(view、controller)、业务层(service)和数据层(Dao)。 为了进一步降低代码的耦合性，可以将模型层中对数据的操作部分提取出来，命名为dao(Data Access Object)，该层可以设计一个接口，因为对数据操作时，参数类型和返回值都是不变的；这样我们就可以设计不同的实现类来实现接口，从而完成对数据的不同操作。 service层则是在controller和dao之间的业务层，主要任务是保证业务处理的实现方式的多样性。如果存在多个业务处理方式，那么就需要对controller层进行反复修改，违反了设计模式的开闭原则（对新增代码开放，对修改代码关闭），所以需要一个service层来保证可以存在多个业务处理方式。service层与dao层一样，只需要设计一个接口以保证参数类型和返回值不变，之后只需要设计实现类实现接口，并在controller层的相应位置调用即可。"},{"title":"学习总结（2022.05.24-2022.05.26）","path":"2022/05/26/学习总结（2022-05-24-2022-05-26）/","text":"RedisRedis是一个NoSQL数据库，因为它基于内存存储，有很高的读取性能，但同时也不能存储大量数据，无法有SQL的容量，所以一般作为SQL的缓存使用。使用方式是：Java应用首先在Redis中查询数据，如果没有获得结果再去SQL中查询。 放在内存中意味着Redis的数据并不能一直储存，且随着机器故障或者重启有丢失数据的风险，所以Redis有将内存中的数据存储至硬盘的功能，这种功能叫做持久化。 Redis的持久化有两种：RDB和AOF。 RDBRDB，即通过快照技术（保存某一时刻内存中数据的状态）保存数据的一种持久化策略。由于保存的是内存状态，所以保存的文件是比较小的，且是不可读的二进制文件。RDB默认是开启的 RDB默认的保存策略如下。 123456# 每900秒内key存在1次变化，触发RDBsave 900 1 # 每300秒内key存在10次变化，触发RDBsave 300 10# 每60秒内key存在10000次变化，触发RDBsave 60 10000 但是RDB并不是完全的策略，因为在两次RDB触发事件间发生数据丢失则无法恢复，所以需要另外一种策略填补。 AOFAOF是通过不断往日志文件中写入Redis的写操作相关命令，通过命令恢复数据的一种持久化策略。 AOF默认的保存策略如下。AOF默认是关闭的。 123456# always：只要收到一条写命令，就保存至日志appendfsync always# everysec：每秒保存一次至日志appendfsync everysec# no：从不保存appendfsync no AOF和RDB的区别如下： RDB恢复数据的速度较快，AOF因为要读取日志文件的命令来恢复数据，所以速度较慢。 RDB存储的数据文件较小，而AOF因为会不断在日志文件中写入命令，日志文件会越来越大。 所以RDB适合用于容灾备份，AOF适合用于日常备份。 数据结构Redis常用的有五种数据结构，分别是string，hash，list，set，sortset。 string：存储的是一对键值对，一般用于需要计数的场景，如用户的访问次数，文章转发数等。 常用命令如下。 1234567891011121314# 设置一个键值对set# 获取一个键对应的值get# 给整数类型的值+1incr# 给整数类型的值加指定的值incrby# 设置多个键值对mset# 获取多个键的值mget# 设置一个键值对，并设置过期时间setex hash：存储的是一个二维表，适合存储对象，所以一般用于存储商品信息，用户信息等。 常用命令如下。 1234567891011121314# 设置一个键值对hset# 获取一个field对应的值hget# 设置多个键值对hmset# 获取多个field对应的值hmget# 获取表中所有field和valuehgetall# 获取表中所有fieldhkeys# 获取表中所有valuehvals list：是一个有序，可重复的线性表，可以从两头插入和删除，但不支持随机查找，一般用于消息队列。 常用命令如下。 123456789101112131415161718# 列表左边推入元素lpush# 列表右边推入元素rpush# 列表左边弹出元素lpop# 列表右边弹出元素rpop# 计算元素个数llen# 获取指定下标的值，最左边元素index为0lindex# 插入一个元素linsert# 查询范围内元素lrange# 删除指定的前几个元素lrem set：是一个无序的集合，但不可存储重复的键值对。因为Redis支持通过多个set查询它们的交&#x2F;并&#x2F;差集，所以一般用于查找共同好友、发现共同关注等。 常用命令如下。 12345678910111213141516171819202122# 添加元素sadd# 查询所有元素smembers# 判断一个元素是否在集合中sismember# 查询元素数量scard# 移动元素至另一集合smove# 删除元素srem# 随机取出一个元素并删除spop# 随机取出一个元素，不删除srandmember# 求集合交集sinter# 求集合并集sunion# 求集合差集sdiff zset：是一个有序的集合，可以根据集合中的score对数据进行排序，一般用于直播礼物排行榜、游戏积分排行榜等。 常用命令如下。 123456789101112131415161718192021222324# 添加成员及分数zadd# 统计成员个数zcard# 统计一个分数区间内成员的数量zcount# 获取一个成员的分数zscore# 为成员增加分数zincrby# 获取一个成员的升序排名zrank# 获取一个成员的降序排名zrevrank# 查找指定排名区间的成员zrange# 查找指定排名区间的成员，倒序排列zrevrange# 查找指定分数区间的成员zrangebyscore# 查找指定分数区间的成员，倒序排列zrevrangebyscore# 删除指定成员zrem 内存淘汰策略Redis是将数据存储在内存上的，如果内存已满，就需要淘汰一些不需要的数据，以保证之后的数据写入成功。Redis有八种内存淘汰策略。 volatile-lru：从已经设置过期时间的数据集中，选择最近使用次数最少的数据淘汰。 volatile-lfu：从已经设置过期时间的数据集中，选择一段时间内使用次数最少的数据淘汰。 volatile-ttl：从已经设置过期时间的数据集中，选择最近将要过期的数据淘汰。 volatile-random：从已经设置过期时间的数据集中，随机选择数据淘汰。 allkeys-lru：从所有数据集中，选择最近使用次数最少的数据淘汰。 allkeys-lfu：从所有数据集中，选择一段时间内使用次数最少的数据淘汰。 allkeys-ttl：从所有数据集中，选择最近将要过期的数据淘汰。 allkeys-random：从所有数据集中，随机选择数据淘汰。 理论上volatile-lru是最合理的，但也是最慢的，而allkeys-random是速度最快的，所以应对不同的业务场景，需要采取不同的内存淘汰策略。 Linux常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107# 基础命令# 查看当前路径pwd# 进入指定路径（相对路径/绝对路径）# .: 当前路径# ..: 上一级路径cd# 显示路径下所有文件# -a: 显示隐藏文件# -l: 显示文件信息ls# 文件与目录管理# 创建新的目录文件mkdir# 删除空目录文件rmdir# 复制文件或目录# -r: 表示递归复制# -f: 表示强制cp# 删除文件或目录# -r: 表示递归删除# -f: 表示强制rm# 移动文件或目录mv# 创建文件touch# 查看文件中的内容cat# 以分页形式查看文件内容less# 查看文件的前几行head# 查看文件的后几行tail# 重定向&gt;# 追加&gt;&gt;# 压缩tar -zxvf# 解压tar -zcvf# 文本编辑# 命令模式# 删除光标所在字符x# 删除光标所在行dd# 删除光标所在行直到文件末尾dG# 删除光标所在位置直到文件末尾D# 插入模式# 在光标所在位置编辑i# 在光标所在行末尾编辑A# 移动到下一行编辑o# 移动到上一行编辑O# 末行模式# 退出q# 保存w# 强制!# 用户管理# 添加用户useradd# 删除用户userdel# 修改用户usermod# 查看用户id# 组管理# 添加组groupadd# 权限管理# 修改权限chmod# 进程管理# 查看父进程idps -ef | grep# 查看资源使用情况px aux | grep# 终止进程kill# 网络管理# 查看ipifconfig# 查看端口占用情况netstat -anp | grep# 软件安装sudo apt install Git常用命令1234567891011121314151617181920# 下载远程仓库，并在本地创建一个同名文件夹git clone# 查看工作区和缓冲区变化git status# 将工作区的变化提交到缓冲区git add# 将缓冲区的变化提交到本地仓库git commit# 把本地仓库的变化推送到远程仓库git push# 拉取远程仓库的变化到本地仓库git pull# 查看仓库的所有版本信息git log# 将工作区的变化回退git checkout# 将缓冲区的变化回退到工作区git reset# 将本地仓库回退至历史版本git reset --hard Git处理冲突如果push时发现本地仓库版本低于远程仓库版本，会push失败，只有使用pull将本地仓库版本更新，才能继续修改。 修改后推送到本地仓库时，如果修改的是同一个文件和同一个内容，会提示产生冲突，需要人为处理；如果不是同一文件或不是同一内容，则不会提示。 由上可知，使用git时应该注意尽量不要开发同一个文件，不然容易产生冲突；且push前最好pull一下，防止push失败。 Git忽略文件git可以在push时忽略一些文件，不对这些文件进行版本控制。使用方式是将这些文件放在.gitignore文件夹下。"},{"title":"学习总结（2022.05.17-2022.05.23）","path":"2022/05/23/学习总结（2022-05-17-2022-05-23）/","text":"索引索引是一种帮助提高查询速度的数据结构，可以提高MySQL的查询语句的效率。 索引的数据结构的选择有两个指标：单值查询和范围查询。各个数据结构的查询效率如下： 数组：单值查询慢，范围查询慢。 链表：单值查询慢，范围查询慢。 二叉树：单值查询较慢，范围查询慢。 B树：单值查询较快，范围查询慢。 B+树：单值查询较快，范围查询较快（MySQL官方推荐数据结构） Hash表：单值查询快，范围查询慢（MySQL内部使用，不开放给用户） B+树是对B树的一种优化。叶子节点之间维护一个指针，方便了范围查找；所有非叶子节点会在叶子节点中冗余一份，并且自身不再存储数据，而只存储key值，这样就降低了树的高度。 为什么要降低树的高度？因为数据库读取数据时是按树的层序读取，而每一次读取都要经历一次磁盘IO，所以树的高度越低，磁盘IO的次数越少，效率越高。 为什么MySQL使用主键自增策略？因为无序的插入索引会导致树的结构发生较多较大的变化，而改变结构是要消耗时间的。在主键自增的策略下，每次新建的数据的主键索引就永远插入到索引树的右侧，这样就能保证树的结构不会发生较大的改变。 索引是不是声明的越多越好？首先，声明索引需要建立索引树，需要占用空间；其次，每次对数据的增删改都会影响索引树的结构，如果索引树太多势必会导致维护这些索引树的代价提升。所以索引并不是越多越好。 数据库的组成结构连接器：校验用户名和密码，和客户端建立连接。 分析器：进行语法分析，编译SQL语句。 优化器：优化SQL语句的性能，主要操作为 选择哪个索引进行查询。 多表查询时，选择表连接的顺序。 执行器：执行SQL语句编译后的指令。 存储引擎：存储数据。 存储引擎目前MySQL使用的引擎有MyISAM和InnoDB。 MyISAM：MyISAM有三种文件，分别是表结构定义文件、数据文件和索引文件。因为它的数据和索引是分开存储的，所以MyISAM的索引叫非聚集索引。索引分为两种类型：主键索引和非主键索引，根据索引树是否是由主键生成来区分。在MyISAM中： 主键索引的key值为主键值，data为数据对应的地址值。 非主键索引的key值为指定的队列值，data也为数据对应的地址值。 InnoDB：InnoDB有两种文件。分别是表结构定义文件、数据&#x2F;索引文件。因为它的数据和索引放在一个文件中，所以InnoDB的索引叫聚集索引。在InnoDB中： 主键索引的key值为主键值，data为主键对应的数据。不同于MyISAM存储的是数据的地址，因为InnoDB存储的是数据本身，这就要求InnoDB必须有一列主键，否则就无法构建索引树。如果用户建表时不声明主键，那么InnoDB会维护一个隐藏列作为主键。MySQL推荐自定义主键的原因就是如果我们不声明主键，我们也无法通过隐藏的索引列来进行查询，这就浪费了主键索引的性能。 非主键索引的key值为指定的队列值，data为数据对应的主键值。 MyISAM与InnoDB的区别： InnoDB支持事务，MyISAM不支持事务。 InnoDB支持外键，MyISAM不支持外键。 InnoDB支持表锁和行锁，MyISAM只支持表锁。 那么什么情况下使用MyISAM？因为MyISAM不支持事务，且只支持表锁，会导致增删改查的效率下降，并有发生隔离问题的可能，所以一般存储不需要更改的数据，比如历史数据。 索引语法1234567891011121314151617-- 查询索引show index from tableName;-- 建立索引create table tableName( id int PRIMARY KEY, index idx_name(name) using BTREE)ENGINE=InnoDB character set utf8;-- 查看索引show index from tableName;-- 删除索引alter table tableName drop index idx_name;-- 添加索引alter table tableName add index idx_name; 回表回表是指在一次查询中，需要根据非主键索引查询出主键值，再根据主键值在主键索引中找到数据，这样就查询了两条索引树，导致查询的效率变低了。 如何避免回表？主要的方式有： 尽量使用主键查询。因为只有使用非主键索引才会发生回表。 尽量避免使用select * from。因为如果准确列出列名，且列名中包含非主键索引，那么该列的值会直接使用非主键索引中的值，而非去使用获得主键，并在主键索引树查询得到的值。 可以考虑使用联合索引。这样可以降低非主键索引树的高度，能更快的查到主键值。 MavenMaven是一个项目管理工具，主要功能是编译项目、将项目打包为jar包、依赖管理。 Maven有以下指令： clean：删除编译好的项目文件夹target。 validate：验证项目中文件的合法性和权限。 compile：编译项目，生成target文件夹。 test：可以运行test包下的所有测试方法。 package：将项目打包成.jar或.war。 verify：验证打包是否有效且合法。 install：可以将打包生成的jar包复制到本地仓库中。 site：建立远程站点。 deploy：把本地仓库传输到远端部署。 依赖管理scope作用域：在导入依赖时，可以对依赖所影响的作用域进行限制，使用标签即可。 作用域有以下几种： test：仅在test包下有效，在main包下无效。 provide：在编译时生效，在运行时失效。主要用于对依赖的版本控制，如对旧依赖使用provide作用域。 runtime：在编译时失效，在运行时生效。主要用于面向接口编程时对编程的规范，如JDBC，在使用JDBC的方法时，由于编译时使用的是java自带的接口，运行时才使用导入的驱动包中的实现类，所以此时编译并不会报错，且可以正常运行。 compile：默认作用域，作用于全局。 依赖传递：依赖具有传递性。如A依赖引入了B依赖，B依赖引入了C依赖，那么A依赖就一定也会引入C依赖。 依赖冲突：在同一个项目中，导入同一依赖的不同版本，就会发生冲突。冲突的解决方法有： 声明优先原则：指同一依赖的不同版本中，谁先在pom.xml声明，就优先使用谁。 就近原则：指在依赖传递时，谁传递的次数比较少，就优先使用谁。就近原则的优先级高于声明优先原则。 手动排除。 提取常量。在pom.xml顶部事先提取依赖版本，这样就可以避免依赖冲突。 1234567891011121314151617&lt;properties&gt; &lt;!-- 1. 提取了常量之后，可以避免依赖冲突的问题 2. 提取了常量之后，可以方便我们后期管理这些依赖（查看版本，更换版本） --&gt; &lt;spring.version&gt;5.3.3&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 清理Maven在本地仓库下寻找含有lastupdated和part关键字的文件，删除之。 JunitJunit是一种测试工具，可以运行指定的方法。 Junit有以下五种注解： @Test：单元测试。修饰的方法必须是public void，必须没有参数。 @After：在测试执行后执行。 @Before：在测试执行前执行。 @AfterClass：在测试类类加载前执行。 @BeforeClass：在测试类中的全部方法执行完毕后执行。 其中，@AfterClass、@BeforeClass必须修饰静态方法。 测试类必须放在test包下。 测试类一般命名为XxxTest，测试方法一般命名为testXxx。 MybatisMybatis是一种ORM框架。ORM意为对象关系映射，即是将SQL中的数据转化为Java对象，或是将Java对象转化为SQL记录。Mybatis可以帮我们在Java中更高效的操作数据库。 Mybatis需要一个主配置文件，用于获取SqlSessionFactory。SqlSessionFactory时一个工厂，用于生产SqlSession实例对象。SqlSession是一种Mybatis框架与数据库的连接，里面封装了Connection对象。 配置文件样例如下。 123456789101112131415161718192021222324252627&lt;configuration&gt; &lt;settings&gt; &lt;!-- 添加日志的配置 --&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt; &lt;!-- 环境的配置，其实就是去配置数据库连接--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/40th?useSSL=false&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--&lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 其中标签用于放置SQL语句的配置文件，一般命名为XxxMapper.xml，并放置于Maven项目中的src&#x2F;main&#x2F;resources文件下，且要与src&#x2F;main&#x2F;java中的Mapper接口在相同的路径下。 Mapper配置文件样例如下。 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- mapper.xml 映射文件中的标签没有顺序要求 --&gt;&lt;!-- namespace: 命名空间，需要唯一 --&gt;&lt;mapper namespace=&quot;cskaoyan&quot;&gt; &lt;!--&lt;insert id=&quot;&quot;--&gt; &lt;!--&lt;delete id=&quot;&quot;--&gt; &lt;!--&lt;update id=&quot;&quot;--&gt; &lt;!--&lt;select id=&quot;&quot;/&gt;--&gt; &lt;!-- 后续如何找到这个标签中的SQL语句呢？ namespace.id = 这个SQL语句的坐标 id: 指这个SQL语句的位置，每一个标签的id不能重复 resultType：结果的类型 --&gt; &lt;select id=&quot;selectAccountById&quot; resultType=&quot;com.cskaoyan.bean.Account&quot;&gt; select * from account where id = #&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;selectAccountList&quot; resultType=&quot;com.cskaoyan.bean.Account&quot;&gt; select * from account &lt;/select&gt;&lt;/mapper&gt; Mybatis的动态代理功能可以根据Mapper配置文件和由用户制定的Mapper接口，自动生成接口的代理对象，但是对Mapper接口有如下要求： 接口的全限定名需与Mapper.xml下的标签中的值保持一致。 接口的方法要与Mapper.xml下的 标签 一一对应，并且方法名要和标签的id值保持一致。 方法的返回类型必须与标签中的resultType保持一致。 接口文件名和配置文件名需保持一致，且配置文件在resources文件夹下的相对路径要与接口文件在java文件夹下的相对路径一致。 Mybatis的使用样例如下。 1234567891011121314151617181920212223public static void main(String[] args) throws IOException &#123; // 目的：要去执行sql语句 // 1. 读取配置文件 InputStream stream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); // 2. 获取SqlSessionFactory SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(stream); // 3. 执行SQL语句,其中true表示自动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(true); // 获取代理对象 StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); // 找到对应给的SQL语句，并且执行 String name = studentMapper.selectNameById(1); System.out.println(name);&#125; 输入映射在Mapper接口中的参数需要映射至Mapper配置文件中，需要遵守一些规则。 传入的参数在Mapper中需要使用#&#123;XXX&#125;来取值。 如果在Mapper接口中对参数进行了@Param注解修饰别名，那么在Mapper配置文件中必须使用该别名。 如果Mapper接口中传入的是对象，那么在Mapper配置文件中必须使用#&#123;成员变量名&#125;来取值。如果对象有注解，可以通过#&#123;注解值.成员变量名&#125;来取值。 传值时可以使用#{}和${}两种不同的传值方式，其中#{}表示是预编译占位，${}表示是字符串拼接。一般而言，我们都使用#{}传值，但是如果我们需要对SQL语句传入表名和列名时，则需要使用${}。 输出映射在Mapper配置文件中执行SQL语句后的结果会转换为一个Java对象，转换时也需要遵守一些规则。 映射的类型由Mapper配置文件中SQL语句标签里的resultType或resultMap指定，且Mapper接口中的返回类型要与其一致。 如果返回有多个值，在Mapper接口中需定义数组或集合，但是resultType只需要指定单个元素的类型即可。 如果返回的有多个列，那么需要在java文件中定义一个JavaBean对象来作为返回类型。此时Mybatis会把对象中的成员变量名和查询结果的列名一一映射，如果原始表中的列名与成员变量名不一致，可以通过@Param取别名，或者是resultMap来解决。在声明JavaBean对象的成员变量时，尽量使用包装类型，方便寻找错误。 resultMap一般用于对SQL的查询结果进行再次映射，一般用于修改原始表列名和多表查询。resultMap的使用样例如下。 12345678910111213141516171819&lt;resultMap id=&quot;studentMap&quot; type=&quot;com.cskaoyan.bean.Student&quot;&gt; &lt;!-- id:映射主键值的标签 column: 列名 property: 成员变量名 result: 映射普通列的 --&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectStudentByIdWithResultMap&quot; resultMap=&quot;studentMap&quot;&gt; select id,name,age,gender from student where id = #&#123;id&#125;&lt;/select&gt; 动态SQLMybatis可以根据传入的条件，动态的改变SQL语句。 ：可以自动拼接where关键字，并去除相邻的and或or关键字；如果where中没有SQL片段需要拼接，不会拼接where关键字。 ：可以判断传入的参数是否符合条件。需要注意的是，判断中的大于号和小于号为了避免与xml文件中的标签符号冲突，需要写为&amp;gt;和&amp;lt;。 和：可以提取公共的SQL语句，负责引入中的内容。为了保证SQL语句的可读性，并不会滥用这两个标签，它们一般用于提取列名。 ：可以自动拼接set关键字，并去除标签中的最后一个,。 ：可以在SQL中循环取值。一般用于in查询。例子如下。 Mapper.java 12// in 查询List&lt;User&gt; selectUserListByIds(List&lt;Integer&gt; ids); Mapper.xml 123456789&lt;select id=&quot;selectUserListByIds&quot; resultType=&quot;com.cskaoyan.bean.User&quot;&gt; &lt;!-- select * from user where id in (?,?,?,?,?,?,?)--&gt; select &lt;include refid=&quot;all_column&quot;/&gt; from user where id in &lt;foreach collection=&quot;collection&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/select&gt; : 可以在执行目标SQL语句之前或之后执行一条额外的SQL语句。例子如下。 1234567891011&lt;insert id=&quot;insertUserWithReturnId&quot;&gt; insert into user values (null,#&#123;user.name&#125;,#&#123;user.age&#125;,#&#123;user.nickname&#125;)&lt;!--order: 表示在目标SQL执行之前或者是之后执行 AFTER | BEFOREkeyProperty： 表示执行的结果映射到哪个参数中resultType: SQL语句返回的类型--&gt;&lt;selectKey order=&quot;AFTER&quot; keyProperty=&quot;user.id&quot; resultType=&quot;int&quot;&gt; select LAST_INSERT_ID()&lt;/selectKey&gt;&lt;/insert&gt; useGeneratedKeys：仅在insert语句中使用，可以获取插入数据的自增主键。（注意：此时对应的接口返回值仍然是影响行数，id值则是被放在传入的keyProperty中，上面的同理）例子如下。 123456789&lt;!--开启配置：useGeneratedKeys=&quot;true&quot; 映射到对应的参数中：keyProperty=&quot;user.id&quot;--&gt;&lt;insert id=&quot;insertUserWithReturnIdUseGeneratedKeys&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;user.id&quot;&gt; insert into user values (null,#&#123;user.name&#125;,#&#123;user.age&#125;,#&#123;user.nickname&#125;)&lt;/insert&gt; 多表查询多表查询的方式分为分次查询和连接查询。 首先在建立JavaBean对象时，需要在直接查询的A表所映射的对象中放入B表所映射的对象的成员变量。 分次查询：在Mybatis中，一个SQL语句标签只能执行一句SQL语句，分次查询即是使用resultMap来连接两个SQL语句，用一个SQL语句的结果作为另一个SQL语句的传入值。 分次查询的样例如下。 1234567891011121314151617181920212223242526272829303132&lt;!-- 分次查询 --&gt;&lt;select id=&quot;selectUserByName&quot; resultMap=&quot;userMap&quot;&gt; select id,username,nickname,gender,age from user where username = #&#123;name&#125;&lt;/select&gt;&lt;resultMap id=&quot;userMap&quot; type=&quot;com.cskaoyan.bean.User&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;nickname&quot; property=&quot;nickname&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;!-- association：关联单个bean的时候，使用 property：成员变量的名字 javaType: 成员变量的类型 select：关联的第二次查询的SQL语句的坐标，第二次查询和第一次查询在同一个文件中的时候，namespace可以省略 column: 给第二次查询传递的值的列名 --&gt; &lt;association property=&quot;userDetail&quot; javaType=&quot;com.cskaoyan.bean.UserDetail&quot; select=&quot;com.cskaoyan.mapper.UserDetailMapper.selectUserDetailById&quot; column=&quot;id&quot;/&gt; &lt;!-- 第二次查询 --&gt; &lt;select id=&quot;selectUserDetailById&quot; resultType=&quot;com.cskaoyan.bean.UserDetail&quot;&gt; select id,user_id as userId,height,weight,pic from user_detail where user_id = #&#123;id&#125; &lt;/select&gt; 连接查询：连接查询即是利用inner join和resultMap来连接表。 连接查询的样例如下。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- 连接查询 --&gt;&lt;select id=&quot;selectUserByNameUseCrossQuery&quot; resultMap=&quot;userCrossMap&quot;&gt; SELECT user.id, user.username, user.nickname, user.gender, user.age, user_detail.id as uid, user_detail.user_id as userId, user_detail.weight as weight, user_detail.height as height, user_detail.pic as pic FROM user left JOIN user_detail ON user.id = user_detail.user_id WHERE user.username = #&#123;name&#125;&lt;/select&gt;&lt;resultMap id=&quot;userCrossMap&quot; type=&quot;com.cskaoyan.bean.User&quot;&gt; &lt;!-- 映射 user--&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;nickname&quot; property=&quot;nickname&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;!-- 映射userDetail--&gt; &lt;association property=&quot;userDetail&quot; javaType=&quot;com.cskaoyan.bean.UserDetail&quot;&gt; &lt;id column=&quot;uid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;userId&quot; property=&quot;userId&quot;/&gt; &lt;result column=&quot;weight&quot; property=&quot;weight&quot;/&gt; &lt;result column=&quot;height&quot; property=&quot;height&quot;/&gt; &lt;result column=&quot;pic&quot; property=&quot;pic&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; 懒加载和缓存懒加载是指在Mybatis进行分次查询的时候，假如第二次查询的内容没有被使用到的话，那么就不去执行第二次查询的SQL语句，等到用到第二次查询的内容的时候再去执行第二条SQL语句。 Mybatis的默认配置是关闭懒加载，要开启懒加载需要在Mybatis的配置文件中加入如下配置。 123456&lt;settings&gt; &lt;!-- 懒加载 true: 表示开启 false:默认值，表示关闭 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 缓存是指在Mybatis中，单独开辟一块内存空间（map），来存储查询的信息。后续假如再次调用了到了同样的查询，那么就直接查询缓存。 缓存分为一级缓存和二级缓存。 一级缓存是一个SqlSession级别的缓存。缓存的内容存储在SQLSession中。一级缓存是默认开启的，且无法关闭，只有在SqlSession关闭时，或者SqlSession调用commit方法会让一级缓存失效。 二级缓存是一个NameSpace级别的缓存，每一个NameSpace都有自己的缓存空间。二级缓存是默认开启的。 在实际工作中，Mybatis的缓存机制并不好用，主要是它无法解决脏数据的问题，且用户不能直接操作缓存，所以在实际工作中会使用Redis替代。"},{"title":"学习总结（2022.05.10-2022.05.16）","path":"2022/05/16/学习总结（2022-05-10-2022-05-16）/","text":"关系型数据库与非关系型数据库关系型数据库：不仅存储数据，也存储数据与数据间的关系。一般存储在磁盘上，读取较慢。 非关系型数据库：仅仅用于存储数据，不能存储数据间的关系。但是一般存储在内存中，读取较快。 SQL语句库的操作 123456create database dbName;# 添加库drop database dbName;# 删除库alter database dbName character set utf8 collate utf8_bin;# 修改库的字符集和校对规则(不能修改名字)show databases;# 查询所有的库show create database dbName;# 查询对应库的建库语句use dbName;# 选中库(重要) 表的操作 123456789101112131415create table tableName( columnName1 dataType, columnName2 dataType, ... ) character set utf8 collate utf8_bin;# 创建表(后面为设置表的字符集和校对规则)drop table tableName;# 删除表rename table tableName to newTableName;# 修改表名alter table tableName character set latin1 collate latin1_bin;# 修改表的字符集和校对规则alter table tableName add columnName dataType;# 添加列(列名后跟列的数据类型)alter table tableName drop columnName;# 删除列alter table tableName modify columnName dataType;# 修改列的类型alter table tableName change columnName newColumnName dataType;# 修改列的类型和名字show tables;# 查询所有表describe tableName;# 查询表结构show create table tableName;# 查询建表语句 数据的操作 123456789insert into tableName values (...), (...), ...;# 插入数据delete from tableName columnName = ...;# 删除数据update tableName set columnName = ... where columnName = ...;# 修改数据select * from tableName;# 查找所有数据select columnName from tableName;# 查找该列数据 关键字： where：寻找符合条件的指定数据行。 distinct：过滤结果相同的记录。 limit：限制显示的行数。 as：别名，对查询结果的列和表起名。 order by：排序。可接desc表示降序。 group by：分组。可接having对分组后的结果进行过滤。 聚合函数： max：最大值 min：最小值 avg：平均值 sum：总和 count：计数 SQL语句执行顺序 1234567(5) SELECT column_name, ... (1) FROM table_name, ... (2) [WHERE ...] (3) [GROUP BY ...] (4) [HAVING ...] (6) [ORDER BY ...](7) [Limit ...] 数据完整性实体完整性：确定表中数据是唯一且不重复的，确保用户不会输入重复的数据，实现的关键是主键。主键是一行数据中唯一不允许重复和值为null的字段。主键一般可以自增。在建表时可以声明一个字段为主键。 123create table tableName( columnName dataType PRIMARY KEY auto_increment# 声明为主键且自增) auto_increment=1000# 设置自增的起始数 域完整性：每一个字段都应该有类型以约束值。也可以使用unique（值唯一）和not null（值不为空）来约束值。unique修饰的字段可以为空。 参照完整性：一个表如果存在外键，那么这个外键应该与另一个表的主键相对应。外键使用foreign key来声明。 三大范式第一范式：每一列应该保持原子性。原子性表示表中的数据都是一个不可拆分的最小单元。 第二范式：数据应该有唯一性。唯一性表示每一条数据都有唯一的标识，如主键。 第三范式：数据不应该冗余。 多表查询内连接inner join 12select * from user inner join user_detail on user.id = user_detail.user_id; 外连接outer join 外连接分为左连接和右连接，使用左连接时会保留左表数据，右连接反之。 12select * from user left outer join user_detail on user.id = user_detail.user_id; 嵌套查询 一个SQL语句的结果可以作为另一个SQL语句的条件。 12select * from student where clazz_id = (select id from clazz where name = &#x27;一班&#x27;); JDBCJDBC是java的一套连接数据库的标准接口。但JDBC只提供接口，具体的实现(如何连接数据库)由数据库厂家的驱动实现，如MySQL的mysql-connector。 JDBC的使用如下。 123456789101112131415161718192021222324252627282930313233343536373839// 1.加载驱动 DriverManager.registerDriver(new Driver());// String url = &quot;协议 + ip + 端口 + 路径 + 参数&quot;; String url = &quot;jdbc:mysql://localhost:3306/40th?useSSL=false&amp;characterEncoding=utf8&quot;; String username = &quot;root&quot;; String password = &quot;123456&quot;; // 2.发送用户名和密码，建立连接 // 返回的当前是一个Connection接口，但是实际上在运行的时候，返回是Connection接口的实现类的实例 Connection connection = DriverManager.getConnection(url, username, password); // 3.获取statement对象 Statement statement = connection.createStatement(); // 4.发送SQL语句// 增删改使用executeUpdate方法 int affectedRows = statement.executeUpdate(&quot;insert into stu values (4,&#x27;云飞兄&#x27;,20,&#x27;358班&#x27;)&quot;);// 查使用executeQuery方法ResultSet resultSet = statement.executeQuery(&quot;select * from stu&quot;); // 5.解析结果集 System.out.println(&quot;affectedRows:&quot; + affectedRows);while (resultSet.next()) &#123; int id = resultSet.getInt(&quot;id&quot;); String name = resultSet.getString(&quot;name&quot;); int age = resultSet.getInt(&quot;age&quot;); String className = resultSet.getString(&quot;class&quot;); System.out.println(&quot;id:&quot; + id); System.out.println(&quot;name:&quot; + name); System.out.println(&quot;age:&quot; + age); System.out.println(&quot;className:&quot; + className);&#125; // 6.断开连接resultSet.close(); statement.close(); connection.close(); 数据库注入在使用Statement时，如果输入的SQL语句是字符串拼接而成的，那么用户就可能输入一些包含SQL关键字的字符，这样就可能改变SQL语句的格式，引发安全性的问题。 解决方式是使用PreparedStatement(预编译的Statement)。 1234567891011// 在创建PreparedStatement的时候，PreparedStatement会把当前这个没有参数的SQL语句，发送给MySQL服务器，执行预编译// 预编译：其实就是去解析这个SQL语句中的关键字，变成MySQL可以执行的命令// 在预编译之后，后续输入的字符串，就只会被MySQL当成纯文本来解析PreparedStatement preparedStatement = connection.prepareStatement(&quot;select * from user where name = ? and password = ?&quot;);// 设置参数preparedStatement.setString(1,username);preparedStatement.setString(2,password);// 传递参数，执行SQL语句ResultSet resultSet = preparedStatement.executeQuery(); 在安全性上，PreparedStatement要比Statement安全；在效率上，因为PreparedStatement需要与数据库通信两次，一次传输预编译的SQL语句，一次传输参数，所以相比于只通信一次的Statement要慢一些。 批处理对SQL语句有三种批处理的方式： for循环插入 12345678910111213// for循环public static void batchUseForEach() throws SQLException &#123; Statement statement = connection.createStatement(); for (int i = 0; i &lt; 10000; i++) &#123; String sql = &quot;insert into user values (&quot;+i+&quot;,&#x27;foreach&#x27;,null,null)&quot;; statement.executeUpdate(sql); &#125;&#125; statement批处理 12345678910111213// Statement处理public static void batchUseStatement() throws SQLException &#123; Statement statement = connection.createStatement(); for (int i = 10000; i &lt; 20000; i++) &#123; String sql = &quot;insert into user values (&quot;+i+&quot;,&#x27;batchUseStatement&#x27;,null,null)&quot;; statement.addBatch(sql); &#125; // 发送SQL语句，执行 statement.executeBatch();&#125; PreparedStatement批处理 需要在数据库的url后面加上配置rewriteBatchedStatements=true ，表示开启批处理。 12345678910111213141516// PreparedStatement处理public static void batchUsePrepapreStatement() throws SQLException &#123; // 获取PreparedStatement PreparedStatement preparedStatement = connection.prepareStatement(&quot;insert into user values (?,?,null,null)&quot;); // 循环，设置参数 for (int i = 20000; i &lt; 30000; i++) &#123; preparedStatement.setInt(1,i); preparedStatement.setString(2,&quot;PrepapreStatement&quot;); preparedStatement.addBatch(); &#125; // 把参数发送给MySQL服务器，执行SQL语句 preparedStatement.executeBatch();&#125; 由代码可知，三种方式与SQL服务器的通信次数、SQL语句的编译次数和执行次数如下表。 通信次数 编译次数 执行次数 时间 for循环 n n n 最长 Statement 1 n n 次之 PreparedStatement 2 1 1 最短 然而通过实际测试发现在数据较大（&gt;&#x3D; 1000000）的情况下statement批处理的时间要长于for循环，可能原因是操作系统对内存的分配：在for循环中，每一次循环时操作系统不必去一直维护内存，在一次循环结束后可以将内存释放；而statement批处理时操作系统需要维护内存去记录sql语句，这导致了statement批处理的时间变长。 事务事务是指组成事务的一组操作，这些操作要么一起操作成功，要么一起操作不成功。 事务具有四个特性： 原子性。事务是一个不可分割的操作单元，里面的一组操作要么都成功，要么都不成功。 一致性。事务必须使数据库从一个一致性状态到另一个一致性状态（比如无论怎么转账，所有账户的总金额应该不变）。 隔离性。事务与事务间应该互相隔离，互不影响。 持久性。一个事务一旦生效，对数据库的改变是永久的，即事务提交以后就无法回滚。 针对事务的隔离性，提出了事务的四个隔离级别： 读未提交 读已提交 可重复读 串行化 在这些隔离级别中，会出现如下三个隔离问题： 脏读。即一个事务读取到了另一个事务还未提交的数据。 不可重复读，即在同一个事务中读取同一个数据，前后读取的数据不一致。一般是一个事务读取到了另一个事务修改的数据。 虚幻读，即在同一个事务中读取同一个数据，前后读取的数据不一致。一般是一个事务读取到了另一个事务插入或删除的数据。 四个隔离级别在处理三个隔离问题的能力如下 脏读 不可重复读 虚幻读 读未提交（read uncommitted） √ √ √ 读已提交（read committed） X √ √ 可重复读（repeatable read） X X √ 串行化（serializable） X X X 在MySQL中，默认的隔离级别是可重复读。MySQL通过自身解决了部分虚幻读的问题，但并没有完全解决。 串行化虽然安全级别最高，但是此时数据库完全丧失了多线程的能力，在一个事务操作期间，其他事务都会变成阻塞状态，数据库的效率会因此下降。 在JDBC中，开启事务的API如下。 12345678// 开启事务connection.setAutoCommit(false);// 提交事务connection.commit();// 回滚事务connection.rollback(); DatasourceDatasource具体指的是数据库连接池。数据库连接池是利用池化的思想，把数据库连接存放在池中，在我们需要连接时，从池里获取连接；用完之后再放回池中，这样就避免了反复创建、销毁连接，提高程序的效率。 目前使用的第三方数据库连接池有三个：DBCP、c3p0、Druid。 DBCP：需要使用properties配置文件配置。 123456username=rootpassword=123456url=jdbc:mysql://localhost:3306/40thdriverClassName=com.mysql.jdbc.DriverconnectionProperties=useSSL=false;characterEncoding=utf8initialSize=10 1234567// 加载配置文件Properties properties = new Properties();properties.load(new FileInputStream(&quot;dbcp.properties&quot;));// 获取连接DataSource dataSource = BasicDataSourceFactory.createDataSource(properties);Connection connection = dataSource.getConnection(); c3p0：需要使用xml文件配置。 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 在xml文件中，有一些特殊字符会有歧义，会报错，这些字符需要写转义字符 &amp; &gt; &lt; 转义字符 &amp; &amp;amp; &lt; &amp;lt; &gt; &amp;gt; --&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/40th?useSSL=false&amp;amp;characterEncoding=utf8&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxStatements&quot;&gt;200&lt;/property&gt; &lt;/default-config&gt;&lt;/c3p0-config&gt; 使用方式同DBCP，只是dataSource改为c3p0的。 1dataSource = new ComboPooledDataSource(); Druid：需要使用properties配置文件配置。 1234username=rootpassword=123456url=jdbc:mysql://localhost:3306/40th?useSSL=false&amp;characterEncoding=utf8driverClassName=com.mysql.jdbc.Driver 使用方式同DBCP，只是dataSource改为Druid的。 1dataSource = DruidDataSourceFactory.createDataSource(properties); DBUtilsDBUtils是一个可以帮助提高JDBC开发效率的框架。主要使用下面三个类。 DBUtils：可以关闭连接、提交事务等。 1234567891011// 关闭连接public static void close(Connection conn) throws SQLException;// 关闭ResultSetpublic static void close(ResultSet rs) throws SQLException;// 关闭statementpublic static void close(Statement stmt) throws SQLException;// 提交并且关闭public static void commitAndClose(Connection conn) throws SQLException; QueryRunner：可以执行SQL语句并获取结果集。 12345678// 构造无参的queryRunnerQueryRunner queryRunner = new QueryRunner();// 构造QueryRunnerDataSource dataSource = DruidUtils.getDataSource();QueryRunner queryRunner = new QueryRunner(dataSource);// 获取增删改影响的行数int affectedRows = queryRunner.update(&quot;update stu set name = ? where id = ?&quot;, &quot;嘉靖皇帝&quot;, 4); ResultSetHandler：可以帮助解析结果集，但本身是接口，实际用的是以下的具体实现。 // BeanHandler，把结果集中的第一行数据转化为一个JavaBean Stu stu = queryRunner.query(&quot;select id,name,age,class as clazz from stu where id = ?&quot;,new BeanHandler&lt;&gt;(Stu.class),2); // BeanListHandler，把结果集对象解析为一个 BeanList List&lt;Stu&gt; stuList = queryRunner.query(&quot;select id,name,age,class as clazz from stu&quot;,new BeanListHandler&lt;&gt;(Stu.class)); // MapHandler，把结果集中的第一行记录解析为一个Map Map&lt;String, Object&gt; map = queryRunner.query(&quot;select * from stu&quot;, new MapHandler()); // MapListHandler，把结果集中的记录 映射到一个 List&lt;map&lt;String,Object&gt;&gt; 对象中 List&lt;Map&lt;String, Object&gt;&gt; mapList = queryRunner.query(&quot;select * from stu&quot;, new MapListHandler()); // ColumnListHandler，用来接收单列值的解析结果。 List&lt;Object&gt; list = queryRunner.query(&quot;select name from student&quot;, new ColumnListHandler&lt;&gt;()); // ScalarHandler，用来处理查询结果是单个值的情况。 Long count = queryRunner.query(&quot;select count(*) from student&quot;, new ScalarHandler&lt;Long&gt;());"},{"title":"学习总结（2022.05.01-2022.05.09）","path":"2022/05/10/学习总结（2022-05-01-2022-05-09）/","text":"HTMLHTML是一个用标签描述的文本语言。 HTML初始格式为： 12345678910&lt;!DOCTYPE html&gt; 语法声明: 声明使用HTML5语法&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; meta: 描述网页的元信息 &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; 重要标签（了解即可）： 123456789101112&lt;hr&gt; : 横线标签, 单标签&lt;br&gt; : 换行标签, 单标签&lt;h1&gt;&lt;h2&gt;&lt;h3&gt;&lt;h4&gt;&lt;h5&gt;&lt;h6&gt; : 标题标签, 双标签&lt;div&gt; : 分区或者节给一个页面, 双标签&lt;p&gt; : 段落标签, 双标签&lt;a&gt; : 超链接标签, 双标签&lt;img&gt; : 图片标签, 单标签&lt;ol&gt;: 有序列表, 和&lt;li&gt;标签共同构成一套标签&lt;ul&gt;: 无序列表, 和&lt;li&gt;标签共同构成一套标签&lt;table&gt;: 表格标签, 定义一个表格 (和tr, td, th ...构成成套标签) &lt;tr&gt; : 一个表格中的一行 &lt;td&gt; : 一行中的一个单元格 表单元素：表单元素会根据元素内的内容生成一个url，对后端发起请求，并根据请求获得内容。生成的url中分为非参数部分和参数部分，例子如下： 12https://s.taobao.com/search?q=鞋子 非参数 | 参数 非参数部分由表单元素的action属性提供，参数则由表单元素的其他属性提供。 表单元素中有一个method属性，它决定了表单元素在提交表单时使用的HTTP方法：GET&#x2F;POST。GET一般用于获取数据，POST一般用于提交数据；GET请求一般把请求参数直接拼接在url之后，POST请求一般把参数放在传输的正文中；GET请求不安全（可以被用户直接观察到），POST请求安全。 表单元素根据自身的name属性和value属性生成一个键值对数据，通过传输该数据完成与后端的交互。 常见表单元素： 123&lt;input&gt; : 单标签, 表示一个输入框&lt;textarea&gt; : 多行文本, 相当于一个可以输入多行内容的input&lt;select&gt; : 下拉选择, 和&lt;option&gt; 是一套标签 CSSCSS主要用于对HTML的文本、图片和版面的布局等显示样式。 CSS通过选择器将HTML代码和CSS代码关联。选择器的类型有标签选择器&#x2F;类选择器&#x2F;id选择器。 12345678910111213141516171819202122&lt;style&gt; /* 标签选择器 */ div&#123; width: 100px; height: 100px; background: red; &#125; /* 类选择器 */ .div1&#123; width: 100px; height: 100px; background: red; color: white; font-size: 30px; &#125; /* id选择器 */ #div2&#123; width: 100px; height: 100px; background: #c9ffe3; &#125;&lt;/style&gt; 选择器的优先级是id选择器 &gt; 类选择器 &gt; 标签选择器。如果存在两个同优先级选择器，优先选择较近的选择器（本质是HTML的解析模式为从上到下解析）。 盒子模型：一个HTML标签在页面上占据的空间。这个空间分为四个结构：元素内容区域、内边距区域(padding)、边框区域(border)、外边距区域(margin)。盒子模型的作用是使布局模块化，方便整个布局和个体布局的设计。根据盒子模型种类的不同，可以将标签元素分为三种： 块级元素：独占一行，从上到下排布；可以直接控制宽高&#x2F;内外边距，一般用于大布局的搭建。如：div、p、form、table 行级元素：不独占一行，与其他行级元素从左到右一行显示；只能控制内外边距，宽高受本身内容大小控制；一般用于小结构的搭建。如：span、a、br 行内块：本质属于行级元素，但是可以设置宽高。如：input、img、select JavaScriptJS是一种轻量级、弱类型的语言，主要用于在HTML中添加交互行为。 JS的引入方式有两种。一种是直接在HTML中的script标签内部引入，一种是在script标签的src属性中导入外部的JS文件。 类型：统一用var声明，数据类型由赋值类型决定。数据类型一般有：Number，String，Array 函数：使用function声明。 DOMDOM全称为文档对象模型，是一种将HTML文档视为树结构的理论，这种树结构也被称为DOM树。 DOM树的节点拥有层级关系，从顶端的文档节点开始，依次往下是： 由HTML元素构成的元素节点 HTML属性构成的属性节点 HTML元素内文本构成的文本节点 根据DOM理论，可以知道一个HTML文件的加载顺序： 解析HTML结构，构建DOM树 加载外部脚本(JS)和样式表文件(CSS) 解析并执行脚本代码 构造DOM模型，完成后根据DOM树显示页面。 JS中与DOM相关的操作有： 获取节点： document.getElementById()document.getElementsByName()document.getElementsByTagName() 添加节点： document.appendChild() 删除节点： document.removeChild() 替换节点： document.replaceChild()"},{"title":"Hexo美化记录","path":"2022/05/04/Hexo美化记录/","text":"一些Hexo美化技术分享 live 2D在git中输入$ npm install --save hexo-helper-live2d安装live 2D插件。 在_config.yml文件下添加如下配置 1234567891011live2d: enable: true scriptFrom: local model: use: live2d-widget-model-haruto #模型选择，与文件包同名 display: position: right #模型位置 width: 150 #模型宽度 height: 300 #模型高度 mobile: show: false #是否在手机端显示 再次在git中输入npm install packagename，packagename为https://github.com/xiazeyu/live2d-widget-models下的live 2D文件包。 动态背景在主题文件夹下的layout\\layout.ejs中加入如下代码 1234&lt;!--动态线条背景--&gt;&lt;script type=&quot;text/javascript&quot;color=&quot;220,220,220&quot; opacity=&#x27;0.7&#x27; zIndex=&quot;-2&quot; count=&quot;200&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt; 注意一定要放在&lt;body&gt;中。 网页标题优化在主题文件夹下的source\\js中新建一个FunnyTitle.js 文件，在里面填写如下代码： 12345678910111213141516var OriginTitle = document.title;var titleTime;document.addEventListener(&#x27;visibilitychange&#x27;, function () &#123; if (document.hidden) &#123; $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/img/trhx2.png&quot;); document.title = &#x27;ヽ(●-`Д´-)ノ你丑你就走！&#x27;; clearTimeout(titleTime); &#125; else &#123; $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/img/trhx2.png&quot;); document.title = &#x27;ヾ(Ő∀Ő3)ノ你帅就回来！&#x27; + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125;&#125;); 在主题文件夹下的layout\\layout.ejs中加入如下代码： 12&lt;!--浏览器搞笑标题--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;\\js\\FunnyTitle.js&quot;&gt;&lt;/script&gt; 更多美化可以访问该知乎文章：https://zhuanlan.zhihu.com/p/69211731"},{"title":"学习总结（2022.04.25-2022.04.30）","path":"2022/04/30/学习总结（2022-04-25-2022-04-30）/","text":"数组和链表数组添加的时间复杂度: o(n) 数组删除的时间复杂度: o(n) 数组按下标查找的时间复杂度: o(1) 无序数组按值查找的时间复杂度: o(n) 有序数组按值查找的时间复杂度: o(logn) 链表的添加时间复杂度: o(1) 链表的删除时间复杂度: o(1) 链表的查找时间复杂度: o(n) 泛型泛型，就是参数化类型，在不确定传入的类型时，可以先设置一个参数来代指（类似于形参）。 基本语法如下： 123class 类名&lt;泛型类型1,…&gt;interface 接口名&lt;泛型类型1…&gt;public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 .) 可以定义多个泛型，但是最好不超过两个，如果需要两个以上的泛型，说明设计有问题。 在泛型类上定义的泛型，作用域仅在类名和类体内，即使是子类也不能继承。 泛型通配：？为泛型通配符，没有明确，就是Object以及任意类；？ extends E为向下限定，只能是E及其子类；？ super E为向上限定，只能是E及其父类。 泛型擦除：java中的泛型并不是真正的泛型，在编译之后，泛型会变成Object以及类型强转，泛型只是防止程序员对类型的随意转换。 红黑树红黑树是一个特殊的二叉搜索树，每个节点有红色和黑色两种颜色。 其中根节点和叶子（nil，叶子节点下的空节点）必须是黑色；父子节点不能都是红色节点；从叶子到根节点的路径上，黑色节点的数目是一样的。（黑高平衡） 红黑树通过旋转（类似于二叉搜索树）和分裂（类似于B树，向上和向下）保证黑高平衡和无连续红色节点。 集合类CollectionCollection是Collection集合体系的顶级接口，定义为一个数据容器。 Collection的子实现一些存储元素有序，一些存储元素无序；一些允许存储重复元素，一些不允许存储重复元素；一些允许存储null，一些不允许存储null。 API： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ------------------------------增删改查相关的api------------------------------// boolean add(E e)// 确保此 collection 包含指定的元素（可选操作）。// boolean addAll(Collection&lt;? extends E&gt; c)// 将指定 collection 中的所有元素都添加到此 collection 中（可选操作）。// boolean contains(Object o)// 如果此 collection 包含指定的元素，则返回 true。// boolean containsAll(Collection&lt;?&gt; c)// 如果此 collection 包含指定 collection 中的所有元素，则返回 true。 // boolean remove(Object o)// 从此 collection 中移除指定元素的单个实例，如果存在的话（可选操作）。// boolean removeAll(Collection&lt;?&gt; c)// 移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）。// boolean retainAll(Collection&lt;?&gt; c)// 仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）。 // ---------------------------------------集合类都具有的辅助方法----------------- // void clear()// 移除此 collection 中的所有元素（可选操作）。// boolean equals(Object o)// 比较此 collection 与指定对象是否相等。// int hashCode()// 返回此 collection 的哈希码值。// boolean isEmpty()// 如果此 collection 不包含元素，则返回 true。// int size()// 返回此 collection 中的元素数。 // ------------------------------------------特殊方法--------------------------// Object[] toArray()// 返回包含此 collection 中所有元素的数组。 // &lt;T&gt; T[] toArray(T[] a)// 返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同。// 只有数组类型与存储的数据类型相匹配，才能正常运行；如果传入的数组够长，那么返回的数组和传入的数组是一个数组，反之则不是；如果传入的数组过长，那么空位位置会置为null。// Iterator&lt;E&gt; iterator()// 返回在此 collection 的元素上进行迭代的迭代器。// Iterator类型的方法：// hasNext(): 向后还有没有元素可以遍历// next(): 向后遍历// remove(): 删除刚刚遍历过的元素; // 注意：java中的增强for循环就是由iterator方法实现的（数组不一样，数组的增强for循环在编译中是变成普通的fori循环） 并发修改异常：collection的一些子实现是线程不安全的，在使用Iterator遍历时会产生线程安全问题。所以一些子实现会维护一个标记，记录修改次数，每次修改次数都会增加。 Iterator对象遍历前，都会检查修改次数是否与原集合类一致，如果不一致，就会认为数据被其他线程修改，从而抛出并发修改异常。 但是即使在单线程情况下，如果在遍历过程中直接使用集合类的修改方法，也会抛出并发修改异常。所以在Iterator对象遍历时不要修改数据。 ListList是Collection的子接口，描述的数据结构是线性表。 List有序，允许存储重复元素，允许存储null。 API： 12345678910111213141516171819202122232425262728293031// void add(int index, E element)// 在列表的指定位置插入指定元素（可选操作）。 // boolean addAll(int index, Collection&lt;? extends E&gt; c)// 将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作）。 // E get(int index)// 返回列表中指定位置的元素。 // int indexOf(Object o)// 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。 // int lastIndexOf(Object o)// 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。// E remove(int index)// 移除列表中指定位置的元素（可选操作）。 // E set(int index, E element)// 用指定元素替换列表中指定位置的元素（可选操作）。// ListIterator&lt;E&gt; listIterator()// 返回此列表元素的列表迭代器（按适当顺序）。// ListIterator&lt;E&gt; listIterator(int index)// 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。// ListIterator类型的方法：// hasNext(): 向后还有没有元素可以遍历// next(): 向后遍历// remove(): 删除刚刚遍历过的元素; // hasPrevious(): 向前是否可以遍历// previous(): 向前遍历// List&lt;E&gt; subList(int fromIndex, int toIndex)// 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图。// subList并不是从源集合类中复制了数据，而是维护了一些标记指向源数据，在subList上操作，本质还是在操作源数据。// 所以不建议在使用subList中修改源数据，可能抛出并发修改异常。 ArrayListArrayList是List的子实现，描述的数据结构是线性表。 其底层结构是数组，数组默认长度为10，扩容倍数为1.5倍。 ArrayList存储结构有序，允许存储重复元素，允许存储null。 ArrayList线程不安全。 构造方法： 123456// ArrayList() // 构造一个初始容量为 10 的空列表。 // ArrayList(Collection&lt;? extends E&gt; c) // 构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。 // ArrayList(int initialCapacity) // 构造一个具有指定初始容量的空列表。 API： 123456// Object clone()// 返回此 ArrayList 实例的浅表副本。// void ensureCapacity(int minCapacity)// 如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。// void trimToSize()// 将此 ArrayList 实例的容量调整为列表的当前大小。 VectorVector是List的子类。描述的数据结构是线性表。 其底层结构是数组，数组默认长度为10，扩容倍数为2倍。 Vector存储结构有序，允许存储重复元素，允许存储null。 Vector线程安全。 LinkedListLinkedList是List的子实现，也是Deque的子实现。描述的数据结构是线性表&#x2F;队列&#x2F;双端队列&#x2F;栈 其底层是双向链表。 LinkedList存储结构有序，允许存储重复元素，允许存储null。 LinkedList线程不安全。 构造方法： 1234// LinkedList() // 构造一个空列表。 // LinkedList(Collection&lt;? extends E&gt; c) // 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。 API: 123456789101112131415161718192021222324252627// 队列API// boolean offer(E e)// 将指定元素添加到此列表的末尾（最后一个元素）。// E poll()// 获取并移除此列表的头（第一个元素）// E peek()// 获取但不移除此列表的头（第一个元素）。// 双端队列API// boolean offerFirst(E e)// 在此列表的开头插入指定的元素。// boolean offerLast(E e)// 在此列表末尾插入指定的元素。// E peekFirst()// 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。// E peekLast()// 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。// E pollFirst()// 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。// E pollLast()// 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。// 栈API// E pop()// 从此列表所表示的堆栈处弹出一个元素。// void push(E e)// 将元素推入此列表所表示的堆栈。 QueueQueue是Collection的子接口，描述的数据结构是队列。 Queue存储元素有序，允许存储重复元素，不允许存储null。（因为Queue的poll方法返回null表示队列无元素，为避免混淆，所以不允许存储null） API: 123456789101112// boolean offer(E e)// 在队列中添加数据// E peek()// 查看队头元素// E poll()// 出队头// boolean add(E e)// 添加数据// E element()// 查看头元素// E remove()// 删除头元素 DequeDeque是Queue接口的一个子接口，描述的数据结构是队列&#x2F;双端队列&#x2F;栈。 Deque存储元素有序，允许存储重复元素，不允许存储null。 ArrayDequeArrayDeque是Deque接口的子实现。描述的数据结构是队列&#x2F;双端队列&#x2F;栈。 其底层结构是循环数组，数组默认长度为16，扩容倍数为2倍。 ArrayDeque存储元素有序，允许存储重复元素，不允许存储null。 ArrayDeque线程不安全。 BlockingQueueBlockingQueue是Queue的一个子接口，描述的数据结构是阻塞队列。 阻塞队列：大小有限的队列，常用于线程池。队满时，添加线程等待；队空时，删除线程等待。 SetSet接口是Collection的一个子接口，描述的数据结构是集合。 Set的子实现一些有序，一些无序；都不允许存储重复元素；一些允许存储null，一些不允许存储null。 HashSetHashSet是Set接口的子实现。 其底层结构是HashMap，HashSet添加的对象其实是HashMap的key值。 HashSet存储元素无序；不允许存储重复元素；允许存储null。 HashSet线程不安全。 构造方法： 12345678// HashSet() // 构造一个新的空 set，其底层 HashMap 实例的默认初始容量是 16，加载因子是 0.75。 // HashSet(Collection&lt;? extends E&gt; c) // 构造一个包含指定 collection 中的元素的新 set。 // HashSet(int initialCapacity) // 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和默认的加载因子（0.75）。 // HashSet(int initialCapacity, float loadFactor) // 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和指定的加载因子。 LinkedHashSetLinkedHashSet是HashSet的子类. 其底层结构是LinkedHashMap。 LinkedHashSet存储元素有序；不允许存储重复元素；允许存储null。 LinkedHashSet线程不安全。 TreeSetTreeSet是Set接口的子实现。 其底层结构是TreeMap。 TreeSet存储元素有序；不允许存储重复元素；不允许存储null。 TreeSet线程不安全。 MapMap是Map集合体系的顶级接口，存储key-value数据。 Map的子实现一些存储元素有序，一些存储元素无序；都不允许存储重复数据；一些允许存储null，一些不允许存储null（仅仅指key） API： 123456789101112131415161718192021222324252627282930313233 // -----------------------增删改查的api-------------------------// V put(K key, V value)// 将指定的值与此映射中的指定键关联（可选操作）。// void putAll(Map&lt;? extends K,? extends V&gt; m)// 从指定映射中将所有映射关系复制到此映射中（可选操作）。// V remove(Object key)// 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。// V get(Object key)// 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。// boolean containsKey(Object key)// 如果此映射包含指定键的映射关系，则返回 true。// boolean containsValue(Object value)// 如果此映射将一个或多个键映射到指定值，则返回 true。 // -----------------------集合类都有的api-------------------------// void clear()// 从此映射中移除所有映射关系（可选操作）。// boolean equals(Object o)// 比较指定的对象与此映射是否相等。// int hashCode()// 返回此映射的哈希码值。// boolean isEmpty()// 如果此映射未包含键-值映射关系，则返回 true。 // int size()// 返回此映射中的键-值映射关系数。 // -----------------------视图方法-------------------------// Set&lt;K&gt; keySet()// 返回此映射中包含的键的 Set 视图。// Collection&lt;V&gt; values()// 返回此映射中包含的值的 Collection 视图。// Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()// 返回此映射中包含的映射关系的 Set 视图。 HashMapHashMap是Map接口的具体子实现，底层结构是数组+链表+红黑树。数组的默认初始容量为16，扩容机制为2倍，默认的加载因子为0.75。 （加载因子用来控制HashMap的饱和度，默认阈值为16 * 0.75 &#x3D; 12，如果超过12对键值对，HashMap扩容） HashMap存储元素无序；不允许存储重复的key；允许存储null作为key。 HashMap线程不安全。 HashMap中键值对的Hash值计算：(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); 如果一个新加入的key-value对，它的key值与已经存在的key值满足hash值相等，而且也满足值相等（&#x3D;&#x3D;或equals），说明key值重复，此时会将新value值覆盖掉旧value值，并将旧value值返回出来。 HashMap在某一链表长度大于8时进行以下其中一种操作：当数组长度小于64时，会扩容数组并进行再散列；当数组长度大于等于64时，则会将链表转化为红黑树。 HashMap在删除节点时，如果删除的是红黑树上的节点，且该节点是红黑树的根节点&#x2F;根节点的左右节点&#x2F;根节点的左节点的左节点，此时会认为红黑树上节点过少，从而使红黑树转化为链表；HashMap在扩容进行再散列时，红黑树会被拆分，如果拆分后红黑树中的节点小于6个，红黑树转化为链表。 构造方法： 12345678// HashMap() // 构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。 // HashMap(int initialCapacity) // 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。 // HashMap(int initialCapacity, float loadFactor) // 构造一个带指定初始容量和加载因子的空 HashMap。 // HashMap(Map&lt;? extends K,? extends V&gt; m) // 构造一个映射关系与指定 Map 相同的新 HashMap。 HashMap没有额外的API，基本继承了Map接口的API。 LinkedHashMapLinkedHashMap是HashMap的一个子类，基本上完全复用了HashMap的底层结构和方法。 LinkedHashMap额外维护了一个双向链表保证迭代顺序。 LinkedHashMap存储元素有序；不允许存储重复的key；允许存储null作为key。 LinkedHashMap线程不安全。 TreeMapTreeMap是Map接口的子实现，描述的数据结构是红黑树。 其底层结构是链表。 TreeMap存储的元素有序；不允许存储重复的key；不允许存储null作为key。 因为TreeMap底层的数据结构是红黑树，所以key值需要比较大小，此时有两种实现比较的方式：存储的key值自身可以实现自然排序；TreeMap提供比较器。 构造方法： 12345678// TreeMap() // 使用键的自然顺序构造一个新的、空的树映射。 // TreeMap(Comparator&lt;? super K&gt; comparator) // 构造一个新的、空的树映射，该映射根据给定比较器进行排序。 // TreeMap(Map&lt;? extends K,? extends V&gt; m) // 构造一个与给定映射具有相同映射关系的新的树映射，该映射根据其键的自然顺序 进行排序。 // TreeMap(SortedMap&lt;K,? extends V&gt; m) // 构造一个与指定有序映射具有相同映射关系和相同排序顺序的新的树映射。 API: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// ------------------------TreeMap定义大小操作相关的api------------------------// Map.Entry&lt;K,V&gt; ceilingEntry(K key)// 大于等于给定key的最小键值对// K ceilingKey(K key)// 大于等于给定key的最小key// Map.Entry&lt;K,V&gt; floorEntry(K key)// 小于等于key的最大的键值对// K floorKey(K key)// 小于等于key最大的key// Map.Entry&lt;K,V&gt; higherEntry(K key)// 大于给定key的最小键值对// K higherKey(K key)// 大于给定key的最小key// Map.Entry&lt;K,V&gt; lowerEntry(K key)// 小于key的最大的键值对// K lowerKey(K key)// 小于key最大的key// Map.Entry&lt;K,V&gt; firstEntry()// 返回最小的键值对// K firstKey()// 返回最小的key// Map.Entry&lt;K,V&gt; lastEntry()// 返回最大的键值对// K lastKey()// 返回最大的key// Map.Entry&lt;K,V&gt; pollFirstEntry()// 删除最小的键值对// Map.Entry&lt;K,V&gt; pollLastEntry()// 删除最大的键值对// ---------------------视图方法-----------------------------// NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)// 返回此映射的部分视图，其键的范围从 fromKey 到 toKey。// SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey)// 返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。// SortedMap&lt;K,V&gt; tailMap(K fromKey)// 返回此映射的部分视图，其键大于等于 fromKey。// NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive)// 返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey。// SortedMap&lt;K,V&gt; headMap(K toKey)// 返回此映射的部分视图，其键值严格小于 toKey。// NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive)// 返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey。 HashTableHashTable是Map的子实现。 其底层结构是数组+链表。数组的初始容量为11，扩容倍数为2倍+1。 HashTable存储的元素无序；不允许存储重复的key；不允许存储null作为key，也不允许存储null作为value。 HashTable线程安全。 StreamStream流是jdk1.8时提供的一种处理集合数据的方法。它提供一种内部迭代的方式，允许我们用多个中间操作来串联成一个管道，如同流式风格，避免了我们在对数据集合进行操作时带来的代码冗长问题。 一个Stream流包括三个模块： 一个数据源，创建流。 多个中间操作，形成流。 一个终止操作，执行流，生成结果。 创建流： 12Collection collection = new ArrayList();Stream stream = collection.stream(); 形成流： 12345678910111213141516171819202122232425262728293031323334353637383940 List&lt;Person&gt; personList = StudentList.personList;// filter:用于通过设置条件过滤元素 // 获取所有北京地区的同学 List&lt;Person&gt; collect = personList.stream() .filter(d -&gt; d.getAddress().equals(Person.Address.BJ)) .collect(Collectors.toList());// distinct:去除重复元素 // 去除重复的同学 List&lt;Person&gt; collect = personList.stream() .distinct() .collect(Collectors.toList());// limit:获取指定数量的元素 // 获取三个年龄大于22岁的同学 List&lt;Person&gt; collect = personList.stream() .filter(d -&gt; d.getAge() &gt; 22) .limit(3) .collect(Collectors.toList());// skip:跳过前n个元素 // 获取年龄大于22岁的同学并跳过第一个 List&lt;Person&gt; collect2 = personList.stream() .filter(d -&gt; d.getAge() &gt; 22) .skip(1) .collect(Collectors.toList());// map:映射每个元素到对应的结果 // 获取所有学生姓名 List&lt;String&gt; collect = personList.stream() .map(a -&gt; a.getName()) .collect(Collectors.toList());// sorted:对流进行排序 // 对高于180的同学根据身高进行排序 List&lt;Person&gt; collect = personList.stream() .filter(a -&gt; a.getHeight() &gt; 180) .sorted(Comparator.comparing(Person::getHeight)) .collect(Collectors.toList()); 执行流： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// anyMatch:检查是否匹配一个元素 // 判断是否存在北京的同学 boolean b1 = personList.stream() .anyMatch(a -&gt; &#123; return a.getAddress() == Person.Address.BJ; &#125;);// allMatch:检查是否匹配所有元素 // 判断是否都是北京的同学 boolean b1 = personList.stream() .allMatch(a -&gt; &#123; return a.getAddress() == Person.Address.BJ; &#125;);// nonematch:检查是否没有匹配元素 // 判断是否不存在深圳的同学 boolean b1 = personList.stream() .noneMatch(a -&gt; &#123; return a.getAddress() == Person.Address.SZ; &#125;);// findAny:返回任意元素（默认第一个） // Optional类作为一个容器代表一个值存在或不存在，方法如下 // isPresent(): 如果 Optional包含值返回true, 否则返回false // ifPresent(代码块): 会将Optional包含的值, 传给指定的代码块 // get(): 如果Optional包含值, 返回包含的值, 否则抛出异常 // orElse(默认值): 如果Optional包含值, 返回包含的值, 否则返回默认值 // 返回任意一个同学 Optional&lt;Person&gt; any = personList.stream() .findAny();// findFirst:返回第一个元素 // 获得年龄最小的同学 Optional&lt;Person&gt; first = personList.stream() .sorted(Comparator.comparing(Person::getAge)) .findFirst();// forEach:遍历输出元素 // 遍历列表，输出学生姓名 personList.stream() .sorted(Comparator.comparing(Person::getAge)) .forEach(a -&gt; System.out.println(a.getName()));// count:返回元素数量 // 北京同学的数量 long count = personList.stream() .filter(a -&gt; a.getAddress() == Person.Address.BJ) .count();// reduce:计算元素 // reduce有双参方法，第一个元素为identity，为计算的初始值 // 班级同学年龄总和 Optional&lt;Integer&gt; reduce1 = personList.stream() .map(Person::getAge) .reduce((a, b) -&gt; &#123; return a + b; &#125;);// collect:收集结果 // 收集结果可以放进List、Map、Set、Collection中 // 获取所有学生姓名，放进List中 List&lt;String&gt; collect = personList.stream() .map(a -&gt; a.getName()) .collect(Collectors.toList());"},{"title":"剑指offer-day23","path":"2022/04/29/剑指offer-day23/","text":"数组中出现次数超过一半的数字最简单的想法当然是用哈希表或者排序，但是最优解是一个算法，叫摩尔投票法。 算法的大致思想是：记录一个投票数，与众数相同则投票数+1，否则-1。因为众数的数量超过数组长度的一半，那么统计整个数组的投票数会大于0。知道这个规律后，唯一的问题是怎么确定一个数是众数。那么就涉及到了第二个规律：数组中的某部分的投票数总和为0，并不会影响整体的票数。现在可以假设数组的第一个元素是众数，向后遍历，遇到相同的数时票数+1，否则-1，如果遇到票数为0的情况，则放弃这一块的遍历情况，转而设置下一个数为众数…直到遍历完成，此时票数一定大于0，指向的数即为众数。 123456789101112131415161718192021class Solution &#123; public int majorityElement(int[] nums) &#123; int vote = 0; int x = 0; for(int num : nums)&#123; // 当票数为0时，假设遍历至此的数为众数 if(vote == 0)&#123; x = num; &#125; // 如果后续遍历的数与该数相等，票数+1，否则-1 if(x == num)&#123; vote++; &#125; else&#123; vote--; &#125; &#125; // 返回最后指向的数 return x; &#125;&#125; 构建乘积数组提示了无法使用除法，那么只能使用乘法，最优解选择的方式是对原数组遍历两遍：第一遍只累乘在自己之前的数，第二遍则累乘在自己之后的数，这样就得到答案了。 1234567891011121314151617181920212223class Solution &#123; public int[] constructArr(int[] a) &#123; // 特殊情况：a为空数组，返回空数组 if(a.length == 0)&#123; return new int[0]; &#125; int[] b = new int[a.length]; // 因为第一个数只有自己之后的数的累乘，所以将b的第一个数置为1 b[0] = 1; // 遍历第一遍，b[i]的值都是在自己之前的数的累乘 for(int i = 1; i &lt; a.length; i++)&#123; b[i] = b[i - 1] * a[i - 1]; &#125; // 记录一个临时值，用来记录b[i]之后的数的累乘 int tmp = 1; // 因为最后一个数只有自己之前的数的累乘，之前已经计算完毕，所以从倒数第二个数开始 for(int i = a.length - 2; i &gt;= 0; i--)&#123; tmp *= a[i + 1]; b[i] *= tmp; &#125; return b; &#125;&#125;"},{"title":"剑指offer-day22","path":"2022/04/28/剑指offer-day22/","text":"数组中数字出现的次数Ⅰ说实话，位运算方面的算法真的很难想，基本都要靠别人的思路，代码虽然简洁但是很难看懂。 这道题目非常像只出现一次的数字，但是只出现一次的数字变成了两个，这说明原来遍历并异或的思路行不通了，但是这个思路是个出发点。在遍历并异或后，就可以获得两个不同的数异或的值，由于异或的特性（一者为0一者为1，结果为1，否则为0），可以确定在结果的二进制中，最低位的1所在的位，在两个数中分别是1和0，那么可以根据这个线索将数组分成两个，一个在该位全是1，另一个则全是0，而且相同的数，它们在该位的数一定相同，那么这两个数组中就是数对相同的数和一个不同的数，对这两个数组进行异或运算，得出来的就是结果了。 1234567891011121314151617181920212223242526272829class Solution &#123; public int[] singleNumbers(int[] nums) &#123; int sum = 0; // 获得整个数组异或后的值 for(int i : nums)&#123; sum ^= i; &#125; int n = 1; // 结果跟1进行与运算，等于0说明结果的倒数第一位是0，n左移一位让1从最低位移到倒数第二位，重复至找到第一个和结果进行与运算的值为1的n，此时n就是结果里最低位为1，其他位为0的值。 while((sum &amp; n) == 0)&#123; n &lt;&lt;= 1; &#125; int x = 0; int y = 0; // 根据n来对数组里每个数进行与运算，数的二进制在该位为0和在该位为1的值分成两组，对这两组分别进行异或运算 for(int i : nums)&#123; if((i &amp; n) != 0)&#123; x ^= i; &#125; else&#123; y ^= i; &#125; &#125; int[] res = &#123;x,y&#125;; return res; &#125;&#125; 数组中数字出现的次数Ⅱ这道题目的最优解引入了一个算法，叫有限状态转换机，但是我看不懂这个算法，只能作罢，直接背代码算了。 123456789101112// 看不懂class Solution &#123; public int singleNumber(int[] nums) &#123; int one = 0; int two = 0; for(int i : nums)&#123; one = one ^ i &amp; ~two; two = two ^ i &amp; ~one; &#125; return one; &#125;&#125; 其实题目并没有限制o(n)时间和o(1)空间，完全是可以用hashmap做的。"},{"title":"剑指offer-day21","path":"2022/04/27/剑指offer-day21/","text":"后面开始涉及位运算与数学知识了，由于这方面比较薄弱，题目基本都是不会做的，就直接看答案吧，争取把答案看懂就行。 二进制中1的个数最简单的想法就是把二进制转为字符串，遍历得到1的个数，当然这不是最优解，最优解是对每一位的数和1进行与运算（与运算，即只有在两数都是1时才返回1，其余可能都返回0），当返回值是1，说明该位位数是1，对计算总和+1，否则+0。然后再将二进制数往右移1位，一直移至n的所有位数都为0（即数的十进制为0）即可。（java中，&gt;&gt; 是右移位数的意思，后面跟的值是右移几位的意思，而 &gt;&gt;&gt; 则是右移的同时在缺失的高位补0）。 1234567891011public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int res = 0; while(n != 0)&#123;// 当n=0时，跳出循环 res += (n &amp; 1);// res累加n和1进行与运算的结果 n &gt;&gt;&gt;= 1;// n右移1位，高位补0 &#125; return res; &#125;&#125; 不用加减乘除做加法题目摆明了要用位运算，最优解是通过观察加法的规律来得出位运算的解决方案。 观察得知，当位数都是0时，它们的和是0，进位是0；当位数有一个是1时，它们的和是1，进位是0；当位数都是1时，它们的和是0，进位是1。可以发现和的计算跟异或运算是一样的（异或运算，即是当两数不相同时，返回值为1，两数相同则返回0），进位的计算跟与运算后是一样的。那么加法可以换算成和与进位的和（其中进位需要左移一位，这样才能体现进位）。 12345678910class Solution &#123; public int add(int a, int b) &#123; while(b != 0) &#123; // 当进位为 0 时跳出 int c = (a &amp; b) &lt;&lt; 1; // c = 进位 a ^= b; // a = 非进位和 b = c; // b = 进位 &#125; return a; &#125;&#125;"},{"title":"剑指offer-day20","path":"2022/04/26/剑指offer-day20/","text":"重建二叉树又是一道知道思路但是不知道怎么实现的题目，直接放答案吧。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int[] preorder; Map&lt;Integer, Integer&gt; inorderMap = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) &#123; this.preorder = preorder; for(int i = 0; i &lt; inorder.length; i++)&#123; inorderMap.put(inorder[i], i); &#125; return recur(0, 0, inorder.length - 1); &#125; public TreeNode recur(int root, int left, int right)&#123; if(left &gt; right)&#123;// 发生越界，返回null return null; &#125; int i = inorderMap.get(preorder[root]);// 获得根节点在中序序列的下标 TreeNode node = new TreeNode(preorder[root]);// 新建根节点 node.left = recur(root + 1, left, i-1);// 根节点的左节点连接递归生成的左子树 node.right = recur(root + 1 + i - left, i+1, right);// 右节点连接递归生成的右子树 return node; &#125;&#125; 数值的整次方如果用简单的迭代会超时，就是摆明了不准用迭代，正确的方式是用变化的二分法，每次将幂数折半，将要累乘的数换成该数的二次方，如果幂数是奇数的话就把多出来的一个数乘进返回值里。 123456789101112131415161718class Solution &#123; public double myPow(double x, int n) &#123; double res = 1; long b = n;// 用long来接int值，防止负数转正数时发生溢出 if(b &lt; 0)&#123;// 幂数小于0，底数要变为分数 b = -b; x = 1 / x; &#125; while(b &gt; 0)&#123; if(b % 2 == 1)&#123;// 幂数为奇数，将多出的数放入答案 res *= x; &#125; x *= x;// 底数变成平方 b /= 2;// 幂数变为一半，向下取整 &#125; return res; &#125;&#125; 二叉搜索树的后序遍历序列完全不会，直接放答案。 1234567891011121314151617class Solution &#123; public boolean verifyPostorder(int[] postorder) &#123; // 用栈存储倒序的后序遍历，即是“根，右，左”的逆序先序遍历 Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int root = Integer.MAX_VALUE; for(int i = postorder.length - 1; i &gt;= 0; i--) &#123; // 因为按照遍历逻辑当前节点一定是父节点的左孩子，如果出现左孩子的值大于父节点，说明不是后序遍历序列，返回false if(postorder[i] &gt; root) return false; // 如果栈顶大于当前节点，说明栈内有当前节点的父节点，出栈至栈空，栈底为父节点 while(!stack.isEmpty() &amp;&amp; stack.peek() &gt; postorder[i]) root = stack.pop(); // 当前节点压栈 stack.add(postorder[i]); &#125; return true; &#125;&#125;"},{"title":"剑指offer-day19","path":"2022/04/25/剑指offer-day19/","text":"求1+2+…+n感觉本质上是一道脑筋急转弯题目，因为迭代和递归的方式都被锁死了，只能另辟蹊径完成，答案用的是逻辑运算符的短路，也见到有人用异常的，我没有想出来，就以答案为标准吧。 123456789class Solution &#123; int res = 0; public int sumNums(int n) &#123; // 运用逻辑运算符短路，递归至n=1时发生短路，后面的递归计算终止 boolean x = n &gt; 1 &amp;&amp; sumNums(n-1) &gt; 0; res += n; return res; &#125;&#125; 二叉搜索树的最近公共祖先自己想出来了递归，答案给的最优解是迭代，但是实际实验过发现两者并没有差别，那就放自己的答案吧。 因为是二叉搜索树，可以利用搜索树的特性，判断两个节点是否在一侧，在哪一侧则往哪边遍历，否则就返回当前的根节点。 12345678910111213141516171819202122/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; // 在左子树往左遍历，在右子树往右遍历 if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123; return lowestCommonAncestor(root.left,p,q); &#125; else if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123; return lowestCommonAncestor(root.right,p,q); &#125; // 两边各一个返回当前根节点 return root; &#125;&#125; 二叉树的最近祖先相比上题少了一个搜索树的条件，显然变难了，自己写的是递归+遍历，有很高的时间复杂度，最优解只使用了递归。 1234567891011121314class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; // 递归终止条件：root为空，或root为p、q中的一个 if(root == null || root == p || root == q) return root; // 递归遍历根节点的左右子树，返回null、p或q TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); // left为空表示p、q都在右子树，返回右子树的根节点，反之同理 if(left == null) return right; if(right == null) return left; // 两者都不为空表示p、q在异侧，直接返回根节点 return root; &#125;&#125;"},{"title":"剑指offer-day18","path":"2022/04/25/剑指offer-day18/","text":"二叉树的深度第一道自己写出来的树题！可以说非常具有纪念意义了，时空复杂度也不输最优解，自豪地放上自己的解。 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int depth; int max; public int maxDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; depth = 0; max = 0; preorder(root); return max; &#125; public void preorder(TreeNode root)&#123;// 前序遍历 depth++;// 遍历该节点，深度+1 if(root == null)&#123;// 若节点为空，说明到达叶节点，深度-1并记录此时的最大深度 depth--; max = Math.max(max,depth); return; &#125; preorder(root.left);// 递归遍历左节点和右节点 preorder(root.right); depth--;// 遍历完成，深度-1 &#125;&#125; 平衡二叉树半写半抄完成的，用的是从上到下的递归，然而并不是最优解，最优解是从下到上的递归+剪枝。使用后序遍历从叶子节点往上遍历，每次遍历时看以该节点为根的子树是否是平衡二叉树，如果是则返回该子树的高度，否则返回-1，表示该树不是平衡二叉树。 123456789101112131415161718class Solution &#123; public boolean isBalanced(TreeNode root) &#123; return recur(root) != -1; &#125; private int recur(TreeNode root) &#123;// 返回平衡二叉树的高度，不是平衡二叉树则返回-1 if (root == null) return 0;// 遍历至叶子节点，返回高度为0 // 遍历左右子树，如果左右子树不是平衡二叉树，返回-1 int left = recur(root.left); if(left == -1) return -1; int right = recur(root.right); if(right == -1) return -1; // 如果左右子树的高度差&lt;2,表示是平衡二叉树，返回该根节点的高度，否则返回-1 return Math.abs(left - right) &lt; 2 ? Math.max(left, right) + 1 : -1; &#125;&#125;"},{"title":"剑指offer-day17","path":"2022/04/23/剑指offer-day17/","text":"最小的k个数非常简单的题目，如果利用Arrays.sort()基本等于白给，可是这就是明着考你排序算法的。我自己手动写了一个快排，虽然还是不太熟悉，多写写就好了。 最优解是利用快排的特点，在基准值左边的数都小于基准值，当基准值的下标为k时，左边则是答案了。 1234567891011121314151617181920212223242526class Solution &#123; public int[] getLeastNumbers(int[] arr, int k) &#123; if (k &gt;= arr.length)&#123;// 特殊值返回：如果k大于数组的长度，直接返回数组 return arr; &#125; return quickSort(arr, k, 0, arr.length - 1); &#125; private int[] quickSort(int[] arr, int k, int l, int r) &#123; int i = l, j = r;// 定义两个指针指向数组的头和尾 while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[j] &gt;= arr[l]) j--;// 找到基准值右边小于基准值的值 while (i &lt; j &amp;&amp; arr[i] &lt;= arr[l]) i++;// 找到基准值左边大于基准值的值 swap(arr, i, j);// 交换值 &#125; swap(arr, i, l);// 交换头/尾指针和基准值指针，使得基准值左边都小于基准值，右边都大于基准值 if (i &gt; k) return quickSort(arr, k, l, i - 1);// 如果基准值在k的右边，则对基准值左边的数组进行快排 if (i &lt; k) return quickSort(arr, k, i + 1, r);// 如果基准值在k的左边，则对基准值右边的数组进行快排 return Arrays.copyOf(arr, k);// 返回0-(k-1)的下标的数组 &#125; private void swap(int[] arr, int i, int j) &#123;// 交换方法 int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125;&#125; 数据流中的中位数看完题目我还嗤之以鼻，这也叫hard题？刷刷写完一提交，过是过了，跑了1600ms… 看了最优解，用到了大根堆和小根堆的知识，代码是不一定看得懂了，只能说尽力而为吧。 12345678910111213141516171819class MedianFinder &#123; Queue&lt;Integer&gt; A, B; public MedianFinder() &#123; A = new PriorityQueue&lt;&gt;(); // 小顶堆，保存较大的一半 B = new PriorityQueue&lt;&gt;((x, y) -&gt; (y - x)); // 大顶堆，保存较小的一半 &#125; public void addNum(int num) &#123; if(A.size() != B.size()) &#123;// 插入数量为奇数， A.add(num); B.add(A.poll()); &#125; else &#123; B.add(num); A.add(B.poll()); &#125; &#125; public double findMedian() &#123; return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;// 如果两堆容量相等，说明此时为偶数，各取堆顶值/2；反之说明为奇数，只取小顶堆中的值。 &#125;&#125;"},{"title":"剑指offer-day16","path":"2022/04/23/剑指offer-day16/","text":"把数组排成最小的数看到题目就想到自然排序了，但是直接使用是不可以的，正确的排序方式应该是看两字符串x和y，是否满足x+y&lt;y+x（比如3和30，如果按默认的字典序排列应该是3在前，但是两者的组合330明显大于303，所以应该是看是否满足330&lt;303,不满足则30排在前面） 1234567891011121314class Solution &#123; public String minNumber(int[] nums) &#123; StringBuffer res = new StringBuffer(); String[] s = new String[nums.length]; for(int i = 0; i &lt; nums.length; i++)&#123;// 将int转为String s[i] = String.valueOf(nums[i]); &#125; Arrays.sort(s, (s1,s2) -&gt; (s1+s2).compareTo(s2+s1));// 实现comparable接口的自然排序 for(String str : s)&#123; res.append(str); &#125; return res.toString(); &#125;&#125; 扑克牌的顺子一开始没有很好的想法，就放弃看答案了。 123456789101112131415class Solution &#123; public boolean isStraight(int[] nums) &#123; int zeroCount = 0; Arrays.sort(nums);// 对数组排序 for(int i = 0; i &lt; nums.length - 1; i++)&#123; if(nums[i] == 0)&#123; zeroCount++;// 记录大小王的个数，在0-2之间 &#125; else if(nums[i] == nums[i+1])&#123;// 出现相等的数表示无法成为顺子 return false; &#125; &#125; return nums[nums.length-1] - nums[zeroCount] &lt; 5;// 用最大的数减去最小的非0数，如果差值小于5说明可以成为顺子 &#125;&#125;"},{"title":"学习总结（2022.04.19-2022.04.24）","path":"2022/04/22/学习总结（2022-04-19-2022-04-24）/","text":"类加载器分类： Bootstrap ClassLoader 根类加载器，负责核心类的加载 Extension ClassLoader 扩展类加载器，负责扩展目录中jar包的加载 Sysetm(App) ClassLoader 系统类加载器&#x2F;应用加载器，负责自定义类的加载 User ClassLoader 自定义类加载器，自定义的类加载器 双亲委派模型：当自定义类进行类加载时，并不是一开始就由系统类加载器进行加载的，而是会交给扩展类加载器，扩展类加载器又会交给根类加载器，但是根类加载器在核心类的jar包中找不到自定义的类，于是又会原路返回至系统类加载器，最后还是由系统类加载器执行。 注解注解是代码里面的一些特殊标记，可以在编译、类加载、运行时被读取，并执行相应的处理。注解可以在不改变原有逻辑的情况下，补充一些信息。注解作为一种数据类型，跟class、interface具有同等地位。 注解的使用方式与修饰符一样，可以给任何一种数据写上注解（类、接口、构造器、变量…） 自定义注解： 123456789101112// 语法权限修饰符 @interface 注解名字&#123; // 注解体 属性类型 属性名(); 属性类型 属性名(); 属性类型 属性名(); .....&#125;//举例public @interface MyAnno &#123;&#125; 注解的使用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// @注解名(属性1 = value1,属性2 = value2) // 注解使用 @MyAnno3(name = &quot;zs&quot;,age = 20) public static void func() &#123; &#125;// 例子：获取注解信息public class Demo &#123; public static void main(String[] args) throws Exception&#123; //获取Login注解里的信息 打印一下 // 获取字节码文件对象 Class&lt;?&gt; c = Class.forName(&quot;_23annotation.com.cskaoyan._04handle.Demo&quot;); // 获取方法对象 Method method = c.getDeclaredMethod(&quot;login&quot;); // 再判断方法上使用了注解 isAnnotationPresent boolean annotationPresent = method.isAnnotationPresent(Login.class); System.out.println(annotationPresent); if (annotationPresent) &#123; // 是 , 获取这个注解实例 getAnnotation Login annotation = method.getAnnotation(Login.class); // 获取属性 String name = annotation.name(); String password = annotation.password(); System.out.println(name); System.out.println(password); &#125; &#125; @Login public static void login() &#123; &#125;&#125;// 使用元注解修饰@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@interface Login &#123; // 定义属性 String name() default &quot;root&quot;; String password() default &quot;123456&quot;;&#125; 元注解：描述注解的注解。常用的元注解有： @Retention元注解，来定义我们自己定义的注解的保留级别. 123RetentionPolicy.RUNTIMERetentionPolicy.CLASS // 默认RetentionPolicy.SOURCE @Target元注解，注解可以作用的目标 1234ElementType.TYPE// 整个类ElementType.FIELD// 成员变量 ElementType.CONSTRUCTOR// 构造方法 ElementType.METHO// 成员方法 GC如何确定垃圾： 引用计数算法：给对象添加一个引用计数器，每当有引用指向它，计数器+1；每当引用失效，计数器-1。当计数器为0，表示该对象不可被引用。但是引用计数算法无法应用在循环引用中。 根搜索算法：以一个叫”GC Roots”的对象为起点向下搜索，看一个对象是否存在连接至GC Root的引用链，如果没有表示该对象不可被引用。GC使用根搜索算法。 如何回收垃圾： 标记清除算法：首先标记出所有需要回收的对象，再统一回收；或者标记出所有存活的对象，统一回收未被标记的对象。虽然实现简单，但是会产生很多内存碎片。 标记复制算法：将一块内存划分成容量相等的两块，每次使用其中一块，当内存用完后，将还存活的对象复制至另一块内存中，再把已满的内存全部清理。虽然实现简单且不容易产生内存碎片，但是内存利用率降低了，且存活对象较多时，会产生许多不必要的开销，降低效率。 标记整理算法：同标记清除算法一样，将所有需要回收的对象标记，但是它不会直接清理，而是将存活的对象都往一端移动，移动完成后清除边界外的所有对象。这样虽然不会产生内存碎片，但是效率却降低了。 分代收集算法：根据对象的存活时间将内存划分为新生代、老年代和永久代，新生代中的对象大部分都是存活时间较短的，老年代中的对象则是存活时间较长的。 新创建的对象会放入新生代中，新生代空间使用的是标记复制算法，将新生代空间划为一个eden空间和两个survivor空间（survivor1、survivor2），其中eden空间用来放置新建的对象，survivor1和survivor2则用来放置复制一遍和复制两遍后存活的对象。当过了一定时间后，survivor2中的对象会放至老年代。 老年代中因为存活对象较多，一般使用标记整理算法。 何时回收垃圾： 申请堆空间失败，表示堆空间已满，触发GC。 系统进入休眠一段时间触发GC。 主动调用GC。 设计模式五大原则： 单一职责原则：每个类只负责自己的部分。 开闭原则：一个类或模块应该对拓展开放，对修改关闭。 里氏替换原则：任何父类可以出现的地方，子类都可以出现。 接口隔离原则：一个接口只提供一个对外的功能。 依赖倒置原则：上层模块不应该依赖于底层模块，而应该依赖于抽象类或接口；抽象类或接口不应该依赖于具体实现类，具体实现类应该依赖于抽象类或接口。 单例设计模式： 保证一个类只有一个对象，防止频繁的创建和销毁对象，避免对共享资源的多重占用。 实现方法：构造方法私有；提供返回实例的静态方法；提供自身类型的全局变量。 123456789101112131415161718public class Singleton1 &#123; //- 提供自身类型的全局的成员变量 private static Singleton1 instance; // - 构造方法私有 private Singleton1() &#123; &#125; //- 提供静态方法,返回实例 public static Singleton1 getInstance() &#123; // 最终要返回singleton1对象 // 做判断 if (instance == null) &#123; instance = new Singleton1(); &#125; return instance; &#125;&#125; 工厂设计模式： 可以通过一个工厂批量生产对象，同时隐藏创建对象的一些细节，标准化产生实例。 123456789101112131415161718192021222324252627282930313233public class FruitFactory &#123; // 提供1个静态方法 返回具体水果对象 public static Fruit getInstance(String name) &#123; Fruit fruit = null; if (&quot;apple&quot;.equals(name)) &#123; fruit = new Apple(); &#125; else if (&quot;orange&quot;.equals(name)) &#123; fruit = new Orange(); &#125; else if (&quot;banana&quot;.equals(name)) &#123; fruit = new Banana(); &#125; else &#123; System.out.println(&quot;生产不了!&quot;); &#125; // 返回水果对象 return fruit; &#125; // 不修改原有的代码逻辑 实现功能 public static Fruit getInstance2(String className) throws Exception &#123; // 根据全限定名 获取字节码文件对象 Class&lt;?&gt; c = Class.forName(className); // 获取构造方法 Constructor&lt;?&gt; declaredConstructor = c.getDeclaredConstructor(); // 实例化对象 Fruit fruit = (Fruit) declaredConstructor.newInstance(); // 返回对象 return fruit; &#125;&#125;"},{"title":"剑指offer-day15","path":"2022/04/22/剑指offer-day15/","text":"二叉树中和为某一值的路径完全没思路，直接放答案。 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();// 定义一个path来记录每次递归结束后的结果 LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int target) &#123; firstOrder(root,target);// 先序遍历 return res; &#125; public void firstOrder(TreeNode root, int target)&#123; if(root == null)&#123;// 节点为空时返回 return; &#125; path.add(root.val);// path添加递归的值 target -= root.val;// 目标值减去当前递归的值 if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null)&#123;// 如果目标值为0且该节点为叶子节点，将已经递归完成的path放入答案列表中 res.add(new LinkedList(path)); &#125; pathSum(root.left,target);// 递归遍历左节点 pathSum(root.right,target);// 递归遍历右节点 path.removeLast();// 执行至此表示寻找符合的叶子节点失败，将本次遍历的节点退出，回溯至上个节点 &#125;&#125; 二叉搜索树与双向链表这道题想到了中序遍历，但是对双链表还是不太熟悉，没做出来，半抄了一个答案。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val,Node _left,Node _right) &#123; val = _val; left = _left; right = _right; &#125;&#125;;*/class Solution &#123; Node head;// 定义头节点和尾节点 Node pre; public Node treeToDoublyList(Node root) &#123; if(root == null)&#123;// 树为空返回null return null; &#125; inorder(root);// 以尾节点为指针，进行中序遍历 head.left = pre;// 遍历完成，将头尾节点连接 pre.right = head; return head; &#125; public void inorder(Node root)&#123; if(root == null)&#123;// 遍历至空节点返回 return; &#125; inorder(root.left); if(pre != null)&#123;// 此时尾节点若还没赋值表示头尾节点未初始化，需要初始化头节点；反之则让尾节点指向当前节点 pre.right = root; &#125; else&#123; head = root; &#125; root.left = pre;// 当前节点的尾指针指向尾节点 pre = root;//尾节点跳至当前节点 inorder(root.right); &#125;&#125; 二叉搜索树的第k大节点这道题倒是写出来了，但是还是老问题，时空复杂度非常感人，看了答案发现用了一个逆序的中序遍历，而且提前终止了遍历，所以能有非常优秀的时空复杂度。 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int res; int k; public int kthLargest(TreeNode root, int k) &#123; this.k = k; inorder(root);// 逆序中序遍历 return res; &#125; public void inorder(TreeNode root)&#123; if(root == null || k == 0)&#123;// 当遍历至空节点时返回；当k已经为0时，提前终止遍历 return; &#125; inorder(root.right); if(--k == 0)&#123;// 当k-1 = 0时，表示当前遍历的节点就是答案，赋值给res res = root.val; &#125; inorder(root.left); &#125;&#125;"},{"title":"剑指offer-day14","path":"2022/04/21/剑指offer-day14/","text":"矩阵中的路径涉及到图的范围了，只能说是力所不能及，直接放答案吧，主要是DFS的思想怎样用代码表现出来。 123456789101112131415161718192021222324252627282930class Solution &#123; public boolean exist(char[][] board, String word) &#123; char[] words = word.toCharArray(); for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[0].length; j++)&#123; if(dfs(board,words,i,j,0))&#123;// 遍历找到第一个等于字符串头的字母，开始DFS return true; &#125; &#125; &#125; // 没有找到或者没有路径，返回false return false; &#125; public boolean dfs(char[][] board, char[] word, int i, int j, int k)&#123; // 终止条件有：遍历时超出边界值；遍历的值不等于字符串中的值 if(i &lt; 0 || i &gt;= board.length || j &lt; 0 || j &gt;= board[0].length || board[i][j] != word[k])&#123; return false; &#125; // k为字符串的下标，如果此时k等于字符串长度，说明寻找到路径，直接返回true if(k == word.length - 1)&#123; return true; &#125; board[i][j] = &#x27;\\0&#x27;;// 遍历过的地方设为空，防止遍历回来 boolean res = (dfs(board,word,i+1,j,k+1) || dfs(board,word,i-1,j,k+1) || dfs(board,word,i,j+1,k+1) || dfs(board,word,i,j-1,k+1));// 分别遍历上下左右，只要有一个符合条件即可 board[i][j] = word[k];// 将遍历过的地方重新赋值，防止影响下一次遍历 return res;// 返回结果 &#125;&#125; 机器人的运动范围跟上题有些相似，就是返回值从boolean改成了int，参考着答案跌跌撞撞地写下来了。 123456789101112131415161718192021222324class Solution &#123; boolean[][] visited;// 定义一个boolean数组，来表示该元素是否被访问过 public int movingCount(int m, int n, int k) &#123; visited = new boolean[m][n]; return dfs(0,0,m,n,k);// 从左上角开始遍历 &#125; public int bitSum(int m, int n)&#123;// 计算位数和，因为题目只取两位数，就方便着写 int m1 = m % 10; int m2 = m / 10; int n1 = n % 10; int n2 = n / 10; return m1+m2+n1+n2; &#125; public int dfs(int i,int j, int m, int n,int k)&#123; // 遍历失败条件：遍历超出范围；遍历的位置的位数和大于要求数；该位置早被遍历过 if(i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || bitSum(i,j) &gt; k || visited[i][j])&#123; return 0;// 返回0表示此处不是机器人能到达的地方，不能计入总数 &#125; visited[i][j] = true;// 遍历成功，将这个位置设为已访问过 return 1+dfs(i+1,j,m,n,k)+dfs(i-1,j,m,n,k)+dfs(i,j+1,m,n,k)+dfs(i,j-1,m,n,k);// 因为成功，所以总数+1 &#125;&#125;"},{"title":"剑指offer-day13","path":"2022/04/21/剑指offer-day13/","text":"调整数组顺序一开始是想的最简单的方法，用两个数组来记录奇数和偶数，遍历原数组一遍就行，但是明显不是最优解。最优解是用双指针从数组两边往中间遍历，头指针记录奇数，尾指针记录偶数，如果头指针遇到偶数就停止，转而遍历尾指针；尾指针遇到奇数就跟头指针的偶数交换，遍历直至两指针相遇。 123456789101112131415161718class Solution &#123; public int[] exchange(int[] nums) &#123; int i = 0; int j = nums.length - 1; while(i &lt; j)&#123;// 遍历直至两指针相遇 while(nums[i] % 2 != 0 &amp;&amp; i &lt; j)&#123;// 头指针遇到偶数停止 i++; &#125; while(nums[j] % 2 == 0 &amp;&amp; i &lt; j)&#123;// 尾指针遇到奇数停止 j--; &#125; int tmp = nums[i];// 交换 nums[i] = nums[j]; nums[j] = tmp; &#125; return nums;// 返回原数组 &#125;&#125; 和为s的两个数字还是双指针…用一个头指针和一个尾指针指向数组两端，求两个指针所指元素的和，大于目标值尾指针向前移，反之头指针向后移，直至等于目标值，返回两个指针指向的元素。 12345678910111213141516171819class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int i = 0;// 维护一个头指针和一个尾指针 int j = nums.length - 1; while(i &lt; j)&#123;// 如果头指针超过尾指针，推出循环 while(nums[i] + nums[j] &lt; target &amp;&amp; i &lt; j)&#123;// 小于target，头指针后移 i++; &#125; while(nums[i] + nums[j] &gt; target &amp;&amp; i &lt; j)&#123;// 大于target，尾指针前移 j--; &#125; if(nums[i] + nums[j] == target)&#123;// 等于target，退出循环 break; &#125; &#125; int[] res = &#123;nums[i],nums[j]&#125;; return res; &#125;&#125; 翻转单词顺序一开始是用split()方法来分割字符串的，虽然写出来了但是时空复杂度不好，看了答案也发现并不推荐这种做法，利用双指针会更好。 用两个指针都指向string的尾部，前指针i遍历至空格，与后指针j一起获取了第一个不含空格的子字符串，用一个StringBuffer接住该字符串，i则继续遍历，不过此时是遍历至第一个字符，再将j移到此处，重复至遍历完成。 12345678910111213141516171819class Solution &#123; public String reverseWords(String s) &#123; s.trim();// 将s头尾的空格去掉 int i = s.length() - 1;// 维护两个指针 int j = i; StringBuffer sb = new StringBuffer(); while(i &gt;= 0)&#123; while(i &gt;= 0 &amp;&amp; s.charAt(i) != &#x27; &#x27;)&#123;// 找到第一个空格 i--; &#125; sb.append(s.substring(i+1,j+1) + &quot; &quot;);// 获取并添加子字符串+&quot; &quot; while(i &gt;= 0 &amp;&amp; s.charAt(i) == &#x27; &#x27;)&#123;// 找到第一个字符 i--; &#125; j = i;// 后指针指向第一个字符 &#125; return sb.toString().trim();// 完成后尾部会多出一个空格，除去空格 &#125;&#125;"},{"title":"剑指offer-day12","path":"2022/04/21/剑指offer-day12/","text":"合并两个排序的链表还是双指针的题目，一开始是想直接在两个链表上处理的，后来发现会出现漏元素的问题，就跟着答案老老实实地用一条新链表来接。 思路很简单，用两个指针p和q遍历两个链表，p&lt;&#x3D;q时将p指向的元素放入新建的链表，反之则放入q指向的元素，遍历至一个指针遍历完成，将新链表指向未遍历完的那个指针就完成了。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null)&#123; return l2; &#125; if(l2 == null)&#123; return l1; &#125; ListNode p = l1;// 创建两个指针 ListNode q = l2; ListNode head = new ListNode(-1);// 创建新链表头和一个头指针 ListNode pre = head; while(p != null &amp;&amp; q != null)&#123;// 遍历两个链表 if(p.val &lt;= q.val)&#123; ListNode cp = p; head.next = cp; head = head.next; p = p.next; &#125; else&#123; ListNode cq = q; head.next = cq; head = head.next; q = q.next; &#125; &#125; if(p != null)&#123;// 其中一个链表遍历完成，遍历另一个链表 head.next = p; &#125; if(q != null)&#123; head.next = q; &#125; return pre.next; &#125;&#125; 两个链表的第一个公共节点这个并没有想出来怎么做，还是看答案吧。 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA == null || headB == null)&#123;// 其中一个节点为空，返回null return null; &#125; ListNode p = headA;// 建立两个指针 ListNode q = headB; while(p != q)&#123; if(p == null)&#123;// 当headA的指针遍历完成后，改为从headB再遍历一次 p = headB; &#125; else&#123; p = p.next; &#125; if(q == null)&#123;// 当headB的指针遍历完成后，改为从headA再遍历一次 q = headA; &#125; else&#123; q = q.next; &#125; &#125; // p、q相等时，跳出循环并输出p，这就是公共节点 return p; &#125;&#125;"},{"title":"剑指offer-day11","path":"2022/04/21/剑指offer-day11/","text":"删除链表的节点思路很简单，维护一个双指针，一个指向现节点，一个指向前节点，找到要删除的节点，让前节点指向现节点的下一个节点，再让现节点指向空指针即可。主要是删除头节点的问题，我选择再维护一个头指针preHead，而答案是将其作为特殊情况处理，直接返回头节点指向的链表。 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode deleteNode(ListNode head, int val) &#123; ListNode pre = new ListNode(-1);// pre指向头指针 ListNode preHead = pre;// preHead指向头指针 ListNode cur = head;// cur指向链表中的头指针 pre.next = cur;// 将自建的头指针和链表中的头指针连接 while(cur != null)&#123; if(cur.val == val)&#123;// 删除节点 pre.next = cur.next; cur.next = null; &#125; pre = cur; cur = cur.next; &#125; return preHead.next; &#125;&#125; 链表中倒数第k个节点跟上面一样，维护一个双指针，都先指向头节点，根据k值让p节点向前移动，当两个节点相距k-1时q节点和p节点一起前移，到p节点指向链表尾节点时结束，返回q节点所指向的链表即可。 12345678910111213141516171819202122/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode getKthFromEnd(ListNode head, int k) &#123; ListNode p = head;// 维护两个节点p、q ListNode q = head; for(int i = 0; i &lt; k-1; i++)&#123;// 迁移p节点 p = p.next; &#125; while(p.next != null)&#123;// p节点和q节点一起前移 q = q.next; p = p.next; &#125; return q;// 返回q节点指向的链表 &#125;&#125;"},{"title":"剑指offer-day10","path":"2022/04/20/剑指offer-day10/","text":"把数字翻译成字符串有一点像青蛙跳台阶，但是递归条件有点不一样。 维护三个指针a&#x3D;f(0)&#x3D;1、b&#x3D;f(1)&#x3D;1、c &#x3D; 1，遍历整个数字（为了方便遍历需要把数字转为字符串），从第二个数字开始，如果该数字和前一个数字组成的数&gt;&#x3D;10且&lt;&#x3D;25，说明这个数字的翻译方法有f(0)+f(1)种，否则只有f(1)种。c的值等于这个数的翻译方法，此时c指向该数字，a指向b，b指向c，循环至遍历结束。 1234567891011121314151617181920class Solution &#123; public int translateNum(int num) &#123; String s = String.valueOf(num); int a = 1;// 代表f(0) int b = 1;// 代表f(1) int c = 1;// 代表f(0)+f(1)，防止只有一个数的特殊情况，初始值为1 for(int i = 1; i &lt; s.length(); i++)&#123; int n = Integer.parseInt(s.substring(i-1,i+1)); if(n &gt;= 10 &amp;&amp; n &lt;= 25)&#123;// 如果遍历的数与前一个数组合符合范围，说明遍历至该数时的翻译方法有f(n-1)+f(n-2)种 c = a + b; &#125; else&#123;// 不符合，明遍历至该数时的翻译方法有f(n-1)种 c = b; &#125; a = b;// a跳至f(n-2) b = c;// b跳至f(n-1) &#125; return c; &#125;&#125; 最长不含重复字符的子字符串自己写了一个虽然过了，但是时空复杂度真的丢人…算是一个暴力解吧。 同样是动态规划思想，用一个哈希表来记录每个字符最后出现的位置，遍历整个字符串，获得一个字符过去出现的最后位置和现在出现的位置，相减获得重复前的子字符串长度。用一个数tmp来记录。最后返回每次记录后tmp的最大值。 12345678910111213141516171819class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); int tmp = 0; int res = 0; for(int i = 0; i &lt; s.length(); i++)&#123; int j = map.getOrDefault(s.charAt(i),-1);//无值则初始化map，初始值设为-1，有值则获取该字符前一次出现的位置 map.put(s.charAt(i),i);// 修改位置至当前 if(tmp &lt; i - j)&#123;// 如果tmp&lt;i-j，说明还未找到相同的字符，tmp长度+1 tmp++; &#125; else&#123;// 如果tmp&gt;=i-j，说明出现了相同的字符，tmp=i-j tmp = i - j; &#125; res = Math.max(tmp,res);// 获取tmp的最大值 &#125; return res; &#125;&#125;"},{"title":"剑指offer-day9","path":"2022/04/20/剑指offer-day9/","text":"连续子数组的最大和思路跟之前的股票的最大利润是一样的，遍历一次数组，如果之前遍历的值的和sum加上这次遍历的值num都小于该值，那么就将起点改为num，并用一个值res来记录每次遍历后的最大值。 1234567891011121314class Solution &#123; public int maxSubArray(int[] nums) &#123; int res = Integer.MIN_VALUE; int sum = 0; for(int num : nums)&#123; sum += num;// 记录遍历至该值的和 if(sum &lt;= num)&#123; sum = num;// 如果总和都没有该值大，将记录的起点改为该值 &#125; res = Math.max(res,sum);// 记录每次遍历后总和间的最大值 &#125; return res; &#125;&#125; 礼物的最大价值相当于上题的加强版，使用一个二维数组，并且增加了一个向下还是向右的判断，但是核心思想是不变的。 遍历数组来记录每次行进的最大总和，放在这次行进的节点中。从左上角开始遍历，因为从第一行遍历和从第一列遍历都是累加的，可以做一个判断：当要遍历的值位于这两个特殊位置时，只需要获取它的左边（或上边）的和，累加至该值并替换。其他时候则需要对左边的值和上边的值进行比较，取较大的累加至该值并替换。最后输出右下角的总和。 123456789101112131415161718192021class Solution &#123; public int maxValue(int[][] grid) &#123; for(int m = 0; m &lt; grid.length; m++)&#123; for(int n = 0; n &lt; grid[0].length; n++)&#123; if(m == 0 &amp;&amp; n == 0)&#123;// 位于起点，跳过遍历 continue; &#125; if(m == 0)&#123;// 位于第一行，只累加左边的值 grid[m][n] += grid[m][n-1]; &#125; else if(n == 0)&#123;// 位于第一列，只累加上边的值 grid[m][n] += grid[m-1][n]; &#125; else&#123;// 其他情况需要判断左边和上边的值，取较大值累加 grid[m][n] += Math.max(grid[m][n-1],grid[m-1][n]); &#125; &#125; &#125; return grid[grid.length - 1][grid[0].length - 1];// 返回右下角值 &#125;&#125;"},{"title":"学习总结（2022.04.12-2022.04.20）","path":"2022/04/18/学习总结（2022-04-12-2022-04-18）/","text":"IO的分类按照数据流向分(以内存为参照物)： 输入：外设-&gt;内存 输出：内存-&gt;外设 按照数据类型分： 字节流(1B &#x3D; 0000 0000) 字符流 字节流一般用于非文本文件；字符流一般用于文本文件。 为什么会有字符流？因为用字节流读取非英文和数字的数据可能会发生错误 4个抽象基类及其子类 字节输出流 字节输入流 字符输出流 字符输入流 抽象父类 OutputStream&lt;br&gt;void write(byte[] b) InputStream&lt;br/&gt;int read(byte[] b) Writer&lt;br&gt;void write(char[] c)&lt;br/&gt;void writer(String s) Reader&lt;br&gt;int read(char[] c) 文件 FileOutputStream(File file, boolean append) FileInputStream(File file) FileWriter(File file, boolean append) FileReader(File file) 缓冲 BufferedOutputStream(OutputSteam out, int size) BufferedInputStream(InputStream in, int size) BufferedWriter(Writer out, int size) BufferedReader(Reader in, int size)&lt;br&gt;String readLine() 转换(字节转字符) OutputStreamWriter(OutputStream out, String charsetName) InputStreamReader(InputStream in, String charsetName) 数据(输入&#x2F;输出java基本类型) DataOutputStream(OutputStream out)&lt;br&gt;void writeInt(int a)... DataInputStream(InputStream in)&lt;br&gt;int readInt()... 打印(输入&#x2F;输出字符串) PrintStream(OutputStream out) &lt;br&gt;int print(int a)... PrintWriter(Writer out)&lt;br&gt;int print(int a) 对象(序列化&#x2F;反序列化) ObjectOutputStream(OutputStream out)&lt;br&gt;void writeObject(Object obj) ObjectInputStream(InputStream in)&lt;br&gt;Object readObject() 换行方式“\\r\\n” System.lineSeparator() 标准IO流System.in本质是InputStream System.out本质是PrintStream 进程&#x2F;线程 同步&#x2F;异步进程是操作系统调度的基本单位，线程是cpu调度的基本单位 同步是调用可以立即得到结果，但是需要等待；异步是调用不能立即得到结果，但是可以不等待 java程序运行原理jvm是多线程的，每次运行至少有两个线程：main线程和GC线程 java是抢占式线程调度，但是java自带的setPriority()方法并不能改变线程的优先级，因为java中的优先级是静态的，只能给操作系统一个建议，实际上操作系统有自己的一套线程优先级 多线程的实现方式 定义一个类继承Thread类，重写run()方法，创建该类对象，通过start()创建线程(如果使用run()只是普通的调用子类方法，并不能达到创建多线程的效果)特点：单继承 定义一个类实现Runnable接口，重写run()方法，创建Runnable子类对象，再创建Thread对象，并将该子类对象作为参数传递。特点：实现接口 定义一个类实现Callable接口，重写call()方法，创建FutureTask对象并将该类的对象作为参数传递，再创建Thread对象将FutureTask对象作为参数传递。特点：有返回值 线程API123456789String getName();// 获得该线程的名称void setName(String name);// 设置该线程的名称Static Thread currentThread();// 返回当前正在执行的线程对象的引用static void sleep(long millis);// 线程休眠，进入阻塞，但是不释放资源void join();// 主线程等待执行该方法的子线程终止。join在哪个线程的代码块中被调用，该线程就是主线程；哪个线程调用了join，该线程就是子线程void setDaemon(boolean on);// 设置一个线程为守护线程。当正在运行的线程都为守护线程时，jvm停止运行；该方法必须在线程启动前调用；GC线程是守护线程。void wait();// 线程进入阻塞并释放资源。void notify();// 线程唤醒随机一个阻塞的进程。void notifyAll();// 线程唤醒全部进入阻塞的进程。 安全中断线程线程执行完毕就会中断。但是很多时候我们需要自己控制线程终止，然而API中的stop()方法存在线程不安全问题，所以一般定义一个成员变量boolean flag来控制。 synchronized关键字基本语法 123synchronized(锁对象)&#123; // 对共享数据的访问操作&#125; 锁对象可以是： 任意一个Object及其子类对象，java中的任意对象都可以当锁，都存在wait()、notify()和notifyAll()方法。 this关键字，即是令包含该代码块的类对象当锁。 字节码文件对象(类名.class) Lock类成员方法： 12lock();// 获取锁unlock();// 释放锁 lock是一把真正的锁类，可以让我们看到加锁解锁的过程。 死锁的原因及解决方法原因：一般出现在同步代码块嵌套，因为2个或以上的线程抢夺资源而造成互相等待。 12345678910synchronized(ObjA)&#123; synchronized(objB)&#123; &#125;&#125;synchronized(objB)&#123; synchronized(ObjA)&#123; &#125;&#125; 解决方式： 更改加锁顺序 12345678910synchronized(ObjA)&#123; synchronized(objB)&#123; &#125;&#125;synchronized(ObjA)&#123; synchronized(objB)&#123; &#125;&#125; 再加一把锁，将非原子操作改为原子操作 1234567891011121314synchronized(ObjC)&#123; synchronized(objB)&#123; synchronized(objA)&#123; &#125; &#125;&#125;synchronized(objC)&#123; synchronized(ObjA)&#123; synchronized(objB)&#123; &#125; &#125;&#125; 线程池线程池有三种子类： ExecutorService newCachedThreadPool()：根据需要创建新线程，也可以自动删除，60s处于空闲状态的线程。线程数量可变。 ExecutorService newFixedThreadPool(int nThreads)：线程数量固定，维护一个无界队列（暂存已提交的来不及执行的任务），按照任务的提交顺序，将任务执行完毕。 ExecutorService newSingleThreadExecutor()：单个线程，其他特点如上。 两种成员方法： 12void submit(Runnable task);// 提交任务void shutdown();// 启动顺序关闭 定时任务与定时器Timer定时器是一种工具，线程用其安排以后在后台线程中执行的任务。可安排任务执行一次，或者定期重复执行。 两种构造方法： 12Timer();// 创建一个新计时器Timer(boolean isDaemon);// 创建一个新计时器，可以指定其相关的线程作为守护程序运行 四种成员方法： 1234schedule(TimerTask task, Date time);// 从time时间开始执行。schedule(TimerTask task, long delay, long period);// 在延迟delay毫秒后，每period毫秒执行一次。schedule(TimerTask task, Date firstTime, long period);// 从firstTime时间开始执行，之后每period毫秒执行一次。scheduleAtFixedRate(TimerTask task, long delay, long period);// 设置一个继承了TimerTask类的定时任务类，在延迟delay毫秒后，每period毫秒执行一次该任务。(TimerTask定时任务，使用时继承该类并重写run()方法) UDP&#x2F;TCPUDP发送端步骤： DatagramSocket datagramSocket = new DatagramSocket(int port); 创建发送端的Socket对象 DatagramPacket sendPacket= newDatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port); 创建用于发送的数据报包 datagramSocket.send(sendPacket); 把包发送出去 datagramSocket.close(); 关闭Socket UDP接收端步骤： DatagramSocket datagramSocket = new DatagramSocket(int port); 创建接收端的Socket对象 DatagramPacket receivePacket = new DatagramPacket(byte[] buf, int offset, int length); 创建用于接收的数据报包 datagramSocket.receive(receivePacket); receive方法进行接收 byte[] data = receivePacket.getData(); 解析数据 datagramSocket.close(); 关闭Socket UDP可以通过多线程优化，达到两端互相通信的效果 TCP客户端步骤： Socket socket = new Socket(String host, int port); 创建客户端的socket对象 OutputStream out = socket.getOutputStream(); 从socket中获取输入&#x2F;输出流 out.write(byte[] b); 利用输入&#x2F;输出流进行读写操作 socket.close(); 关闭Socket TCP服务端步骤： ServerSocket serverSocket = new ServerSocket(int port); 创建服务端的ServerSocket 对象 Socket socket = serverSocket.accept(); 利用accept方法建立连接,得到socket对象 InputStream in = socket.getInputStream(); 从socket中获取输入&#x2F;输出流 in.read(byte[] b); 利用输入&#x2F;输出流进行读写操作 socket.close(); 关闭Socket TCP可以通过ObjectInputStream&#x2F;ObjectOutputStream来实现序列化&#x2F;反序列化传输，也可以通过FileInputStream&#x2F;FileOutputStream来实现文件传输。 反射反射时在类运行时获取其信息的一种技术，具体方式是获取字节码文件（也就是.class文件）对象，然后从对象中获取该类的构造器、变量、方法等成员，且能无视修饰符强行访问。 获取字节码的三种方式： 对象.getClass() 类名.class Class.forName(String classname) classname是全类名 因为第三种才能获取较为完整的对象，一般使用第三种。 反射获得构造方法的方式有： 1234Constructor[] getConstructors();// 获取所有public方法Constructor[] getDeclaredConstructors();// 获取所有构造方法，包括privateConstructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes);// 获取单个public方法Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes);// 获取单个构造方法，包括private 获得构造方法后可以创建对象。 Object o = constructor.newInstance(&quot;张三&quot;, 20, true); 如果构造器非public修饰，需要暴力破解。 constructor.setAccessible(true); 反射获得成员变量的方式有： 1234Field[] getFields();// 获取所有public变量Field[] getDeclaredFields();// 获取所有成员变量Field getField(String name);// 获取指定public成员变量Field getDeclaredField(String name);// 获取指定成员变量 获得成员变量后可以给成员变量赋值。 12Object o = declaredConstructor.newInstance();// 实例化对象nameFiled.set(o, &quot;张三&quot;);// 对该对象的名字成员变量赋值 也可以获得某个成员变量。 Object o1 = nameFiled.get(o); 如果成员变量非public修饰，需要暴力破解，方式同上。 反射获得成员方法的方式有： 1234Method[] getMethods();// 获取所有public方法Method[] getDeclaredMethods();// 获取所有方法Method getMethod(String name, Class&lt;?&gt;... parameterTypes);// 获取指定public方法Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes);// 获取指定方法 可以利用Method调用对象方法。 Object invoke(Object obj, Object... args); 第一个是要调用的对象，后面是多个可变参数类型。 Class类API： 1234String getName();// 获取全类名String getSimpleName();// 获取简单名Class&lt;?&gt; getInterfaces();// 获取接口Class&lt;?&gt; getSuperclass();// 获取父类 Field类API： 12Class&lt;?&gt; getType();// 获取变量类型int getModifiers();// 获取变量类型，以int值表示，可用Modifier.toString()转为String Method类API： 12String getReturnType();// 获取返回值类型Class&lt;?&gt;[] getParameterTypes();// 获取方法参数 配置文件配置文件(properties)里有各种配置信息，以键值对方式存储。 配置文件中注释使用#号。 Properties类表示了一个持久的属性集，可以获得配置文件中的数据。 一种构造方法： ​ Properties() 创建一个无默认值的空属性列表 两种成员方法： 12void load(InputStream inStream);// 从输入流中读取属性列表（键和元素对）String getProperty(String key);// 用指定的键在此属性列表中搜索属性"},{"title":"剑指offer-day8","path":"2022/04/18/剑指offer-day8/","text":"斐波那契数列递归经典题目，但是使用传统递归会超时，需要使用优化的记忆递归。 123456789101112131415161718class Solution &#123; public int fib(int n) &#123; // 超出时间限制 // if(n == 0 || n == 1)&#123; // return n; // &#125; // return fib(n-1) + fib(n-2); int a = 0;// a表示f(0) int b = 1;// b表示f(1) int sum = 0; for(int i = 0; i &lt; n; i++)&#123; sum = (a + b) % 1000000007;// sum表示f(2) = f(0) + f(1) a = b;// a向前移动至f(1) b = sum;// b向前移动至f(2) &#125; return a;// 循环结束，a=f(n) &#125;&#125; 青蛙跳台阶其实就是斐波那契数列，只要记住上一题的解法，这道题就是一模一样，只是初始条件改变了。 12345678910111213class Solution &#123; public int numWays(int n) &#123; int a = 1;// f(0) = 1 int b = 1;// f(1) = 1，f(2) = f(0) + f(1) = 2 int sum = 0; for(int i = 0; i &lt; n; i++)&#123; sum = (a+b) % 1000000007; a = b; b = sum; &#125; return a; &#125;&#125; 股票的最大利润这道题用动态规划没有想出来，看了答案才发现原来这么淳朴…大体思路是遍历整个数组，记录一个最低价，如果后面有更低的价格就更新最低价；没有的话就计算差值，差值最大即为答案。 1234567891011class Solution &#123; public int maxProfit(int[] prices) &#123; int cost = Integer.MAX_VALUE; int profit = 0; for(int price : prices)&#123; cost = Math.min(price,cost);// 更新最低价 profit = Math.max(profit,price - cost);// 更新最大差值 &#125; return profit; &#125;&#125;"},{"title":"剑指offer-day7","path":"2022/04/16/剑指offer-day7/","text":"树的子结构大致思路是有的：通过先序遍历来遍历主树，如果有等于子树根节点的节点，再先序遍历比较。 但是实现得磕磕绊绊，没法了，进行一个答案的抄。 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSubStructure(TreeNode A, TreeNode B) &#123;// 遍历A树 if(A == null || B == null)&#123;// A或B为空，返回false return false; &#125; return (compare(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B)); &#125; public boolean compare(TreeNode A,TreeNode B)&#123;// 比较B树 if(B == null)&#123;// 如果先序遍历完成，返回true return true; &#125; if(A == null || (A.val != B.val))&#123;// 如果A树为空或者两数节点不相等，返回false return false; &#125; return (compare(A.left,B.left) &amp;&amp; compare(A.right,B.right));// 两数节点相等，再先序遍历比较其左节点和右节点 &#125;&#125; 感觉递归的结束条件确实很难想。 二叉树的镜像直接摆烂看答案 1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode mirrorTree(TreeNode root) &#123; if(root == null)&#123;// 遍历至子节点返回null return null; &#125; TreeNode tmp = root.left; root.left = mirrorTree(root.right); root.right = mirrorTree(tmp); return root; &#125;&#125; 可以发现这道题目其实跟交换数字的思路很像，可以靠这个来记忆。 对称二叉树跟第一题很像，都是需要遍历比较。 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root == null)&#123;// root为空返回true return true; &#125; return compare(root.left,root.right); &#125; public boolean compare(TreeNode left, TreeNode right)&#123;// 遍历比较两个节点 if(left == null &amp;&amp; right == null)&#123;// 两个节点同时遍历完毕，说明对称，返回true return true; &#125; if(left == null || right == null || left.val != right.val)&#123;// 其中一个节点先遍历完毕或两节点不相等，返回false return false; &#125; return(compare(left.left,right.right) &amp;&amp; compare(left.right,right.left)); &#125; &#125;"},{"title":"剑指offer-day6","path":"2022/04/14/剑指offer-day6/","text":"从上到下打印二叉树经典题目，使用层序遍历来实现，具体实现方法就是用一个队列来记录节点，一个ArrayList记录答案。当前节点入队后，再将其左右节点入队，随后出队，ArrayList记录节点的值，直至队列为空。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int[] levelOrder(TreeNode root) &#123; LinkedList&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); q.add(root);// 将根节点入队 TreeNode t; while((t = q.peek()) != null)&#123;// 队头为空跳出 if(t.left != null)&#123;// 左节点入队 q.add(t.left); &#125; if(t.right != null)&#123;// 右节点入队 q.add(t.right); &#125; res.add(q.poll().val);// 取出队头获得其值 &#125; int[] arr = new int[res.size()]; for(int i = 0; i&lt;res.size(); i++)&#123;// ArrayList转数组 arr[i] = res.get(i); &#125; return arr; &#125;&#125; 从上到下打印二叉树Ⅱ上一题的变种，加入了对当前层数的判断，需要在之前的代码上做一些修改，主要是用一个int值记录当前层数中的节点数。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); if(root != null)&#123; q.add(root); &#125; while(q.size() != 0)&#123; int i = q.size();// 记录当前层数的节点数 List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); while(i &gt; 0)&#123; TreeNode t = q.poll(); tmp.add(t.val); if(t.left != null)&#123; q.add(t.left); &#125; if(t.right != null)&#123; q.add(t.right); &#125; i--; &#125; res.add(tmp); &#125; return res; &#125;&#125; 从上到下打印二叉树Ⅲ究极加强版，在上一题的基础上加上了蛇形遍历，其实就是需要对层数的奇偶进行判断，而且需要把临时队列tmp更改为双端队列，当层数为奇时从尾部插入，反之从头部插入 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); if(root != null)&#123; q.add(root); &#125; while(q.size() != 0)&#123; int i = q.size(); LinkedList&lt;Integer&gt; tmp = new LinkedList&lt;&gt;(); while(i &gt; 0)&#123; TreeNode t = q.poll(); if(res.size() % 2 == 0)&#123;// 层数判断 tmp.addLast(t.val); &#125; else&#123; tmp.addFirst(t.val); &#125; if(t.left != null)&#123; q.add(t.left); &#125; if(t.right != null)&#123; q.add(t.right); &#125; i--; &#125; res.add(tmp); &#125; return res; &#125;&#125;"},{"title":"剑指offer-day5","path":"2022/04/13/剑指offer-day5/","text":"二维数组中的查找一开始就想到了线性查找，但是是从左上方开始的，发现判定条件不好写后看了看答案，才知道从右上方开始会比较方便（即大于查找值向左移，小于查找值向下移） 提交几次都发现会有边界溢出的情况，无奈只能跟答案一一对照，发现答案事先用了一个int值接住了要判断的值，这样就不会发生边界溢出了。 12345678910111213141516171819202122class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; if(matrix.length == 0)&#123; return false; &#125; int m = 0;// 行数 int n = matrix[0].length - 1;// 列数 while(n &gt;=0 &amp;&amp; m &lt; matrix.length)&#123; int num = matrix[m][n];// 用一个int表示当前值，防止边界溢出 if(num == target)&#123; return true; &#125; if(num &gt; target)&#123; n--; &#125; if(num &lt; target)&#123; m++; &#125; &#125; return false; &#125;&#125; 旋转数组的最小数字不想多说了，就是二分法，重点是怎么设定跳出条件，不然就是寄（是的，我又没做出来） 1234567891011121314// 将数组划分成旋转的和未旋转的// 左指针指向未旋转数组的最后一个元素，右指针指向旋转数组的第一个元素class Solution &#123; public int minArray(int[] numbers) &#123; int i = 0, j = numbers.length - 1; while (i &lt; j) &#123; int m = (i + j) / 2; if (numbers[m] &gt; numbers[j]) i = m + 1;// 说明m还在未旋转数组中，左指针指向m的下一个元素 else if (numbers[m] &lt; numbers[j]) j = m;// 说明m在旋转数组中，右指针指向m else j--;// m正好指向与旋转数组第一个元素相等的元素，右指针左移至与左指针重合 &#125; return numbers[i]; &#125;&#125; 第一个只出现一次的字符一开始就把题目想错了，以为类似为**&quot;aadadaad&quot;**的字符应该返回为空，但是实际上是返回a（a、d两两配对，第一个只剩一个的字母是a） 这道题应该是用哈希表解决的，放出代码。 1234567891011class Solution &#123; public char firstUniqChar(String s) &#123; HashMap&lt;Character, Boolean&gt; dic = new HashMap&lt;&gt;(); char[] sc = s.toCharArray(); for(char c : sc) dic.put(c, !dic.containsKey(c));// 没有则修改为true，有则改为false for(char c : sc) if(dic.get(c)) return c; return &#x27; &#x27;; &#125;&#125;"},{"title":"剑指offer-day4","path":"2022/04/11/剑指offer-day4/","text":"数组中重复的数字最简单的思路当然是使用哈希表来记录重复数，老老实实的写了。 123456789101112131415161718192021class Solution &#123; public int findRepeatNumber(int[] nums) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i : nums)&#123; if(map.containsKey(i))&#123; map.put(i,map.get(i)+1); &#125; else&#123; map.put(i,1); &#125; &#125; int res = 0; for(int i : nums)&#123; if(map.get(i) &gt; 1)&#123; res = i; break; &#125; &#125; return res; &#125;&#125; 结果发现这时空复杂度也太高了…愤而看官方解，发现它也是这么写的…只不过优化了一下过程。 发现自己两年前居然做过这道题，而且时空复杂度都比我现在的优秀，看了一眼： 12345678910class Solution &#123; public int findRepeatNumber(int[] nums) &#123; Arrays.sort(nums); for(int i = 1; i &lt; nums.length;i++)&#123; if(nums[i] == nums[i-1]) return nums[i]; &#125; return 0; &#125;&#125; …也不知道是聪明还是偷懒，利用了题目中 长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内 的条件，自作聪明地用排序来解决问题，不过这应该也算是另辟蹊径吧… 但这道题的最优解还真是利用了这个条件，因为数组内的数不会超过下标值，所以可以利用值对应下标的方法来检测是否有重复，即数字0交换至对应下标0，以此类推，直到交换值和被交换的值相等，说明这个值是重复值。 12345678910111213141516class Solution &#123; public int findRepeatNumber(int[] nums) &#123; int i = 0; while(i &lt; nums.length) &#123; if(nums[i] == i) &#123;// 如果值一开始就对应，则跳过该次循环 i++; continue; &#125; if(nums[nums[i]] == nums[i]) return nums[i];// 交换值和被交换的值相等，说明这个值是重复值 int tmp = nums[i];// 交换两个值 nums[i] = nums[tmp]; nums[tmp] = tmp; &#125; return -1; &#125;&#125; 在排序数组中查找数字 Ⅰ遍历的方法最简单也是最low的，放一个二分法的答案吧。 1234567891011121314151617181920212223class Solution &#123; public int search(int[] nums, int target) &#123; // 搜索右边界 right int i = 0, j = nums.length - 1; while(i &lt;= j) &#123; int m = (i + j) / 2; if(nums[m] &lt;= target) i = m + 1; else j = m - 1; &#125; int right = i; // 若数组中无 target ，则提前返回 if(j &gt;= 0 &amp;&amp; nums[j] != target) return 0; // 搜索左边界 right i = 0; j = nums.length - 1; while(i &lt;= j) &#123; int m = (i + j) / 2; if(nums[m] &lt; target) i = m + 1; else j = m - 1; &#125; int left = j; return right - left - 1; &#125;&#125; 0~n-1中缺失的数字想了很久的二分，但是跳出条件总是写不出，怒而写出暴力解，直接遍历查询。 跟上题一样，还是放出二分的答案吧。 1234567891011121314// 将数组分为两部分：nums[i] == i，nums[i] != i// 用i记录前一数组的最后一个元素，j记录后一数组的第一个元素// 以i &lt;= j来作为跳出条件class Solution &#123; public int missingNumber(int[] nums) &#123; int i = 0, j = nums.length - 1; while(i &lt;= j) &#123; int m = (i + j) / 2; if(nums[m] == m) i = m + 1; else j = m - 1; &#125; return i; &#125;&#125; 感觉静不下心来想二分，都是怎么简单怎么来了，看来得好好练一下二分。"},{"title":"学习总结（2022.04.07-2022.04.11）","path":"2022/04/09/学习总结（2022-04-07-2022-04-11）/","text":"String常量池每次创建字符串常量时，JVM会检查常量池是否存在该常量，如果存在则直接返回该常量的实例引用，没有才会在常量池中创建该常量对象。 例子 123String s1 = &quot;abc&quot;;String s2 = &quot;abc&quot;;System.out.println(s1 == s2)// ==是判断两个引用是否指向同一对象，返回true String两种实例化方式的区别 直接赋值的方式 String s = &quot;abc&quot;; 通过构造方法 String s = new String(&quot;abc&quot;) 第一种只会创建一个对象，第二种则会创建两个对象：一个是与第一种相同的创建方式，一个则是因为new关键字而创建的。虽然两者并不是同一个对象，但它们共用一个value数组（即String类中的char数组）（如果常量池中早已有第0，一种方式创建好的对象，那么第二种方式也只会创建一个对象，即new关键字创建的对象） 第一种会在常量池中创建对象，第二种会在堆上创建对象。 字符串拼接字符串拼接时有两种情况： 在常量池中创建新的对象 在堆上创建新的对象 这两个对象并不是同一个对象，用&#x3D;&#x3D;判别会返回false。 只要拼接的字符串中有一个是以引用变量的形式出现的（比如String s、new String(&quot;abc&quot;)）那么该字符串就是在堆上创建对象。只有拼接时都是以直接赋值的方式创建时，才会在常量池中创建对象（若常量池中已存在拼接后的对象，则不会创建新的，而是使引用指向该对象） 自然排序一般使用Comparable接口和Comparator接口实现。 Comparable接口一般在希望能实现排序的类中实现，通过重写compareTo()方法来达到排序的效果。 a1.compareTo(a2)的返回值若大于0，说明a1对象大于a2，a1排在后面；小于0，说明a1对象小于a2，a1排在前面；等于0则说明a1等于a2。 重写后可以通过Arrays.sort()或Collections.sort()进行自动排序。 Comparator接口一般用于匿名内部类排序，相比Comparable接口更加灵活，依赖于带比较器的Arrays.sort(T[] a, Comparator&lt;? super T&gt; c) ，排序规则跟Comparable接口相同。 示例： 1Arrays.sort(students,(stu1,stu2)-&gt;stu1.getAge() - stu2.getAge());// 根据学生年龄排序 StringBuffer，StringBuilder都是长度可变的字符串类，StringBuilder线程不安全，StringBuffer线程安全。 throws，throwthrows用在方法声明后面，跟的是异常类名；可以跟多个异常类名，用逗号隔开。 throws表示出现异常的一种可能性，并不一定会发生这些异常，且throws修饰的方法由该方法的调用者来处理。 throw用在方法体内，跟的是异常对象名，只能抛出一个异常对象。 throw表示抛出异常，可以由方法体内的语句处理，但执行throw则一定抛出了某种异常。 自定义异常可以自己写一个类并继承Exception 或RuntimeException 来自定义异常。 示例： 123456789101112131415161718192021222324252627282930313233class MyException extends Exception&#123; public MyException() &#123; &#125; public MyException(String message) &#123; super(message); &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; try &#123; func(); &#125; catch (MyException e) &#123; e.printStackTrace(); &#125; &#125; private static void func() throws MyException&#123; // 创建scanner对象 Scanner scanner = new Scanner(System.in); // 输入一个分数 System.out.println(&quot;请输入一个分数&quot;); String score = scanner.nextLine(); int i = Integer.parseInt(score); // 判断一下分数是否满足我们的要求 if (i &lt; 0 || i &gt; 100) &#123; // 认为成绩异常的 // 抛出异常 throw new MyException(&quot;分数异常&quot;); &#125; &#125;&#125; 路径表示对于类 UNIX 平台，绝对路径名的前缀始终是 “&#x2F;“。相对路径名没有前缀。表示根目录的绝对路径名的前缀为 “&#x2F;“ 且名称序列为空。​ 绝对路径： &#x2F;home&#x2F;st&#x2F;6379.conf​ 相对路径： st&#x2F;a.txt​ 根目录： &#x2F; 对于 Microsoft Windows 平台，包含盘符的路径名前缀由驱动器号和一个 “:” 组成。如果路径名是绝对路径名，还可能后跟 “\\“​ 绝对路径： e:\\st\\a.txt​ 相对路径：没有盘符前缀 st\\a.txt 文件过滤器FileFilter接口可以用于实现文件的高级获取功能，通过设置条件来过滤文件，常用匿名内部类实现。 示例： 12File[] files = dir.listFiles((pathname) -&gt; pathname.getName().endsWith(&quot;.java&quot;));// 过滤后缀名为.java的文件"},{"title":"剑指offer-day3","path":"2022/04/09/剑指offer-day3/","text":"替换空格一看到这道题我就优雅地敲下代码 12345class Solution &#123; public String replaceSpace(String s) &#123; return s.replace(&quot; &quot;,&quot;%20&quot;); &#125;&#125; …咳咳，大佬说过，不要成为API Coder，不然35岁就去开滴滴了。 但其实思路还是很简单，因为java的特性，字符串不能被直接修改，只能创建一个新对象，所以在空间复杂度上是怎么都干不过C++的。那么就新建一个可变字符串对象StringBuffer来接收修改后的String对象，可以最大程度优化空间。（其实可以替换为StringBulider，但是在本题中没有明显的优化） 123456789101112131415161718class Solution &#123; public String replaceSpace(String s) &#123; if(s == null || s == &quot;&quot;)&#123; return null; &#125; StringBuilder res = new StringBuilder(); for(int i = 0; i &lt; s.length(); i++)&#123; if(s.charAt(i) == &#x27; &#x27;)&#123; res.append(&quot;%20&quot;); &#125; else&#123; res.append(s.charAt(i)); &#125; &#125; return res.toString(); // return s.replace(&quot; &quot;,&quot;%20&quot;); &#125;&#125; 最后吐槽一下，自己写的方法时空复杂度甚至还没有包装好的replace()低…这道题可能只是单纯用来折磨C++程序员的吧… 左旋转字符串一看到这我又优雅地敲下代码 12345class Solution &#123; public String reverseLeftWords(String s, int n) &#123; return s.substring(n, s.length()) + s.substring(0, n); &#125;&#125; 没想到这么写居然是对的，而且还是最优解… 当然，我一开始并不是这么写的，而是仿造796.旋转字符串的解来写的，用一个字符串来接收两个拼接起来的目标字符串，再返回其中与目标字符串等长的结果字符串。 123456class Solution &#123; public String reverseLeftWords(String s, int n) &#123; String s1 = s + s; return s1.substring(n,s.length() + n); &#125;&#125; 空间复杂度当然没有API好，毕竟自创了一个字符串。 （今天题目挺水的，不过周末了，就放过我吧）"},{"title":"剑指offer-day2","path":"2022/04/08/剑指offer-day2/","text":"从尾到头打印链表简单题，但是实现方法与答案有些不同。 我考虑的是用一个ArrayList来记录链表中的值，最后逆序赋值给一个int数组。答案用的是模拟栈的LinkedList。我尝试了两个方法，发现时空复杂度并没有什么变化，所以就放上自己的答案吧。 12345678910111213141516171819202122/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int[] reversePrint(ListNode head) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(head != null)&#123; list.add(head.val); head = head.next; &#125; int[] res = new int[list.size()]; for(int i = 0; i &lt; list.size(); i++)&#123; res[i] = list.get(list.size() - i - 1); &#125; return res; &#125;&#125; 反转链表经典题目了，但是发现自己死活做不出来，总是有空指针异常，一看答案发现语句顺序错了…但总体思路是对的。利用三个指针来指向前元素、现元素和后元素，然后进行反转操作，操作顺序为： next指针指向当前元素的后一个元素 cur指向的当前元素的指针改为指向pre pre改为指向cur指向的元素 cur改为指向next指向的元素 唯一要注意的点是next指针需要在循环内创建，否则在链表本身为空时会报空指针。 1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head)&#123; ListNode pre = null; ListNode cur = head; while(cur != null)&#123; ListNode next = cur.next;// next指针指向后元素 cur.next = pre;// cur的指针改为指向pre pre = cur;// pre改为指向cur指向的元素 cur = next;// cur改为指向next指向的元素 //next = cur.next;// 自己写的报空指针，不能写在后面，因为当cur在尾指针null时，无法获取next &#125; return pre; &#125;&#125; 之前有想过同上一题目一样，用一个辅助栈来完成反转，看了答案发现这样做并没有三指针快，就放弃这个思路了。 复杂链表的复制完全不会做，选择睡大觉（恼） 好好看了看答案，大概知道思路是怎样的，复述一下。 有两种解法：辅助哈希表和拼接链表，因为后者在空间复杂度上优于前者，所以使用后者。 因为random节点的存在，导致复制时指针可能指向一个还没有创建的节点，所以可以将原链表两倍拉长，使原链表节点先指向复制节点，复制节点再指向原链表的下一个节点。完成复制后进行random节点的指向初始化，通过原节点的信息来让复制节点的指向正确的节点。最后将链表拆开，复制完成。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*// Definition for a Node.class Node &#123; int val; Node next; Node random; public Node(int val) &#123; this.val = val; this.next = null; this.random = null; &#125;&#125;*/class Solution &#123; public Node copyRandomList(Node head) &#123; if(head == null) return null;// 空链表返回空 Node cur = head; // 1. 复制各节点，并构建拼接链表 while(cur != null) &#123; Node tmp = new Node(cur.val);// 新建复制节点，复制原节点的值 tmp.next = cur.next;// 复制节点的指针指向原节点的下一个元素 cur.next = tmp;// 原节点的指针指向复制节点 cur = tmp.next;// cur改为指向复制节点的下一节点，即原链表的下一节点 &#125; // 2. 构建各新节点的 random 指向 cur = head; while(cur != null) &#123; if(cur.random != null) cur.next.random = cur.random.next;// cur.next是复制节点，说明将复制节点的random指针指向原节点的random指针指向的节点的下一个节点，即也是复制节点 cur = cur.next.next;// 跳到原链表的下一个节点 &#125; // 3. 拆分两链表 cur = head.next; Node pre = head, res = head.next; while(cur.next != null) &#123; pre.next = pre.next.next;// 原节点的指针指向原链表的下一个节点 cur.next = cur.next.next;// 复制节点的指针指向复制链表的下一个节点 pre = pre.next;// 跳到原链表的下一个节点 cur = cur.next;// 跳到复制链表的下一个节点 &#125; pre.next = null; // 单独处理原链表尾节点 return res; // 返回新链表头节点 &#125;&#125;// 作者：jyd// 链接：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/jian-zhi-offer-35-fu-za-lian-biao-de-fu-zhi-ha-xi-/// 来源：力扣（LeetCode）// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 可以发现自己对链表还不够熟练，这道题要多加练习。"},{"title":"剑指offer-day1","path":"2022/04/07/剑指offer-day1/","text":"用两个栈实现队列简单且经典的题目，用两个栈来模拟一个队列。 设置两个栈s1和s2，s1用于正常模拟队列的进队。当队列需要出队时，要把是s1中的值依次放入s2，再在s2的栈顶删除s1的栈底元素（也就是队列的队头元素），然后将处理后的元素再依次放入s1中，就模拟了队列的出队过程。 此时需注意：删除元素应该有判空条件。 12345678910111213141516171819202122232425262728class CQueue &#123; Stack&lt;Integer&gt; s1;// 新建两个栈 Stack&lt;Integer&gt; s2; public CQueue() &#123;// 初始化 s1 = new Stack&lt;&gt;(); s2 = new Stack&lt;&gt;(); &#125; public void appendTail(int value) &#123;// 模拟进队 s1.push(value); &#125; public int deleteHead() &#123;// 模拟出队 if(s1.empty())&#123; return -1; &#125; while(!s1.empty())&#123; s2.push(s1.pop()); &#125; int res = s2.pop();// 需要出队的元素 while(!s2.empty())&#123; s1.push(s2.pop()); &#125; return res; &#125;&#125; 看评论说java的stack类会造成速度变慢，可以用LinkedList做容器，但是会不符合题目要求，可以作为优化的一种选项。 包含min函数的栈原本是简单题，但是因为自己想的太复杂了，迟迟没有做出来，参考了一下答案，才把思路理清（👎） 设置一个辅助栈supStack，用于记录主栈入栈操作时栈内的最小值。第一个入主栈的自然要记录，此后若有小于或等于辅助栈栈顶的数，则需要辅助栈将一个相同的数放入栈顶，反之则不用操作。出栈时则需要与辅助栈的栈顶比对，若相等则辅助栈也必须出栈。 123456789101112131415161718192021222324252627282930class MinStack &#123; Stack&lt;Integer&gt; mainStack;// 主栈 Stack&lt;Integer&gt; supStack;// 辅助栈 /** initialize your data structure here. */ public MinStack() &#123;// 初始化 mainStack = new Stack(); supStack = new Stack(); &#125; public void push(int x) &#123; mainStack.push(x); if(supStack.empty() || supStack.peek() &gt;= x)&#123;// 辅助栈空或大于等于要放入的值时，需放入一个同样的值 supStack.push(x); &#125; &#125; public void pop() &#123; if(mainStack.pop().equals(supStack.peek()))&#123;// 当出栈值与辅助栈栈顶相等时，辅助栈也要出栈 supStack.pop(); &#125; &#125; public int top() &#123;// 查看主栈的栈顶 return mainStack.peek(); &#125; public int min() &#123;// 查看辅助栈的栈顶 return supStack.peek(); &#125;&#125; 需要注意的是，pop()中需要使用equals方法而不是==，因为在Integer中，[-128,127]会被缓存记住，只有在这个范围内==才是比较数值，否则比较的是对象，会造成错误。 记忆点1234567// Java Stack类boolean empty();// 判断栈是否为空Object peek();// 返回栈顶Object pop();// 返回并删除栈顶Object push(Object element);// 在栈顶添加新元素int search();// 查找s内的值，返回其在栈内的位置，以1为基数"},{"title":"学习总结（2022.03.31-2022.04.06）","path":"2022/04/06/学习总结（2022-03-31-2022-04-06）/","text":"继承的限制 子类不可以继承父类的私有成员，因为没有访问权限。 子类不可以继承父类的构造器，因为构造器不能算成员。 子类可以访问父类的静态方法，但是并不是继承。 继承中的属性隐藏和方法覆盖对于成员变量的访问范围和访问结果都看引用类型。引用是父类则访问的是父类成员变量，子类则访问子类成员变量。 对于成员方法的访问范围如上相同，看引用类型。 对于成员方法的访问结果则看对象类型。对象是子类则可以调用子类方法、重写或没重写的父类方法，父类则只能调用父类方法。 final关键字final修饰类表示类不可被继承。 final修饰方法表示方法不可被重写，但可以被继承。 final修饰变量表示常量。与static一起用表示全局变量。 instanceof关键字用来判断一个类是否是某个类的子类，一般用于保证向下转型的安全。 抽象类（abstract）抽象类与普通类相同，但是多了一个抽象方法，即不需要实现该方法，而是让子类通过重写的方式来实现。抽象类和抽象类之间可以有继承关系，且继承的抽象类可以选择重写被继承抽象类的抽象方法。 接口（interface）接口是一种开发标准，表示对功能的扩展，只关注行为而不关注属性。一般用来抽象共性行为，与实现其的类为like-a关系。 接口不能创建对象，自然也没有构造器。 接口一般没有成员，只有抽象方法。 接口可以继承接口，但是接口和类之间不能发生继承，类只能实现(implement)接口。 内部类 成员内部类：与普通类相同，但是没有静态声明（允许有静态全局常量）；可以发生继承和实现；与外围类有强依赖关系，可以无视访问权限互相访问。 静态内部类：与普通类完全相同；可以发生继承和实现；与外围类为互相独立的关系，虽然访问不受访问权限限制，但是需要创建对象才可以访问。 局部内部类：不具有访问修饰权限；不具有静态声明；可以发生继承和实现；虽然可以访问外部类的成员，但是外部类无法访问局部内部类的成员。 Lambda表达式Lambda表达式是一种特殊的局部匿名内部类。必须在一个实现了功能接口（有且只有一个必须实现的抽象方法的接口）的类中定义。得到的是这个接口的子类对象。基本格式为： 123(形参列表) -&gt; &#123;// 方法体&#125; ()中是抽象方法的形参列表。 {}中是抽象方法的实现。 在写完Lambda表达式后，需要在表达式前面用(对象名)帮编译器明确对象类型。 Lambda表达式可以简化：当形参只有一个时，可以省略()；当方法体只有一条语句时（包括return语句），可以省略{}。 Lambda表达式的应用：将一个String对象数组映射为所有字符串长度的数组。 1234567891011121314151617181920212223242526/** * @author yzw * @since 2022/04/02 */public class HomeworkImpl &#123; public static void main(String[] args) &#123; String[] s = &#123;&quot;aaa&quot;,&quot;bb&quot;,&quot;c&quot;&#125;;// 实验数组 int[] sLength = mappingObjectLength(s,o -&gt; new int[s.length]);// mapping返回int数组 for(int i : sLength)&#123; System.out.println(i); &#125; &#125; public static int[] mappingObjectLength(Object[] obj, Map map)&#123; int[] result = map.mapping(obj); for (int i = 0; i &lt; obj.length; i++) &#123; result[i] = obj[i].toString().length(); &#125; return result; &#125;&#125;interface Map&#123; int[] mapping(Object o); //返回一个int数组表示每个元素的长度 Object.toString()toString()直接使用是打印对象的全限定类名 + @ + 对象的十六进制地址值。 可以通过重写来展示对象的状态。 Object.equals()和Object.hashcode()equals()直接使用是比较两个引用是否指向相同对象，可以通过重写来修改判断的条件（比如从比较对象的地址修改为比较对象的状态）。 重写遵从闭包原则，即 自反性。x.equals(x) == true 排他性。当比对的不是同种类型的对象或者是一个null时，默认返回false。 对称性。x.equals(y) == true -&gt; y.equals(x) == true。 传递性。x.equals(y) == true &amp;&amp; y.equals(z) == true -&gt; x.equals(z) == true。 其中自反性和排它性需要写代码做判断，而对称性，一致性，传递性，只需要用成员变量的取值来判断对象相等，就自动满足它们。 排他性的选择：getClass()（只能是相同的对象），instanceof（可以是对象的子类） 如果重写equals()，hashcode()也需要重写。因为逻辑上相等的两个对象必须有相同的hash值。 Object.clone()作用是获得一个独立的，与原对象成员一致的新对象。但是在默认的情况下，只能在子类内克隆自己，所以一般需要在类中重写该方法。其次，一个类想实现克隆，需要实现一个标记接口（不含任何抽象方法的接口）java.lang.Cloneable。 浅克隆：如果克隆的类中有引用类型变量，在克隆后该变量会与克隆前的类中的变量指向同一个对象，这样并不能说明这两个类是独立的，这叫做浅克隆。 深度克隆：在clone()中做出如下操作： 将引用指向的对象，也克隆一份。 然后让克隆后的引用指向它。 可以让克隆后的引用类型变量指向一个同样被克隆的新的对象，这样就实现了深度克隆。 示例代码： 123456789101112131415161718class Student&#123; Dog d; //重写clone方法的访问权限 @Override protected Student clone() throws CloneNotSupportedException &#123; //仍然选择调用父类默认实现 //深度克隆的步骤 //1.深度克隆是在浅克隆基础上完成的 Student cloneStu = (Student) super.clone(); //2.需要把Dog对象克隆一份 Dog cloneDog = cloneStu.d.clone(); //3.将拷贝引用指向拷贝对象 cloneStu.d = cloneDog; return cloneStu; //return ((Student) super.clone()); &#125;&#125;"},{"title":"学习总结（2022.03.21-2022.03.30）","path":"2022/04/06/学习总结（2022-03-21-2022-03-30）/","text":"JVM内存 JVM栈。方法执行时占用的内存空间，方法以栈帧形式存储，方法内的局部变量会直接存储在栈帧中，方法执行完毕后出栈销毁，局部变量也被销毁。 堆。存储对象。new关键字即是在堆上开辟空间给对象。当没有引用指向对象时，该对象会被垃圾回收器执行垃圾回收机制(GC)回收内存。 方法区。 本地方法栈。存储JVM的本地(native)方法。 程序计数器：记录当前执行的行数。 传参问题java是值传递，指调用方法时，传入的是实参的拷贝而不是实参本身。 所以下列代码是不可能得出a的两倍的。 123public static void sendIntValue(int a) &#123; a *= 2;&#125; 但是对引用数据类型而言，因为声明的是引用的拷贝，所以内存地址也是会被拷贝的。对引用数据类型进行修改，本身的引用不会发生改变，但是引用和引用的拷贝所指向的对象发生了改变。 所以下列代码b的后面是会加上.zip的。 123public static void sendStringtValue(String b) &#123; b += ”.zip“;&#125; 因为此时b和b的拷贝指向了新的对象b+.zip。 看起来似乎是引用传递，但是下列代码是一个反例。 123456public static void swapArray(int[] arr1,int[] arr2)&#123; int[] temp; temp = arr1; arr1 = arr2; arr2 = temp;&#125; 交换两个拷贝的值，其实就是在交换它们指向的对象，而原先的引用不受影响。在方法结束后，两个拷贝被销毁，交换失败。 类加载JVM认识一个我们创建的类，叫类加载。类加载在一次程序运行中只有一次，且类加载是懒加载的，一些场景会触发类加载，称为类加载的时机，有以下几种： 创建该类对象（new一个对象） 启动该类的main方法 访问某个类的静态成员（包括变量和方法） 子类类加载会触发父类类加载 static修饰的成员是随着类加载完毕就存在的，所以不需要创建对象就可以访问。 创建对象也不依赖于类加载。 类生命周期 类加载过程的三个步骤：加载，连接，初始化 加载主要是将class字节码读取进JVM 连接主要是将静态成员变量进行默认初始化，保证其永远最先进行。 初始化主要执行static相关的内容，包括为静态成员变量赋值，以及执行静态代码块。 成员变量的赋值方式和顺序 默认初始化 显式赋值 构造代码块 构造器赋值 其中默认初始化和构造器赋值永远是第一步和最后一步（掐头去尾） 创建对象过程中结构执行顺序（全） 类加载。首先程序要从有main方法的类中开始执行，所以要先对其进行类加载。（要考虑发生连环类加载的情况，首先有父类存在的话要先执行父类类加载，其次有静态成员变量或者静态代码块创建对象的话要先执行该对象的类加载） 执行静态成员变量的初始化。（包括显式赋值和静态代码块） 创建对象。首先找到对象的构造器，如果有显式调用其他构造器，则跳转至该构造器的类，执行构造代码块和显式赋值，最后执行该构造器。如果没有，则是跳转至父类的无参构造器（无父类则是跳转至Object，但是不影响），执行父类的构造代码块和显式赋值。"},{"title":"Github+hexo搭建博客遇到的坑","path":"2022/04/05/github+hexo搭建博客遇到的坑/","text":"hexo部署问题按照教程部署完后发现页面仍旧没法更改，折腾大半天后发现github最近将默认分支的名字从master改成了main，而_config.yml中一般都将branch设置为master，导致master成为了副分支，github pages默认应用主分支main，所以没法更改页面（所以说政治正确真是害死人…大家约定俗成的事说改就改） 部署慢问题还没有发现问题所在，大概只能理解成访问github困难导致即使push成功网页也会刷新不及时。 图片CDN问题nexmoe主题中的图片使用CDN保存，所以无法使用本地路径，但是图片也不能直接保存至username.github.io中，因为每次push都会导致仓库中保存的图片被删，所以在github中新建了一个仓库用来保存图片。 评论系统gitment已经停止使用！请用gitalk替代。"},{"title":"Hello World","path":"2022/04/05/hello-world/","text":"我的第一篇博客！希望可以一直用下去。"}]